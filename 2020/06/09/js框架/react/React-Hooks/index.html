<!DOCTYPE html><html lang="cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React-Hooks · 快乐的图小灵</title><meta name="description" content="React-Hooks - turing5467"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favi.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://turing5467.github.io/atom.xml" title="快乐的图小灵"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">图小灵的博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="https://github.com/turing5467" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React-Hooks</h1><div class="post-info">Jun 9, 2020</div><div class="post-content"><p><a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d" target="_blank" rel="noopener">引用文章1</a></p>
<h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><ul>
<li>Hooks 是 React 16.8 新增的特性，它可以让你在<strong>不编写 class</strong> 的情况下<strong>使用 state 以及其他的 React 特性(如生命周期)</strong> </li>
</ul>
<h3 id="Hooks解决的问题"><a href="#Hooks解决的问题" class="headerlink" title="Hooks解决的问题"></a>Hooks解决的问题</h3><h4 id="1-类组件的的不足"><a href="#1-类组件的的不足" class="headerlink" title="1.类组件的的不足"></a>1.类组件的的不足</h4><ul>
<li><p><strong>状态逻辑难复用</strong></p>
<p>在组件之间复用状态逻辑很难，可能要用到 <strong>render props</strong> （<strong>渲染属性</strong>）或者 <strong>HOC</strong>（<strong>高阶组件</strong>），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），<strong>导致层级冗余</strong> </p>
</li>
<li><p><strong>趋向复杂难以维护</strong></p>
<ul>
<li>在生命周期函数中混杂不相干的逻辑（如：在 <code>componentDidMount</code> 中注册事件以及其他的逻辑，在 <code>componentWillUnmount</code> 中卸载事件，这样分散不集中的写法，很容易写出 bug ）</li>
<li>组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件</li>
</ul>
</li>
<li><p><strong>this指向问题</strong></p>
<ul>
<li>父组件给子组件传递函数时，必须绑定 this </li>
<li>react 中的组件四种绑定 this 方法的区别 （ 前提：子组件内部做了性能优化）<ul>
<li><strong>构造函数中绑定 this</strong>：那么每次父组件刷新的时候，如果传递给子组件其他的 <code>props 值不变</code>，那么子组件就不会刷新；</li>
<li><strong>在 render() 函数里面绑定 this</strong>：因为 <strong>bind 函数会返回一个新的函数</strong>，所以每次父组件刷新时，<code>都会重新生成</code>一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新</li>
<li><strong>使用箭头函数</strong>：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件<code>每次都会刷新</code></li>
<li><strong>使用类的静态属性：原理和第一种方法差不多，比第一种更简洁</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Hooks优势"><a href="#2-Hooks优势" class="headerlink" title="2.Hooks优势"></a>2.Hooks优势</h4><ul>
<li>能优化类组件的三大问题 </li>
<li>能在无需修改组件结构的情况下<strong>复用状态逻辑</strong>：使用自定义 Hooks </li>
<li>能将组件中相互关联的部分拆分成更小的函数（如订阅、请求数据） ：<code>useEffect</code></li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614215115698.png" alt="image-20200614215115698"></p>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul>
<li>多次调用<code>useState</code>，渲染时调用顺序不变</li>
<li>重复渲染时保留<code>state</code></li>
<li>参数为初始<code>state</code></li>
<li>返回值为一个数组<ol>
<li>第一项为返回的<code>state</code></li>
<li>第二项为更新<code>state</code>的函数，不会合并新旧<code>state</code>，而是直接替换</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可以任意命名，因为返回的是数组，数组解构</span></span><br><span class="line"><span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="每次渲染都是独立的闭包"><a href="#每次渲染都是独立的闭包" class="headerlink" title="每次渲染都是独立的闭包"></a>每次渲染都是独立的闭包</h4><ul>
<li>每一次渲染都有它自己的 Props 和 State</li>
<li>每一次渲染都有它自己的事件处理函数</li>
<li>当点击更新状态的时候，函数组件都会重新被调用，那么每次渲染都是独立的，取到的值不会受后面操作的影响。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">TestCPN</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">alertNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// alert 只能获取到点击按钮时的那个状态</span></span><br><span class="line">        alert(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;alertNumber&#125;&gt;alertNumber&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击alertNumber =&gt;  (即使中间点击过+号)  =&gt; 弹出的值就是一开始的0</p>
<h4 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h4><ul>
<li>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将回调函数传递给 setState的参数。该回调函数将接收先前的 state，并返回一个更新后的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 这样每次执行时都会去获取一遍 state，而不是使用点击触发时的那个 state</span></span><br><span class="line">            setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">           &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">           &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">           &lt;button onClick=&#123;lazy&#125;&gt;lazy&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击lazy  =&gt; (期间点击+号) =&gt; 3秒后的number为多次点击+号后的结果</p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ul>
<li><p>effect(副作用)：指那些没有发生在数据向视图转换过程中的逻辑，如<code>ajax</code>请求，访问原生<code>dom</code>元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志。</p>
</li>
<li><p>副作用可分为两类：需要清除的、不需要清楚的</p>
</li>
<li><p><code>useEffect</code>就是一个effect Hook，给函数组件增加了操作副作用的能力。</p>
</li>
<li><p>它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API 。</p>
<p>与 <code>componentDidMount</code> 或 <code>didUpdate</code> 不同， <code>useEffect</code> 不会阻塞浏览器更新屏幕，这让你的应用看起来<strong>响应更快</strong>。 </p>
</li>
<li><p><code>useEffect</code><strong>接收一个函数</strong>，该函数会<strong>在组件渲染后才执行</strong>，该函数有要求：要么<strong>返回一个能清除副作用的函数</strong>，要么就<strong>不返回任何内容</strong></p>
</li>
</ul>
<h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><ul>
<li>可以通过给<code>useEffect</code>返回一个函数来指定如何清除副作用， 为防止内存泄漏，清除函数会在在组件卸载前执行</li>
<li>如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useEffect, useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> [text,setText] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="comment">// 相当于componentDidMount 和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">        <span class="keyword">let</span> $timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用</span></span><br><span class="line">        <span class="comment">// useEffect 在执行副作用函数之前，会先调用上一次返回的函数</span></span><br><span class="line">        <span class="comment">// 清除副作用: 返回一个清除副作用的函数</span></span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'destroy effect'</span>);</span><br><span class="line">            clearInterval($timer);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;input value=&#123;text&#125; onChange=&#123;(event)=&gt;setText(event.target.value)&#125;/&gt;</span><br><span class="line">          &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button&gt;+&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 通过使用 Hook，你可以把组件内<strong>相关的副作用</strong>组织在一起（例如创建订阅及取消订阅），而不要把它们拆分到不同的生命周期函数里。 </p>
</blockquote>
<h4 id="跳过effect进行性能优化"><a href="#跳过effect进行性能优化" class="headerlink" title="跳过effect进行性能优化"></a>跳过effect进行性能优化</h4><ul>
<li>依赖项数组控制着useEffect的执行</li>
<li>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用：传递数组作为 <code>useEffect</code>的第二个可选参数即可 </li>
<li>如果想执行<strong>只运行一次的 effect</strong>（仅在组件挂载和卸载时执行），可以传递一个空数组<code>[]</code>作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 </li>
</ul>
<h4 id="使用多个Effect实现关注点分离"><a href="#使用多个Effect实现关注点分离" class="headerlink" title="使用多个Effect实现关注点分离"></a>使用多个Effect实现关注点分离</h4><ul>
<li>解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。 </li>
<li>例如 ：设置 <code>document.title</code> 的逻辑被分割到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 中，订阅逻辑又被分割到 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 中的，而<code>componentDidMount</code>中同时包含了两个不同功能的代码。这样会使<strong>生命周期函数变得混乱</strong></li>
<li><strong>Hook 允许我们按照代码的用途分离他们</strong> </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//设置document.title逻辑</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">          setIsOnline(status.isOnline);</span><br><span class="line">      &#125;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟ComponentDidUpdate"><a href="#模拟ComponentDidUpdate" class="headerlink" title="模拟ComponentDidUpdate"></a>模拟ComponentDidUpdate</h4><p> <code>componentDidUpdate</code>就相当于除去第一次调用的<code>useEffect</code>，我们可以借助<code>useRef</code>生成一个标识，来记录是否为第一次执行： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDidUpdate</span>(<span class="params">callback, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> init = useRef(<span class="literal">true</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.current) &#123;</span><br><span class="line">      init.current = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟ComponentDidMount"><a href="#模拟ComponentDidMount" class="headerlink" title="模拟ComponentDidMount"></a>模拟ComponentDidMount</h4><p><code>componentDidMount</code>等价于<code>useEffect</code>的回调仅在页面初始化完成后执行一次，当<code>useEffect</code>的第二个参数传入一个空数组时可以实现这个效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function useDidMount(callback) &#123;</span><br><span class="line">  useEffect(callback, []);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方不推荐上面这种写法，因为这有可能导致一些错误。</p>
</blockquote>
<h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p> <img src="https://user-gold-cdn.xitu.io/2019/11/1/16e25d2b5844206c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p>
<ul>
<li><p><code>useEffect</code>在全部渲染完毕后才会执行</p>
</li>
<li><p><code>useLayoutEffect</code>会在 浏览器 <code>layout</code>之后，<code>painting</code>之前执行</p>
</li>
<li><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect</p>
</li>
<li><p>可以使用它来读取 DOM 布局并<strong>同步触发重渲染</strong></p>
</li>
<li><p>在浏览器执行绘制之前 <code>useLayoutEffect</code>内部的更新计划将被<strong>同步</strong>刷新</p>
</li>
<li><p><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useLayoutEffect,useEffect, useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">LayoutEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = useState(<span class="string">'red'</span>);</span><br><span class="line">    useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        alert(color);</span><br><span class="line">    &#125;);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'color'</span>, color);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div id=<span class="string">"myDiv"</span> style=&#123;&#123; <span class="attr">background</span>: color &#125;&#125;&gt;颜色&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setColor('red')&#125;&gt;红&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setColor(<span class="string">'yellow'</span>)&#125;&gt;黄&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setColor('blue')&#125;&gt;蓝&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">alert(<span class="string">'red'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'red'</span>)</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<h4 id="惰性初始化state"><a href="#惰性初始化state" class="headerlink" title="惰性初始化state"></a>惰性初始化state</h4><ul>
<li><code>initialState</code>参数只会在组件的<strong>初始化渲染</strong>中起作用，后续渲染时会被忽略</li>
<li>如果初始 state 需要通过复杂计算获得，则可以<strong>传入一个函数</strong>，在函数中计算并返回初始的 state，此函数只在<strong>初始渲染</strong>时被调用</li>
</ul>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><ul>
<li><p>接收一个 <code>context</code>对象（<code>React.createContext</code> 的返回值）并返回该 <code>context</code></p>
</li>
<li><p>当前的 <code>context</code>值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code>决定</p>
</li>
<li><p>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染</p>
</li>
<li><p><code>useContext(MyContext)</code> 相当于 class 组件中的  <code>&lt;MyContext.Consumer&gt;</code></p>
</li>
<li><p><code>useContext(MyContext)</code> 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用  来为下层组件提供 context</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button style=&#123;&#123; <span class="attr">background</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Toolbar /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><ul>
<li><code>useReducer</code>和 redux 中的 reducer 很像</li>
<li><code>useState</code>内部就是靠 <code>useReducer</code>来实现的</li>
<li><code>useState</code>的替代方案，它接收一个形如 <code>(state, action) =&gt; newState</code>的 reducer，并返回当前的 <code>state</code>以及与其配套的 <code>dispatch</code>方法</li>
<li>在某些场景下，<code>useReducer</code>会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一种传参方式：reducer, initialState</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值：initialState</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第二种传参方式：(reducer, initFnParam, initFn)</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">		&#123;<span class="comment">/* payload为额外参数，传入reducer.action */</span>&#125;</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="useMemo-amp-amp-useCallBack"><a href="#useMemo-amp-amp-useCallBack" class="headerlink" title="useMemo &amp;&amp; useCallBack"></a>useMemo &amp;&amp; useCallBack</h3><ul>
<li>默认情况，只要父组件状态变了（不管子组件依不依赖该状态），子组件也会重新渲染</li>
<li>优化<ol>
<li>类组件：可以使用<code>PureComponent</code></li>
<li>函数组件：使用<code>React.memo</code>， 将函数组件传递给 <code>memo</code> 之后，就会返回一个新的组件，新组件的功能：<strong>如果接受到的属性不变，则不重新渲染函数</strong>； </li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,memo, useMemo,useCallback&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCounter</span>(<span class="params">&#123;onClick,data&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'SubCounter render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;&#123;data.number&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/返回新组件：接收属性不变，则不重新渲染函数</span></span><br><span class="line"><span class="regexp">SubCounter = memo(SubCounter);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export  default  function Counter4()&#123;</span></span><br><span class="line"><span class="regexp">    console.log('Counter4 render');</span></span><br><span class="line"><span class="regexp">    const [name,setName]= useState('计数器');</span></span><br><span class="line"><span class="regexp">    const [number,setNumber] = useState(0);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/组件更新时，变量和函数每次都会重新创建，那么子组件接受到的属性每次都会认为是新的</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/因此需要使用useMemo：缓存&lt;变量&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/注意：必须传递第二个参数：依赖项数组，否则还是会重新渲染</span></span><br><span class="line"><span class="regexp">    const data =useMemo(() =&gt;(&#123;number&#125;), [number]);</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/useCallback: 缓存&lt;函数&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/注意：必须传递第二个参数：依赖项数组，否则还是会重新渲染</span></span><br><span class="line"><span class="regexp">    const addClick = useCallback(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">        setNumber(number+1);</span></span><br><span class="line"><span class="regexp">    &#125;, [number]);</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;input type="text" value=&#123;name&#125; onChange=&#123;(e)=&gt;setName(e.target.value)&#125;/</span>&gt;</span><br><span class="line">            &lt;SubCounter data=&#123;data&#125; onClick=&#123;addClick&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 你也可以通过给<code>React.memo</code>的第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。 </p>
</blockquote>
<blockquote>
<p>useCallback的依赖项如果时<code>空数组</code>只会在挂载阶段执行；</p>
<p>如果依赖项是一个<code>变化的值</code>，那么在依赖项变化的时候执行；</p>
<p>如果<code>不传</code>第二个参数，那么每次都会执行 </p>
</blockquote>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul>
<li><strong>类组件</strong>使用 <code>React.createRef</code>，<strong>函数组件</strong>使用 <code>useRef</code><ol>
<li>useRef 返回的 ref 对象在组件的<strong>整个生命周期内保持不变</strong>，也就是说每次重新渲染函数组件时，返回的ref 对象都是同一个</li>
<li>使用 <code>React.createRef</code>，每次重新渲染组件都会重新创建 ref</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现类似实例变量的东西"><a href="#实现类似实例变量的东西" class="headerlink" title="实现类似实例变量的东西"></a>实现类似实例变量的东西</h4><p> <code>useRef()</code> Hook 不仅可以用于 DOM refs。</p>
<p>「ref」 对象是一个 <code>current</code> 属性可变且可以容纳任意值的通用容器，类似于一个 class 的实例属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> intervalRef = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    intervalRef.current = timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearInterval(intervalRef.current);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何测量DOM节点"><a href="#如何测量DOM节点" class="headerlink" title="如何测量DOM节点"></a>如何测量DOM节点</h4><p> 获取 DOM 节点的位置或是大小的基本方式是使用 <a href="https://react.docschina.org/docs/refs-and-the-dom.html#callback-refs" target="_blank" rel="noopener">callback ref</a>。每当 ref 被附加到一个另一个节点，React 就会调用 callback。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MeasureExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [height, setHeight] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> measuredRef = useCallback(<span class="function"><span class="params">node</span> =&gt;</span> &#123;    </span><br><span class="line">      <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;     </span><br><span class="line">          setHeight(node.getBoundingClientRect().height);    </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 ref=&#123;measuredRef&#125;&gt;Hello, world&lt;<span class="regexp">/h1&gt;      </span></span><br><span class="line"><span class="regexp">	  &lt;h2&gt;The above header is &#123;Math.round(height)&#125;px tall&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>  我们没有选择使用 <code>useRef</code>，因为当 ref 是一个对象时它并不会把当前 ref 的值的 <em>变化</em> 通知到我们。  使用 callback ref 可以确保 即便子组件延迟显示被测量的节点(比如为了响应一次点击)，我们依然能够在父组件接收到相关的信息，以便更新测量结果。 </p>
<p> 注意到我们传递了 <code>[]</code> 作为 <code>useCallback</code> 的依赖列表。这确保了 ref callback 不会在再次渲染时改变，因此 React 不会在非必要的时候调用它。 </p>
<h4 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h4><ul>
<li><strong>因为函数组件没有实例，所以函数组件无法像类组件一样可以接收 ref 属性</strong> ：<code>&lt;Child ref={xxx} /&gt;</code>是不行的</li>
<li>forwardRef 可以在父组件中操作<strong>子组件</strong>的 ref 对象</li>
<li>forwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props,ref</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> ref=&#123;ref&#125;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1（相较普通ref多的一步）</span></span><br><span class="line">Child = React.forwardRef(Child);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>); </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();<span class="comment">//&#123;current:''&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    inputRef.current.value = <span class="string">'focus'</span>;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      	<span class="comment">/* 3 */</span></span><br><span class="line">        &lt;Child ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;setNumber(&#123;<span class="attr">number</span>:number+<span class="number">1</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><ul>
<li><code>useImperativeHandle</code>可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛 </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useRef,forwardRef,useImperativeHandle&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props, ref</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> focusRef = useRef();</span><br><span class="line">    <span class="keyword">let</span> inputRef = useRef();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父组件将要传进来的ref</span></span><br><span class="line">    useImperativeHandle(ref,()=&gt;&#123;</span><br><span class="line">      <span class="comment">// 这个函数会返回一个对象，作为父组件 current 属性的值</span></span><br><span class="line">      <span class="comment">// 通过这种方式，父组件可以使用操作子组件中的多个 ref</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            focusRef,</span><br><span class="line">            inputRef,</span><br><span class="line">            name:<span class="string">'计数器'</span>,</span><br><span class="line">            focus()&#123;</span><br><span class="line">                focusRef.current.focus();</span><br><span class="line">            &#125;,</span><br><span class="line">            changeText(text)&#123;</span><br><span class="line">                inputRef.current.value = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input ref=&#123;focusRef&#125;/&gt;</span><br><span class="line">            &lt;input ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Child = forwardRef(Child);</span></span><br><span class="line"><span class="regexp">export default function Parent()&#123;</span></span><br><span class="line"><span class="regexp">  const parentRef = useRef();/</span><span class="regexp">/&#123;current:''&#125;</span></span><br><span class="line"><span class="regexp">  function getFocus()&#123;</span></span><br><span class="line"><span class="regexp">    parentRef.current.focus();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效，不注释会报错</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ parentRef.current.addNumber(666);</span></span><br><span class="line"><span class="regexp">    parentRef.current.changeText('&lt;script&gt;alert(1)&lt;/</span>script&gt;<span class="string">');</span></span><br><span class="line"><span class="string">    console.log(parentRef.current.name);//计数器</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">      &lt;&gt;</span></span><br><span class="line"><span class="string">        &lt;Child ref=&#123;parentRef&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h3><p>自定义 Hook 更像是一种约定，而不是一种功能。</p>
<p>如果函数的名字以 <code>use</code> 开头，并且<strong>调用了其他的 Hook</strong>，则就称其为一个<strong>自定义 Hook</strong></p>
<p>有时候我们会想要在组件之间<strong>重用一些状态逻辑</strong>，之前要么用 render props ，要么用高阶组件，要么使用 redux。自定义 Hook 可以让你在不增加组件的情况下达到同样的目的</p>
<blockquote>
<p> 每个组件调用同一个 hook，只是复用 hook 的状态逻辑，并<strong>不会共用一个状态</strong> 。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;,[]);</span><br><span class="line">  <span class="keyword">return</span> [number,setNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>只能在<strong>函数最外层</strong>调用 Hook 。不要在循环，条件或嵌套函数中调用Hook。 </p>
<p><code>Hook</code>通过数组实现的，每次<code>useState</code> 都会改变下标，<code>React</code>需要利用调用顺序来正确更新相应的状态，如果<code>useState</code> 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。 </p>
</li>
<li><p>只能在 <strong>React 的函数组件</strong>中调用 Hook。 （自定义Hook除外）</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2020/06/11/面试/128/" class="prev">PREV</a><a href="/2020/06/07/面试/5467/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/06/09/js框架/react/React-Hooks/';
var disqus_title = 'React-Hooks';
var disqus_url = 'https://turing5467.github.io/2020/06/09/js框架/react/React-Hooks/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2019 - 2020 <a href="https://turing5467.github.io">turing5467</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>