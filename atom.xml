<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>快乐的图小灵</title>
  
  <subtitle>用猛烈的孤独，开启你伟大的冒险</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://turing5467.github.io/"/>
  <updated>2020-08-30T13:47:57.660Z</updated>
  <id>https://turing5467.github.io/</id>
  
  <author>
    <name>turing5467</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java入门</title>
    <link href="https://turing5467.github.io/2020/08/30/Java/Java/"/>
    <id>https://turing5467.github.io/2020/08/30/Java/Java/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2020-08-30T13:47:57.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Win10环境搭建"><a href="#Win10环境搭建" class="headerlink" title="Win10环境搭建"></a>Win10环境搭建</h3><ul><li><p>jdk安装地址：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p></li><li><p>配置<strong>系统</strong>环境变量</p><ul><li><p>新增<code>Java_Home</code>：jdk安装路径，如<code>D:\Program Files\jdk1.8.0_206</code></p></li><li><p>点击<code>Path</code>：点击编辑文本，最前面加<code>%Java_Home%\bin;%Java_Home%\jre\bin;</code></p></li><li><p>新增<code>CLASSPATH</code>：值为<code>.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar</code></p></li></ul></li><li><p>检测是否安装成功</p><ul><li><code>Win + r</code> =&gt; <code>cmd</code> =&gt; <code>javac</code> + <code>java</code> =&gt; 有一堆命令出来则表示安装成功</li></ul></li><li><p>安装IDEA，开始写代码吧</p></li></ul><h4 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h4><ul><li><p>安装：<a href="http://maven.apache.org/，选择`.bin.zip`版本" target="_blank" rel="noopener">http://maven.apache.org/，选择`.bin.zip`版本</a></p></li><li><p>解压</p></li><li><p>新建一个文件夹，用作maven仓库</p></li><li><p>打开<code>conf/setting.xml</code></p><p><code>&lt;settings&gt;</code>下添加一行<code>&lt;localRepository&gt;maven仓库地址&lt;/localRepository&gt;</code></p><p><code>&lt;mirrons&gt;</code>下添加一段（配置阿里云镜像）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><ul><li><code>MAVEN_HOME</code>：maven安装路径</li><li><code>Path</code>：添加<code>%MAVEN_HOME%\bin</code></li><li>检查是否成功配置：<code>mvn -version</code></li></ul></li></ul><ul><li><p>创建项目：<a href="https://www.cnblogs.com/xihehua/p/9639045.html" target="_blank" rel="noopener">参考</a></p></li><li><p>安装插件：Setting =&gt; plugins =&gt; alibaba java code + lombok</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h2&gt;&lt;h3 id=&quot;Win10环境搭建&quot;&gt;&lt;a href=&quot;#Win10环境搭建&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Taro</title>
    <link href="https://turing5467.github.io/2020/08/23/%E5%B7%A5%E7%A8%8B%E5%8C%96/Taro/"/>
    <id>https://turing5467.github.io/2020/08/23/工程化/Taro/</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-08-25T16:17:35.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Taro"><a href="#Taro" class="headerlink" title="Taro"></a>Taro</h2><ul><li><p><strong>Taro</strong> 是一个开放式<strong>跨端跨框架</strong>解决方案 ，支持React、Vue等框架开发。</p></li><li><p>支持的终端</p><ul><li>微信小程序，百度/支付宝/字节跳动小程序、QQ轻应用</li><li>H5移动端Web页面（如微信小程序）</li><li>ReactNative（原生App）</li></ul></li><li><p>优点：一次开发、多端运行^.^</p><ol><li>编译多端：通过自身编译工具，编译成不同环境下的代码，实现多端运行</li><li>React语法规范：允许我们使用JSX和React相关的语法（包括Hooks）</li><li>组件开发：小程序的组件化并不是做的很好，使用Taro可以弥补这种不足</li><li>支持Typescript语法</li><li>开发流程自动化：使程序员集中精力在业务本身身上</li></ol></li></ul><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol><li><p>安装Taro脚手架：<code>npm i -g @tarojs/cli</code> 或 <code>yarn global add @tarojs/cli</code></p></li><li><p>初始化一个项目：<code>taro init myDemo1</code></p><p>填写项目基本信息及配置</p></li><li><p>启用taro编译工具（热部署）：<code>yarn dev:h5</code></p><p><code>dev</code>表示开发模式</p><p>后缀表示编译模式：微信小程序后缀为<code>wxapp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">微信：wxapp</span><br><span class="line">百度：swan</span><br><span class="line">支付宝：alipay</span><br><span class="line">H5: h5</span><br><span class="line">ReactNative：rn</span><br><span class="line">字节跳动：tt</span><br><span class="line">qq：qq</span><br><span class="line">快应用：quickapp</span><br></pre></td></tr></table></figure></li></ol><h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><ol><li><p><code>taro update self</code>：更新到最新版本</p></li><li><p><code>taro doctor</code>：诊断项目的依赖、设置、结构，以及代码的规范是否存在问题，并尝试给出解决方案。</p></li><li><p><code>Taro create --name [页面名称]</code>：快速创建新页面</p></li><li><p>cli命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看用法</span></span><br><span class="line">$ taro config --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 设置配置项&lt;key&gt;的值为&lt;value&gt;</span></span><br><span class="line">$ taro config <span class="built_in">set</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="comment"># 读取配置项&lt;key&gt;</span></span><br><span class="line">$ taro config get &lt;key&gt;</span><br><span class="line"><span class="comment"># 删除配置项&lt;key&gt;</span></span><br><span class="line">$ taro config delete &lt;key&gt;</span><br><span class="line"><span class="comment"># 打印所有配置项</span></span><br><span class="line">$ taro config list [--json]</span><br></pre></td></tr></table></figure></li></ol><h4 id="taro-微信小程序"><a href="#taro-微信小程序" class="headerlink" title="taro-微信小程序"></a>taro-微信小程序</h4><ul><li><p>编译命令：``yarn dev:weapp`</p></li><li><p>预览小程序：打开微信开发者工具，选择项目的dist目录即可</p></li><li><p><a href="https://taro-docs.jd.com/taro/docs/GETTING-STARTED" target="_blank" rel="noopener">其它命令见</a></p></li></ul><h4 id="设计稿及尺寸单位"><a href="#设计稿及尺寸单位" class="headerlink" title="设计稿及尺寸单位"></a>设计稿及尺寸单位</h4><p><a href="https://taro-docs.jd.com/taro/docs/size" target="_blank" rel="noopener">文档</a></p><ul><li><p>Taro推荐使用<code>px</code>或<code>%</code>，因为在编译过程中会自动转换为<code>rpx</code>或<code>rem</code></p></li><li><p>Taro默认设计稿以750px为标准， 如果不是，则修改项目配置 <code>config/index.js</code> 中的 <code>designWidth</code>  即可。</p><p>不过也只默认支持640、750、828尺寸的设计稿</p></li><li><p>其它尺寸需要在<code>DEVICE_RATIO</code>中添加换算规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEVICE_RATIO = &#123;</span><br><span class="line">  <span class="string">'640'</span>: <span class="number">2.34</span> / <span class="number">2</span>,</span><br><span class="line">  <span class="string">'750'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'828'</span>: <span class="number">1.81</span> / <span class="number">2</span>,</span><br><span class="line">  <span class="string">'375'</span>: <span class="number">2</span> / <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>行内样式可使用<code>Taro.pxTransform (num)</code></p></li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-config  // 项目配置</span><br><span class="line">-dist // 编译器生成的代码</span><br><span class="line">-src //项目源代码</span><br><span class="line">-pages//页面</span><br><span class="line">app.js</span><br><span class="line">app.less</span><br><span class="line">app.config.js  //项目配置，可以配置路由及项目样式，类似小程序的app.json</span><br><span class="line">.eslintrc</span><br><span class="line">.gitignore</span><br><span class="line">package.json  //项目包管理</span><br><span class="line">project.config.json  //项目配置文件</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><p>组件使用：</p><ul><li>在小程序端， 可以使用所有的小程序原生组件 </li><li>H5端：需引入<code>@tarojs/components</code></li><li>RN端：需引入<code>@tarojs/components-rn</code></li></ul><p><code>import Tarp from &#39;@tarojs/taro&#39;</code></p></li><li><p>其他使用同React</p></li><li><p>图为使用Hooks的组件编写demo</p></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200823195301698.png" alt="image-20200823195301698"></p><h4 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h4><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><ul><li>如果是项目中的静态图片，不可直接使用路径，需要先引入图片</li><li>因为项目编译后图片的路径会发生改变</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nana <span class="keyword">from</span> <span class="string">'../../static/nana.jpg'</span></span><br><span class="line">&lt;Image src=&#123;nana&#125; width=<span class="string">"100px"</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p><a href="https://taro-docs.jd.com/taro/docs/hooks" target="_blank" rel="noopener">链接</a></p><ul><li>在 Taro 中使用 Hooks API 很简单，Taro 的专有 Hooks（例如 <code>usePageScroll</code>, <code>useReachBottom</code>）从 <code>@tarojs/taro</code> 中引入，框架自己的 Hooks 从对应的框架引入。 </li></ul><ol><li><p><code>useDidShow</code>：等同于<code>componentDidShow</code>生命周期</p></li><li><p><code>useDidHide</code>：等同于<code>componentDidHide</code>生命周期</p></li><li><p><code>usePullDownRefresh</code>： 等同于 <code>onPullDownRefresh</code> 页面生命周期钩子 </p></li><li><p><code>useReachBottom</code>： 等同于 <code>onReachBottom</code> 页面生命周期钩子 </p></li><li><p><code>usePageScroll</code>： 等同于 <code>onPageScroll</code> 页面生命周期钩子 </p></li><li><p><code>useResize</code>： 等同于 <code>onResize</code> 页面生命周期钩子 </p></li><li><p><code>useShareAppMessage</code>： 等同于 <code>onShareAppMessage</code> 页面生命周期钩子 ，使用此 Hook 时必须在<code>page.config.js</code>配置<code>enableShareAppMessage: true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  useShareAppMessage(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.from === <span class="string">'button'</span>) &#123;</span><br><span class="line">      <span class="comment">// 来自页面内转发按钮</span></span><br><span class="line">      <span class="built_in">console</span>.log(res.target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">'自定义转发标题'</span>,</span><br><span class="line">      path: <span class="string">'/page/user?id=123'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// page.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  enableShareAppMessage: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p><code>useTabItemTap</code>：等同于 <code>onTabItemTap</code> 页面生命周期钩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useTabItemTap(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.index)</span><br><span class="line">  <span class="built_in">console</span>.log(item.pagePath)</span><br><span class="line">  <span class="built_in">console</span>.log(item.text)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>useRouter</code></p></li><li><p><code>useReady</code>： 等同于页面的 <code>onReady</code> 生命周期钩子。 </p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useTabItemTap(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.index)</span><br><span class="line">  <span class="built_in">console</span>.log(item.pagePath)</span><br><span class="line">  <span class="built_in">console</span>.log(item.text)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li>跳转：<ol><li><code>navigateTo({url})</code>： 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。 （若需要传参，参数写在url末尾）</li><li><code>redirectTo</code>： 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 </li><li><code>switchTab</code>：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</li><li><code>navigateBack</code>：返回上级页面</li><li><code>relaunch</code>： 关闭所有页面，打开到应用内的某个页面 </li><li><code>getCurrentPages</code>：获取当前页面信息，H5不支持</li></ol></li></ul><blockquote><p> 小程序中页面栈最多十层。 </p></blockquote><ul><li>获路由参数：<code>this.$router.params.paramName</code></li></ul><h3 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h3><ul><li><code>Taro.request({url, })</code>：返回一个Promise对象，可以<code>then</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Taro&quot;&gt;&lt;a href=&quot;#Taro&quot; class=&quot;headerlink&quot; title=&quot;Taro&quot;&gt;&lt;/a&gt;Taro&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Taro&lt;/strong&gt; 是一个开放式&lt;strong&gt;跨端跨框架&lt;/strong&gt;解决方
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://turing5467.github.io/2020/08/08/%E5%85%B6%E4%BB%96/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B/"/>
    <id>https://turing5467.github.io/2020/08/08/其他/上传文件流程/</id>
    <published>2020-08-08T06:02:44.655Z</published>
    <updated>2020-08-08T09:56:55.345Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="将"><a href="#将" class="headerlink" title="将"></a>将</h2><h2 id="概念了解"><a href="#概念了解" class="headerlink" title="概念了解"></a>概念了解</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul><li>CDN：内容分发网络：将本来咋多个点的内容分发到全国各地的节点，用户访问时就近访问。</li><li>优点：节省带宽费用</li><li>哪些内容可以分发？<ul><li>静态内容：包括图片、视频、音频、JS文件、CSS文件、静态页面等<ul><li>图片和音视频有个特点，带宽占用量高，如果不走CDN，使用带宽硬扛，价格太贵，对于初创公司无法承担。</li><li>这时CDN的价值就体现出来了，把静态文件分发到CDN上，访问静态文件走CDN流量，正常情况下CDN流量仅相当于带宽费用的1/4。</li></ul></li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Upload组件</span><br><span class="line"><span class="tag">&lt;<span class="name">Upload</span></span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">    <span class="attr">beforeUpload</span>=<span class="string">&#123;this.beforeImgUpload.bind(this,</span> <span class="attr">field</span>)&#125;</span></span><br><span class="line"><span class="tag">    <span class="attr">data</span>=<span class="string">&#123;this.getData&#125;</span></span></span><br><span class="line"><span class="tag">    // <span class="attr">onChange</span>=<span class="string">&#123;this.handleChangeImg&#125;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">customRequest</span>=<span class="string">&#123;window.uploadType</span> === <span class="string">1</span> ? <span class="attr">undefined</span> <span class="attr">:</span> <span class="attr">this.getCustomRequest</span>&#125;</span></span><br><span class="line"><span class="tag">     <span class="attr">accept</span>=<span class="string">".doc,.docx,.xlsx,.pdf"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="tag">&lt;<span class="name">Button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">type</span>=<span class="string">&#123;loading</span> &amp;&amp; <span class="attr">curUploadFieldKey</span> === <span class="string">fieldKey</span> ? '<span class="attr">loading</span>' <span class="attr">:</span> '<span class="attr">upload</span>'&#125; /&gt;</span>上传文件</span><br><span class="line">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">Upload</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="上传前"><a href="#上传前" class="headerlink" title="上传前"></a>上传前</h3><ul><li><p><code>accept</code>：接收文件类型</p></li><li><p><code>beforeUpload</code>：对上传文件大小、类型做限制，不符合要求则<code>return false</code>或<code>return Promise.reject()</code>反之亦然。</p><ul><li>获取上传文件的token：设置全局上传服务器主机名及使用私有云或公有云</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUploadToken = <span class="function">(<span class="params">params = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        xhr(&#123;</span><br><span class="line">            method: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'/wechat_api/qiniu/getUploadToken'</span>,</span><br><span class="line">            body: params</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(response)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">getToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    getUploadToken().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.code === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.data.type === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.token = res.data.cred</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> cred = res.data.cred || <span class="string">'&#123;&#125;'</span></span><br><span class="line">                <span class="keyword">let</span> params = <span class="built_in">JSON</span>.parse(cred)</span><br><span class="line">                <span class="keyword">if</span> (!isEmpty(params)) <span class="keyword">this</span>.token = params.token</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置全局上传服务器主机名, 使用私有云或公有云</span></span><br><span class="line">            <span class="keyword">this</span>.authKey = res.data.authKey</span><br><span class="line">            <span class="built_in">window</span>.cosHost = res.data.host</span><br><span class="line">            <span class="built_in">window</span>.isPrivate = res.data.isPrivate</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">beforeImgUpload = <span class="function">(<span class="params">field, file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">curUploadFieldKey</span>: field.fieldKey&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'file.size'</span>, field.fieldKey, file.size)</span><br><span class="line">    <span class="keyword">const</span> isLt5M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">const</span> isLt20M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &lt; <span class="number">20</span></span><br><span class="line">    <span class="keyword">if</span> (field.fieldType === <span class="number">6</span> &amp;&amp; !isLt5M) &#123;</span><br><span class="line">        message.error(<span class="string">'图片大小不宜超过5MB!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (field.fieldType === <span class="number">7</span> &amp;&amp; !isLt20M) &#123;</span><br><span class="line">        message.error(<span class="string">'附件大小不宜超过20MB!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.token) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.uploadType === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getToken()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><ul><li>根据<code>window.uploadType</code>选择是否使用自定义上传<ul><li>1：action + data上传</li><li>其他：customRequest上传</li></ul></li></ul><h4 id="自定义上传"><a href="#自定义上传" class="headerlink" title="自定义上传"></a>自定义上传</h4><ul><li><p>customRequest(info)：</p><ol><li><p>使用FileReader类读取文件（有必要吗？-因为后面没用到reader）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; file &#125; = info</span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">reader.readAsDataURL(file)</span><br><span class="line"><span class="keyword">await</span> reader.onloadend</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>获取上传文件的token，主要是获取文件上传路径</p><ol><li><p>getUploadToken接口</p><ul><li><p>传入参数：url、prefix</p></li><li><p>返回对象，具有属性：isPrivate、host、key</p><ul><li>host + key为文件地址</li></ul></li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="built_in">parseInt</span>(moment().format(<span class="string">'x'</span>), <span class="number">10</span>)&#125;</span><span class="subst">$&#123;getRanStr(<span class="number">3</span>)&#125;</span>`</span>&#125;</span>/<span class="subst">$&#123;file.name&#125;</span>`</span></span><br><span class="line"><span class="keyword">let</span> getUploadTokenRes = <span class="keyword">await</span> getUploadToken(&#123; <span class="attr">key</span>: url, <span class="attr">prefix</span>: <span class="string">'robot'</span> &#125;)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>将文件上传至云服务器</p><ul><li>根据传入type(？-如何判断)选择上传的服务器：1七牛云，2OSS，3COS</li><li>根据情况选择是否上传至CDN？-：<code>/wechat_api/sns/uploadToCdn</code></li><li>更新页面数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">getCustomRequest = <span class="keyword">async</span>(info) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">loading</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// const &#123; imgType &#125; = this.props</span></span><br><span class="line">        <span class="comment">// let prefix = imgType === 0 ? 'headimg' : 'sns'</span></span><br><span class="line">        <span class="keyword">const</span> &#123; file &#125; = info</span><br><span class="line">        <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">        reader.readAsDataURL(file)</span><br><span class="line">        <span class="keyword">await</span> reader.onloadend</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="built_in">parseInt</span>(moment().format(<span class="string">'x'</span>), <span class="number">10</span>)&#125;</span><span class="subst">$&#123;getRanStr(<span class="number">3</span>)&#125;</span>`</span>&#125;</span>/<span class="subst">$&#123;file.name&#125;</span>`</span></span><br><span class="line">        <span class="keyword">let</span> getUploadTokenRes = <span class="keyword">await</span> getUploadToken(&#123; <span class="attr">key</span>: url, <span class="attr">prefix</span>: <span class="string">'robot'</span> &#125;)</span><br><span class="line">        <span class="keyword">if</span> (getUploadTokenRes.code === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">window</span>.isPrivate = getUploadTokenRes.data.isPrivate</span><br><span class="line">            <span class="built_in">window</span>.cosHost = getUploadTokenRes.data.host</span><br><span class="line">            <span class="keyword">let</span> key = getUploadTokenRes.data.key</span><br><span class="line">            uploadCloudFile(getUploadTokenRes.data.type, getUploadTokenRes, key, file, info).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="keyword">let</span> params = &#123;</span><br><span class="line">                        key: key.substring(<span class="number">1</span>),</span><br><span class="line">                        cosUrl: res</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// const uin = this.props.adminUserInfo.uin</span></span><br><span class="line">                    <span class="comment">// if (imgType === 1) this.uploadToCdn(&#123; imgUrl: res, uin: uin, cmdId: key &#125;)</span></span><br><span class="line">                    <span class="keyword">this</span>.handleChangeModalOrder(<span class="keyword">this</span>.state.curUploadFieldKey, res)</span><br><span class="line">                    <span class="comment">// if (field.fieldType === 6) &#123;</span></span><br><span class="line">                        <span class="keyword">this</span>.setState(&#123;<span class="attr">loading</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">                    <span class="comment">// &#125;else if (field.fieldType === 7) &#123;</span></span><br><span class="line">                    <span class="comment">//     this.setState(&#123;isInvoiceUpload: false&#125;)</span></span><br><span class="line">                    <span class="comment">// &#125;</span></span><br><span class="line">                    info.onSuccess(params)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="非自定义"><a href="#非自定义" class="headerlink" title="非自定义"></a>非自定义</h4><ul><li><code>action</code>：上传地址（<code>https://up.qiniup.com</code>）</li><li><code>data</code>： 上传所需额外参数 或 返回额外参数的函数(？-没有action时是否要传)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;将&quot;&gt;&lt;a href=&quot;#将&quot; class=&quot;headerlink&quot; title=&quot;将&quot;&gt;&lt;/a&gt;将&lt;/h2&gt;&lt;h2 id=&quot;概念了解&quot;&gt;&lt;a href=&quot;#概念了解&quot; class=&quot;headerlink&quot; title=&quot;概念了解&quot;&gt;&lt;/a&gt;概念了解&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>better-scroll</title>
    <link href="https://turing5467.github.io/2020/08/06/js/%E5%BA%93/d3/"/>
    <id>https://turing5467.github.io/2020/08/06/js/库/d3/</id>
    <published>2020-08-05T16:00:00.000Z</published>
    <updated>2020-08-06T16:36:57.258Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/48cfe84e655e" target="_blank" rel="noopener">参考文章</a></p><h2 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h2><ul><li><p>D3.JS就是一个数据可视化的库。<img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200806223702475.png" alt="star数92.7k"></p></li><li><p>类似库</p><ul><li>three.js：主要应用于基于webGL的<strong>3D</strong>场景，而D3主要应用于<strong>2D</strong>场景。<code>star数：62.6k</code></li><li>echarts：也是一个可视化库，<strong>封装</strong>了常规的折线图，柱状图，散点图，饼图，类似图标磨具，可以直接拿来使用。而D3就像画笔一样，一切都由你<strong>自由发挥</strong>。</li></ul></li><li><p>在我们的scrm系统中，经常需要数据统计，通常我们使用antd的Table组件来展示数据，对于某些数据来说，可能会不太直观,。</p></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>D3.js通过预先创建好嵌入于网页中的JavaScript函数来选择网页元素、创建<strong>SVG</strong>元素、调整<code>CSS</code>来呈现数据，并且也可以设置动画、动态改变对象状态或加入工具提示来完成<strong>用户交互</strong>功能。</p><p>使用简单的D3.js函数就能够将大型的数据数据结构与<strong>SVG</strong>对象进行绑定，并且能生成<strong>格式化文本</strong>和各种<strong>图表</strong>。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>O.O<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>?.?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        d3.selectAll(<span class="string">'body p'</span>).text(<span class="string">'Hello D3'</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>选择元素：类似于jQuery的<code>$()</code></p><ul><li><p><code>select</code>： 选择所有指定元素的第一个 </p></li><li><p><code>selectAll</code>： 选择指定元素的全部 </p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200806225134076.png" alt="image-20200806225134076"></p></li></ul></li></ul><p>乍一看和jQuery没什么区别嘛，那我们接着往下看</p><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p> D3 有一个很独特的功能：能将数据绑定到 DOM 上 。</p><ul><li><code>datum(data)</code>：绑定一个数据（字符串、对象等）到选择集上</li><li><code>data(data)</code>绑定数组到选择集上</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>C<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">'tr'</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> p = d3.selectAll(<span class="string">'p'</span>)</span></span><br><span class="line">    p.datum(data)</span><br><span class="line"><span class="javascript">    p.text(<span class="function">(<span class="params">data,i</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">`我的名字叫<span class="subst">$&#123;data.name&#125;</span>`</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">    data = [</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">'Apple'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">'banana'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">'orange'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    p.data(data)</span><br><span class="line"><span class="javascript">        .text(<span class="function">(<span class="params">ele, i</span>) =&gt;</span> <span class="string">`水果<span class="subst">$&#123;i+<span class="number">1</span>&#125;</span>号：<span class="subst">$&#123;ele.name&#125;</span>`</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>为选择集内每个元素末尾插入元素：<code>append()</code></p></li><li><p>为选择集内每个元素前插入元素：<code>insert()</code>（有差）</p></li><li><p>移除某元素：<code>remove()</code></p></li><li><p><code>enter()</code> 有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>C<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = [<span class="string">'r'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="string">'k'</span>, <span class="string">'i'</span>, <span class="string">'e'</span>]</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 如果不加select('body')，下面append的元素会跑到body外面</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> p = d3.select(<span class="string">'body'</span>).selectAll(<span class="string">'p'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        p.data(data).enter().append(<span class="string">'p'</span>).text(<span class="function"><span class="params">d</span> =&gt;</span> d)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>exit</code>：有元素，但没有足够数据时，使用此方法可以移除多余的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> arr = [<span class="string">'r'</span>, <span class="string">'k'</span>]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> div = d3.select(<span class="string">'body'</span>).selectAll(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 一定要写在text函数后面，不然元素数据不会改变</span></span></span><br><span class="line"><span class="javascript">        div.data(arr).text(<span class="function"><span class="params">d</span> =&gt;</span> d).exit().remove()</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><ul><li>前面提到d3能将大型数据与svg绑定在一起</li></ul><blockquote><p>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</p><p>SVG 用来定义用于网络的基于矢量的图形</p><p>SVG 使用 XML 格式定义图形</p><p><strong>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</strong></p></blockquote><ul><li>svg预定义的形状元素有：<code>rect</code>、<code>circle</code>、<code>ellipse</code>、<code>line</code>、<code>polyline(折线)</code>、<code>polygon(多边形)</code>、<code>path</code></li></ul><h4 id="使用d3绘制一个简单的柱形图"><a href="#使用d3绘制一个简单的柱形图" class="headerlink" title="使用d3绘制一个简单的柱形图"></a>使用d3绘制一个简单的柱形图</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> dataset = [<span class="number">250</span> , <span class="number">110</span> , <span class="number">170</span> ,<span class="number">230</span> , <span class="number">90</span>]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> rectHeight = <span class="number">25</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>).select(<span class="string">'svg'</span>)</span></span><br><span class="line"><span class="javascript">        svg.selectAll(<span class="string">"rect"</span>)</span></span><br><span class="line">            .data(dataset)</span><br><span class="line">            .enter()</span><br><span class="line"><span class="javascript">            .append(<span class="string">"rect"</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"x"</span>, <span class="number">20</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"y"</span>, (d,i) =&gt; i * rectHeight)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"width"</span>, d =&gt; d)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"height"</span>, rectHeight<span class="number">-2</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"fill"</span>,<span class="string">"lightblue"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h4><ul><li><p>直接用数值的大小来代表像素其实不是一种好方法，为什么呢</p></li><li><p>如果数值过大或过小，要么根本看不见，要么画布没有那么长</p></li><li><p>于是，我们需要一种计算关系，能够：</p><p><strong>将某一区域的值映射到另一区域，其大小关系不变。</strong></p></li><li><p>这就是<strong>比例尺</strong></p></li><li><p>d3提供了多种比例尺，下面介绍最常用的两种</p></li></ul><h5 id="线性比例尺"><a href="#线性比例尺" class="headerlink" title="线性比例尺"></a>线性比例尺</h5><ul><li><strong>将0，映射成 0；dataset最大的值，映射成 250。</strong> </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> dataset = [<span class="number">2.5</span>, <span class="number">1.1</span>, <span class="number">1.7</span>,<span class="number">2.3</span>, <span class="number">0.9</span>]</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 为什么不将数组最小值赋值给min，因为最小值要映射为0，这样就看不见它了</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// let min = d3.min(dataset)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> min = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> max = d3.max(dataset)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 线形尺部分</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> linear = d3.scaleLinear()</span></span><br><span class="line">                        .domain([min, max])</span><br><span class="line">                        .range([0, 250])</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> rectHeight = <span class="number">25</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>).select(<span class="string">'svg'</span>)</span></span><br><span class="line"><span class="javascript">        svg.selectAll(<span class="string">"rect"</span>)</span></span><br><span class="line">            .data(dataset)</span><br><span class="line">            .enter()</span><br><span class="line"><span class="javascript">            .append(<span class="string">"rect"</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"x"</span>, <span class="number">20</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"y"</span>, (d,i) =&gt; i * rectHeight)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通过线形尺映射width</span></span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"width"</span>, d =&gt; linear(d))</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"height"</span>, rectHeight<span class="number">-2</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"fill"</span>,<span class="string">"lightblue"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="序数比例尺"><a href="#序数比例尺" class="headerlink" title="序数比例尺"></a>序数比例尺</h5><p> 有时候，定义域和值域不一定是连续的。例如，有两个数组： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> index = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> color = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>];</span><br></pre></td></tr></table></figure><p> 我们希望 0 对应 red，1 对应 blue，依次类推。 </p><p> 这些值都是离散的，线性比例尺不适合，需要用到序数比例尺。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://d3js.org/d3.v5.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> dataset = [<span class="number">2.5</span>, <span class="number">1.1</span>, <span class="number">1.7</span>,<span class="number">2.3</span>, <span class="number">0.9</span>]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> index = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> color = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> min = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> max = d3.max(dataset)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> linear = d3.scaleLinear()</span></span><br><span class="line">                        .domain([min, max])</span><br><span class="line">                        .range([0, 250])</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> colorOrdinal = d3.scaleOrdinal()</span></span><br><span class="line">                            .domain(index)</span><br><span class="line">                            .range(color);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> rectHeight = <span class="number">25</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>).select(<span class="string">'svg'</span>)</span></span><br><span class="line"><span class="javascript">        svg.selectAll(<span class="string">"rect"</span>)</span></span><br><span class="line">            .data(dataset)</span><br><span class="line">            .enter()</span><br><span class="line"><span class="javascript">            .append(<span class="string">"rect"</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"x"</span>, <span class="number">20</span>)</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"y"</span>, (d,i) =&gt; i * rectHeight)</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 通过线形尺映射width</span></span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"width"</span>, d =&gt; linear(d))</span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"height"</span>, rectHeight<span class="number">-2</span>)</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 通过颜色映射尺映射颜色</span></span></span><br><span class="line"><span class="javascript">            .attr(<span class="string">"fill"</span>, (d, i) =&gt; colorOrdinal(i));</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h5><p>坐标轴，是可视化图表中经常出现的一种图形，由一些列线段和刻度组成。坐标轴在 SVG 中是没有现成的图形元素的，需要用其他的元素组合构成。</p><p>D3 提供了<strong>坐标轴的组件</strong>，如此在 SVG 画布中绘制坐标轴变得像添加一个普通元素一样简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = [<span class="number">2.5</span>, <span class="number">1.1</span>, <span class="number">1.7</span>,<span class="number">2.3</span>, <span class="number">0.9</span>]</span><br><span class="line"><span class="keyword">let</span> index = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> min = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> max = d3.max(dataset)</span><br><span class="line"><span class="keyword">let</span> linear = d3.scaleLinear()</span><br><span class="line">                .domain([min, max])</span><br><span class="line">                .range([<span class="number">0</span>, <span class="number">250</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colorOrdinal = d3.scaleOrdinal()</span><br><span class="line">.domain(index)</span><br><span class="line">.range(color);</span><br><span class="line"><span class="comment">// 坐标轴</span></span><br><span class="line"><span class="keyword">let</span> axisX = d3.axisBottom(linear)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rectHeight = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">let</span> svg = d3.select(<span class="string">'body'</span>).select(<span class="string">'svg'</span>)</span><br><span class="line">svg.selectAll(<span class="string">"rect"</span>)</span><br><span class="line">    .data(dataset)</span><br><span class="line">    .enter()</span><br><span class="line">    .append(<span class="string">"rect"</span>)</span><br><span class="line">    .attr(<span class="string">"x"</span>, <span class="number">20</span>)</span><br><span class="line">    .attr(<span class="string">"y"</span>, (d,i) =&gt; i * rectHeight)</span><br><span class="line"><span class="comment">// 通过线形尺映射width</span></span><br><span class="line">    .attr(<span class="string">"width"</span>, d =&gt; linear(d))</span><br><span class="line">    .attr(<span class="string">"height"</span>, rectHeight<span class="number">-2</span>)</span><br><span class="line"><span class="comment">// 通过颜色映射尺映射颜色</span></span><br><span class="line">    .attr(<span class="string">"fill"</span>, (d, i) =&gt; colorOrdinal(i));</span><br><span class="line"><span class="comment">// 添加坐标轴</span></span><br><span class="line">svg.append(<span class="string">'g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate(20,130)'</span>)</span><br><span class="line">    .call(axisX)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态更新坐标轴数字</span></span><br><span class="line">d3.select(<span class="string">'#update'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    linear.domain([<span class="number">0</span>, <span class="built_in">Math</span>.random() * <span class="number">100</span>]);</span><br><span class="line">    <span class="comment">// transition d3提供默认的动画</span></span><br><span class="line">    d3.select(<span class="string">'g'</span>).transition().call(axisX)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/48cfe84e655e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;D3&quot;&gt;&lt;a href=&quot;#D3&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Gauge-Taiko</title>
    <link href="https://turing5467.github.io/2020/07/26/%E5%85%B6%E4%BB%96/Gauge-Taiko/"/>
    <id>https://turing5467.github.io/2020/07/26/其他/Gauge-Taiko/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-07-26T14:11:53.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gauge-Taiko"><a href="#Gauge-Taiko" class="headerlink" title="Gauge-Taiko"></a>Gauge-Taiko</h2><ul><li><p>新一代BDD框架Gauge-Taiko</p></li><li><p>BDD（Behavior Driven Development）：行为驱动开发。 </p></li><li><p>它采用统一的<strong>领域特定语言（DSL）</strong>来描述业务场景和用户行为，让团队各个不同角色对<strong>业务</strong>需求有一致认识，从而做到更有效的沟通和更<strong>高效的协作</strong>； </p></li></ul><h3 id="Gauge"><a href="#Gauge" class="headerlink" title="Gauge"></a>Gauge</h3><ul><li>Gauge是一款开源的轻量级跨平台自动化测试工具，它的愿景是<strong>用更少的代码、更少的维护工作</strong>实现<strong>更多的自动化测试</strong>，有如下特性：<ul><li>采用<code>Markdown</code>格式，</li><li>支持用自然语言编写Spec，语法自由，编写工作<strong>简单易上手</strong></li><li>写出来的<strong>文档格式清晰</strong>，很好维护。</li></ul></li></ul><h3 id="Taiko"><a href="#Taiko" class="headerlink" title="Taiko"></a>Taiko</h3><p> Taiko是一款开源浏览器自动化测试工具 。</p><ol><li>提供常见UI自动化测试工具那样根据Id、name、<a href="https://www.isolves.com/it/cxkf/yy/CSS2/" target="_blank" rel="noopener">css</a>、Xpath等方式选择页面元素的功能，还提供<strong>智能选择器</strong>（Smart selector），支持<strong>直接根据显示的文本</strong>来定位各种类型的页面元素，同时还有支持上、下、左、右这种根据某个元素的相对方位去<strong>定位</strong>元素的API，很好的解决UI测试页面元素定位难的问题。 </li><li>Taiko采用隐式的等待（Wait）方式，也可以手动设置超时时间以防有些访问等待时间过长。 </li></ol><h3 id="完美配合"><a href="#完美配合" class="headerlink" title="完美配合"></a>完美配合</h3><p> Taiko在REPL里执行的浏览器操作步骤，可以通过一个简单的命令直接生产Gauge支持的Step，只需要再去简单的加上step名称就可以，操作及其简单。 </p><ul><li>代码演示</li></ul><ol><li><code>specs/index.spec</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 大标题</span><br><span class="line"></span><br><span class="line">* 后面代表每一个step名</span><br><span class="line"></span><br><span class="line">## 小标题</span><br><span class="line">* step-1</span><br><span class="line">* step-2  搜索</span><br><span class="line">功能测试</span><br><span class="line">命令：gauge run ./specs/index.spec</span><br></pre></td></tr></table></figure><ol start="2"><li><code>tests/steps.js</code>：step编写位置必须在tests下的文件（在哪里配置没去注意），文件名随意</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">step(<span class="string">'step-1'</span>, <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> click(<span class="string">'xx'</span>);    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可传递参数</span></span><br><span class="line">step(<span class="string">'step-2 &lt;param_1&gt;'</span>, <span class="keyword">async</span>(param_1) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> click(param_1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Taiko-API"><a href="#Taiko-API" class="headerlink" title="Taiko API"></a>Taiko API</h3><h4 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h4><ul><li><p>openBroswer、closeBrowser</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> openBrowser()</span><br><span class="line"><span class="keyword">await</span> openBrowser(&#123;<span class="attr">args</span>:[<span class="string">'--window-size=1440,900'</span>]&#125;)</span><br></pre></td></tr></table></figure></li><li><p>跳转：<code>switchTo</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> switchTo(<span class="regexp">/Taiko/</span>)</span><br><span class="line"><span class="keyword">await</span> switchTo(<span class="regexp">/http(s?):\/\/(www?).google.(com|co.in|co.uk)/</span>)</span><br></pre></td></tr></table></figure></li><li><p>开启标签页：<code>openTab</code>`closeTab`</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">await openTab() # 开启一个空白标签页</span><br><span class="line"><span class="keyword">await</span> openTab(<span class="string">'https://taiko.dev'</span>)</span><br></pre></td></tr></table></figure></li><li><p>cookie相关：<code>setCookie</code>、<code>getCookie</code>、<code>deleteCookies</code></p></li></ul><h4 id="页面行为"><a href="#页面行为" class="headerlink" title="页面行为"></a>页面行为</h4><ul><li><p><code>goto</code>、<code>goBack</code>、<code>goForward</code>、<code>reload</code></p></li><li><p>点击：<code>click</code>、<code>doubleClick</code>、<code>rightClick</code></p><p><code>tap</code>：轻敲</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> click(link(<span class="string">'Get Started'</span>))</span><br><span class="line"><span class="keyword">await</span> click(&#123;<span class="attr">x</span> : <span class="number">170</span>, <span class="attr">y</span> : <span class="number">567</span>&#125;) <span class="comment">//点击指定坐标</span></span><br></pre></td></tr></table></figure></li><li><p>选择文件字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> click(<span class="string">'Get Started'</span>)</span><br><span class="line"><span class="keyword">await</span> attach(<span class="string">'c:/abc.txt'</span>, to(<span class="string">'Please select a file:'</span>))</span><br><span class="line"><span class="keyword">await</span> attach(<span class="string">'c:/abc.txt'</span>, <span class="string">'Please select a file:'</span>)</span><br></pre></td></tr></table></figure></li><li><p>按键：<code>press(keyName)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> press(<span class="string">'Enter'</span>)</span><br><span class="line"><span class="keyword">await</span> press([<span class="string">'Shift'</span>, <span class="string">'ArrowLeft'</span>, <span class="string">'ArrowLeft'</span>])</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>滚动：<code>scrollTo(selector)</code>、<code>scrollLeft</code>、<code>scrollRight</code>、<code>ScrollUp</code>、<code>scrollDown</code>： Scrolls the page/element to the left. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> scrollLeft()</span><br><span class="line"><span class="keyword">await</span> scrollLeft(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">await</span> scrollLeft(<span class="string">'Element containing text'</span>)</span><br><span class="line"><span class="keyword">await</span> scrollLeft(<span class="string">'Element containing text'</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>hover</code>、<code>focus</code>、</li></ul><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul><li><p><code>$(selector)</code></p></li><li><p>图片：<code>image()</code></p></li><li><p>li标签：<code>listItem()</code></p></li><li><p>按钮：<code>button()</code></p></li><li><p>文件输入字段：<code>fileField</code></p></li><li><p>timeField</p></li><li><p>文本输入框：<code>textBox</code></p></li><li><p>下拉框：<code>dropDown</code></p></li><li><p>多选框：<code>checkBox</code></p></li><li><p>单选框：<code>radioButton</code></p></li><li><p>文字：<code>text</code></p></li><li><p>表单元格：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableCell(&#123;<span class="attr">row</span>: <span class="number">1</span>, <span class="attr">col</span>: <span class="number">1</span>&#125;, <span class="string">"Table Caption"</span>)</span><br><span class="line">tableCell(&#123;<span class="attr">id</span>:<span class="string">'myColumn'</span>&#125;).text()</span><br></pre></td></tr></table></figure></li><li><p>滑块或拨号控件：<code>range</code></p></li><li><p>颜色选择器：color + select</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> color(&#123;<span class="string">'id'</span>:<span class="string">'colorId'</span>, <span class="string">'class'</span>: <span class="string">'coloc-pick'</span>&#125;).select(<span class="string">'#f236cf'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="距离选择器"><a href="#距离选择器" class="headerlink" title="距离选择器"></a>距离选择器</h4><ul><li><code>toLeftOf</code></li><li><code>toRightOf</code></li><li><code>above</code></li><li><code>below</code></li><li><code>near</code></li></ul><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul><li><p>警告：<code>alert</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'Are you sure'</span>, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> accept())</span><br><span class="line">alert(<span class="string">'Are you sure'</span>, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> dismiss())</span><br></pre></td></tr></table></figure></li><li><p>确认框：<code>confirm</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">confirm(<span class="string">'Message'</span>, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> accept())</span><br><span class="line">confirm(<span class="string">'Message'</span>, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> dismiss())</span><br></pre></td></tr></table></figure></li><li><p>输入提示：<code>prompt</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prompt(<span class="string">'Message'</span>, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> accept(<span class="string">'Something'</span>))</span><br><span class="line">prompt(<span class="string">'Message'</span>, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> dismiss())</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Gauge-Taiko&quot;&gt;&lt;a href=&quot;#Gauge-Taiko&quot; class=&quot;headerlink&quot; title=&quot;Gauge-Taiko&quot;&gt;&lt;/a&gt;Gauge-Taiko&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新一代BDD框架Gauge-Taiko&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>moment库学习</title>
    <link href="https://turing5467.github.io/2020/07/25/js/%E5%BA%93/moment/"/>
    <id>https://turing5467.github.io/2020/07/25/js/库/moment/</id>
    <published>2020-07-24T16:00:00.000Z</published>
    <updated>2020-07-26T10:36:16.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="moment"><a href="#moment" class="headerlink" title="moment"></a>moment</h2><ul><li><p><a href="http://momentjs.cn/docs/" target="_blank" rel="noopener">文档</a></p></li><li><p>在Node和浏览器中均可工作 </p></li><li><p>moment原型通过<code>moment.fn</code>公开。  如果要添加自己的函数，则可以在其中放置它们。 </p></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = moment();  <span class="comment">// 获取当前的日期时间，相当于moment(new Date())</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'1998-7-12'</span>);  <span class="comment">//注意传入有效的时间格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//moment(number) 通过传入时间戳来创建moment</span></span><br><span class="line">moment(<span class="number">1318781876406</span>)</span><br><span class="line"><span class="comment">//如果要传入秒数，可以使用moment.unix(stamp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//moment(Date)传入Date对象来创建moment对象，date对象的更改不会影响moment对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// moment(_i, _f) 使用指定格式解析字符串</span></span><br><span class="line">moment(<span class="string">'1998-7-12'</span>, <span class="string">'YYYY-M-DD'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// moment(_i, _f, true) 使moment使用严格的解析：_i与_f格式完全匹配，返回moment对象，通过isValid拿到匹配结果</span></span><br><span class="line">moment(<span class="string">"2-25-1995"</span>, <span class="string">"MM-DD-YYYY"</span>, <span class="literal">true</span>).isValid(); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析胶合的小时和分钟</span></span><br><span class="line">moment(<span class="string">"123"</span>, <span class="string">"hmm"</span>).format(<span class="string">"HH:mm"</span>) === <span class="string">"01:23"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个格式(你只知道它可能是多种格式之一)</span></span><br><span class="line">moment(<span class="string">"12-25-1995"</span>, [<span class="string">"MM-DD-YYYY"</span>, <span class="string">"YYYY-MM-DD"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//moment(obj)：可以通过指定对象中的某些单位来创建 moment。</span></span><br><span class="line">moment(&#123; <span class="attr">y</span>: <span class="number">2010</span>, <span class="attr">M</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">5</span>, <span class="attr">h</span>: <span class="number">15</span>, <span class="attr">m</span>: <span class="number">10</span>, <span class="attr">s</span>: <span class="number">3</span>, <span class="attr">ms</span>: <span class="number">123</span>&#125;);</span><br><span class="line">moment(&#123; <span class="attr">year</span>: <span class="number">2010</span>, <span class="attr">month</span>: <span class="number">3</span>, <span class="attr">day</span>: <span class="number">5</span>, <span class="attr">hour</span>: <span class="number">15</span>, <span class="attr">minute</span>: <span class="number">10</span>, <span class="attr">second</span>: <span class="number">3</span>, <span class="attr">millisecond</span>: <span class="number">123</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">//moment([year, month, day, hour?, minute?, second?, millisecond?] 同上</span></span><br></pre></td></tr></table></figure><ul><li>克隆moment对象：<code>m2 = moment(moment1)</code> 或 <code>m2 = moment1.clone()</code></li></ul><h3 id="取值-赋值"><a href="#取值-赋值" class="headerlink" title="取值/赋值"></a>取值/赋值</h3><blockquote><p>moment支持链式调用</p></blockquote><ul><li><p>moment使用重载的getter和setter方法，带参数调用则作为setter，不带则为getter</p></li><li><p>函数名：<code>millisecond</code>、<code>second</code>、<code>minute</code>、<code>hour</code>、<code>date</code>、<code>day</code>、<code>weekday</code>（0为星期一）、<code>isoWeekday</code>（1为星期一）、<code>dayOfYear</code>、<code>month</code>（0为1月）、<code>year</code></p></li><li><p>如果设置值超出范围，会响应冒泡。</p></li><li><p><code>get(str)</code>：参数支持year、month、date、hour、minute、second、millisecond，不区分大小写，且支持复数形式和缩写形式。</p><p><code>set(str, value)</code>同上</p></li></ul><ul><li><code>max</code>、<code>min</code>返回传入日期里最大/小的值，参数可为moment、string、date、Array</li></ul><ul><li><p><code>add(number, unit)</code>或<code>add({unit: number})</code>：通过增加时间改变原始的moment</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment().add(<span class="number">7</span>, <span class="string">'days'</span>);</span><br><span class="line">moment().add(<span class="number">7</span>, <span class="string">'d'</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">键</th><th align="left">快捷键</th></tr></thead><tbody><tr><td align="left">years</td><td align="left">y</td></tr><tr><td align="left">quarters</td><td align="left">Q</td></tr><tr><td align="left">months</td><td align="left">M</td></tr><tr><td align="left">weeks</td><td align="left">w</td></tr><tr><td align="left">days</td><td align="left">d</td></tr><tr><td align="left">hours</td><td align="left">h</td></tr><tr><td align="left">minutes</td><td align="left">m</td></tr><tr><td align="left">seconds</td><td align="left">s</td></tr><tr><td align="left">milliseconds</td><td align="left">ms</td></tr></tbody></table><p><code>subtract()</code>为减去时间，用法同上</p></li></ul><ul><li><p><code>startOf()</code>： 通过将原始的 moment 设置为时间单位的开头来对其进行更改。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment().startOf(<span class="string">'year'</span>);    <span class="comment">// 设置为今年一月1日上午 12:00</span></span><br><span class="line">moment().startOf(<span class="string">'day'</span>);     <span class="comment">// 设置为今天上午 12:00</span></span><br><span class="line"></span><br><span class="line">moment().startOf(<span class="string">'hour'</span>);    <span class="comment">// 设置为当前时间，但是 0 分钟、0 秒钟、0 毫秒</span></span><br><span class="line">moment().startOf(<span class="string">'minute'</span>);  <span class="comment">// 设置为当前时间，但是 0 秒钟、0 毫秒</span></span><br><span class="line">moment().startOf(<span class="string">'second'</span>);  <span class="comment">// 与 moment().milliseconds(0); 相同</span></span><br></pre></td></tr></table></figure><p><code>endOf</code>：同上</p></li></ul><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><ul><li><p><code>format(_f)</code>： 接受一串令牌并将其替换为其相应的值。 </p><p><a href="http://momentjs.cn/docs/#/displaying/" target="_blank" rel="noopener">令牌见</a></p><p>要转义格式字符串中的字符，可以将字符包在方括号中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'[今天] dddd'</span>); <span class="comment">// '今天 Sunday'</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>fromNow(bool)</code>：显示时间间隔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment([<span class="number">2016</span>, <span class="number">0</span>, <span class="number">29</span>]).fromNow();     <span class="comment">// 4 years ago</span></span><br><span class="line">moment([<span class="number">2016</span>, <span class="number">0</span>, <span class="number">29</span>]).fromNow(<span class="literal">true</span>); <span class="comment">// 4 years</span></span><br></pre></td></tr></table></figure><p><code>toNow</code>与之相反</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment([<span class="number">2016</span>, <span class="number">0</span>, <span class="number">29</span>]).toNow();  <span class="comment">// in 4 years</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>from(moment)</code>：显示当前日期与传入参数的事件时间间隔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'1998-07-12'</span>).from(moment()) <span class="comment">//22 years ago</span></span><br></pre></td></tr></table></figure><p><code>to(moment)</code></p></li><li><p><code>m1.diff(m2)</code>获取以毫秒为单位的差异。如过要获取其他度量单位中的差异，将该度量作为第二个参数传入。（m1 - m2）</p><p>第三个参数表示是否将结果截断为整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'1998-07-12'</span>).diff(moment(), <span class="string">'days'</span>);<span class="comment">//8050</span></span><br><span class="line">moment(<span class="string">'1998-07-12'</span>).diff(moment(), <span class="string">'years'</span>, <span class="literal">true</span>);<span class="comment">//-22.03955368752489</span></span><br></pre></td></tr></table></figure></li><li><p><code>valueOf()</code>：返回时间戳</p></li><li><p><code>unix()</code>：输出Unix时间戳，单位为s</p></li><li><p><code>daysInMonth()</code>：返回当月天数</p></li><li><p><code>toDate()</code>：获取原生Date对象的副本</p></li><li><p><code>toArray()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().toArray() <span class="comment">//[2020, 6, 26, 17, 16, 33, 444]</span></span><br></pre></td></tr></table></figure></li><li><p><code>toObejct()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment.toObject();  <span class="comment">// &#123;years: 2020, months: 6, date: 26, hours: 17, minutes: 17, seconds: 47, milliseconds: 470&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><ul><li><p><code>m1.isBefore(m2)</code>检查m1是否在m2之前</p></li><li><p><code>isSame</code></p></li><li><p><code>isAfter</code></p></li><li><p><code>isSameOrBefore</code></p></li><li><p><code>isSameOrAfter</code></p></li><li><p><code>isBetween(m1, m2, unit)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-10-19'</span>, <span class="string">'2010-10-25'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-10-19'</span>, <span class="literal">undefined</span>); <span class="comment">// true, 因为 moment(undefined) 等效于 moment()</span></span><br><span class="line"></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-01-01'</span>, <span class="string">'2012-01-01'</span>, <span class="string">'year'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>isLeapYear</code>是否为闰年 </p></li><li><p><code>moment.isMoment(m1)</code>：检查变量是否为moment对象</p></li><li><p><code>moment.isDate(d1)</code></p></li></ul><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><ul><li><p><code>moment.locale(str)</code>设置语言环境(全局)</p></li><li><p><code>moment().locale(str)</code>设置语言环境(局部)</p></li><li><p>加载语言环境（浏览器）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"moment.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"locale/fr.js"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"locale/pt.js"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  moment.locale(<span class="string">'fr'</span>);  <span class="comment">// 设置默认/全局的语言环境。</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>获取当前语言环境下月份或工作日的列表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">moment.months();</span><br><span class="line"><span class="comment">// ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]</span></span><br><span class="line"></span><br><span class="line">moment.monthsShort()</span><br><span class="line"><span class="comment">// ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]</span></span><br><span class="line"></span><br><span class="line">moment.weekdays()</span><br><span class="line"><span class="comment">// ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]</span></span><br><span class="line">moment.weekdaysShort()</span><br><span class="line"><span class="comment">// ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]</span></span><br><span class="line">moment.weekdaysMin()</span><br><span class="line"><span class="comment">// ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;moment&quot;&gt;&lt;a href=&quot;#moment&quot; class=&quot;headerlink&quot; title=&quot;moment&quot;&gt;&lt;/a&gt;moment&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://momentjs.cn/docs/&quot; target=&quot;_b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://turing5467.github.io/2020/07/20/%E5%B7%A5%E7%A8%8B%E5%8C%96/Git/"/>
    <id>https://turing5467.github.io/2020/07/20/工程化/Git/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2020-08-02T09:36:00.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000" target="_blank" rel="noopener">廖雪峰git教程</a></p><ul><li>Git是目前世界上最先进的<strong>分布式</strong>版本控制系统（没有之一）。 </li><li>版本控制：记录每次文件的改动，还可以让同事协作编辑。</li><li>集中式：版本库存放在中央服务器。每次使用时，都要先从中央服务器取得最新的版本，让后开始干活，干完再推送给中央服务器。</li><li>分布式： 每个人的电脑上都是一个完整的版本库 ， 每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 </li></ul><p><img src="https://lc-api-gold-cdn.xitu.io/fea7461e85aee80bbe96.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Alt text"></p><h3 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h3><ul><li><p>版本库又名repository，可以简单理解为一个目录，该目录内所有的文件都可以被git管理起来， 每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 </p></li><li><p>版本库中 存了很多东西，其中最重要的就是称为<strong>stage</strong>（或者叫index）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。 </p></li><li><p>创建版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ <span class="built_in">cd</span> giiiit</span><br><span class="line">$ git init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ git init giiiit</span><br></pre></td></tr></table></figure></li><li><p>将文件添加到版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件添加到暂存区（可添加多个）</span></span><br><span class="line">$ git add index.txt</span><br><span class="line">$ ....</span><br><span class="line"><span class="comment"># 将暂存区的文件提交至版本库</span></span><br><span class="line">$ git commit -m <span class="string">"add a file"</span></span><br></pre></td></tr></table></figure></li><li><p>修改文件后，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看仓库当前状态：添加/修改/删除文件</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 查看当前文件相较于最近一次提交做了什么修改</span></span><br><span class="line">$ git diff index.txt</span><br><span class="line">$ git add index.txt</span><br><span class="line">$ git commit -m <span class="string">"modify a file"</span></span><br></pre></td></tr></table></figure></li><li><p>回退版本</p><p>当前版本：HEAD</p><p>上个版本：HEAD^</p><p>上上个版本：HEAD^^</p><p>前100个版本：HEAD^100</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显式最近到最远的提交日志(参数表示格式化)</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">70dc97615e5a72533ac888d4ab1370bba32bae8d (HEAD -&gt; master) modify a file</span><br><span class="line">9700b312aa2ae21a7d0a71895b0dd9fd06c70b97 add a file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到上一个版本</span></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到最新版本(只需写版本号前几位)</span></span><br><span class="line">$ git reset --hard 70dc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是第二天才想回退到最新版本，但你已经无法通过git log找到新版本的commit id时</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure></li><li><p>删除版本库中的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除工作区的文件</span></span><br><span class="line">$ rm index.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除暂存区的文件</span></span><br><span class="line">$ git rm index.txt</span><br><span class="line">$ git commit -m <span class="string">"delete a file"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不小心删错了(只执行了rm命令)，可以使用reset回退到版本库最新版本</span></span><br><span class="line">$ git co -- index.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果执行了git rm 命令，可以选择回退版本，但其他文件也会被修改</span></span><br><span class="line">$ git reset ---hard 9700</span><br></pre></td></tr></table></figure></li></ul><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><ul><li><p>工作区就是你在电脑里能看到的目录</p></li><li><p>丢弃工作区的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把readme.txt文件在工作区的修改全部撤销</span></span><br><span class="line"><span class="comment"># 文件未添加至暂存区：回到和版本库相同的状态</span></span><br><span class="line"><span class="comment"># 文件已添加至暂存区：回到添加至暂存区后的状态</span></span><br><span class="line"><span class="comment"># 即：让这个文件回到最近一次commit或add时的状态。</span></span><br><span class="line"><span class="comment"># -- 如果不加，就会变成切换分支命令</span></span><br><span class="line">$ git checkout -- index.txt</span><br></pre></td></tr></table></figure></li><li><p>将暂存区的修改回退到工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset Head index.txt</span><br></pre></td></tr></table></figure></li><li><p>将版本库的修改回退到工作区：参考上一节</p></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li><p>将本地仓库关联一个远程库</p><p><code>git remote add origin  远程仓库名</code></p></li><li><p>将本地库的内容推送至远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># origin是远程库默认的名字</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li><li><p>创建远程库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># github 或 gitlab创建</span></span><br><span class="line"><span class="comment"># 克隆</span></span><br><span class="line">$ git <span class="built_in">clone</span> 仓库名</span><br></pre></td></tr></table></figure></li></ul><h4 id="pull和fetch的区别"><a href="#pull和fetch的区别" class="headerlink" title="pull和fetch的区别"></a>pull和fetch的区别</h4><blockquote><p>git fetch和git pull的区别</p><ol><li><p>fetch：从远程仓库获取最新版本到本地仓库（不会自动合并）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    git fetch origin master;  <span class="comment">//将远程仓库的master分支下载到本地当前branch中</span></span><br><span class="line">&gt;    git merge origin/master;  <span class="comment">//将origin/master合并至当前分支</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>pull： 从远程获取最新版本并merge到本地 （fetch+merge）</p><p>如果你有一个分支设为跟踪一个远程分支，可以使用git pull 命令来自动的抓取然后合并远程分支到当前分支。 </p></li></ol></blockquote><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p> <img src="https://www.liaoxuefeng.com/files/attachments/919022325462368/0" alt="git-br-initial"> HEAD指向当前分支，分支指向最新的提交每次提交，分支都会向前移动一步</p><ul><li><p>当我们创建新的分支<code>ybs</code>，git新建一个指针叫做<code>ybs</code>，指向相同的提交，然后将HEAD指向<code>dev</code></p><p> <img src="https://www.liaoxuefeng.com/files/attachments/919022363210080/l" alt="git-br-create"> </p><p>出现新的commit后</p><p> <img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge"> </p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并切换至ybs分支</span></span><br><span class="line">$ git checkout -b ybs</span><br><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># 将ybs分支合并至当前分支(master)</span></span><br><span class="line">$ git merge ybs</span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d ybs</span><br></pre></td></tr></table></figure><p>前面说到checkout的另一种作用，撤销修改，一种命令，两种作用，令人迷惑</p><p>因此 最新版本的Git提供了新的<code>git switch</code>命令来切换分支 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并切换至分支</span></span><br><span class="line">$ git switch -c ybs</span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git switch ybs</span><br></pre></td></tr></table></figure><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><ul><li>冲突：两个分支对同一行进行了修改</li><li>解决：把Git合并失败的文件手动编辑为我们希望的内容，再提交。 </li></ul><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会<strong>丢掉分支信息</strong>。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff <span class="string">"merge width no--ff"</span> ybs</span><br></pre></td></tr></table></figure><h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>工作进行到一半，还没发提交，上司要你在2小时内解决一个bug</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将工作现场储存起来</span></span><br><span class="line">$ git stash</span><br><span class="line"><span class="comment"># git co master</span></span><br><span class="line">$ git co -b bug-101</span><br><span class="line"><span class="comment"># 解决bug</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git ci -m <span class="string">"fix bug 101"</span></span><br><span class="line">$ git switch master</span><br><span class="line">$ git merge --no-ff -m <span class="string">"merge bug fix 101"</span> bug-101</span><br><span class="line">$ git switch ybs</span><br><span class="line"><span class="comment"># 查看工作现场</span></span><br><span class="line">$ git stash list</span><br><span class="line"><span class="comment"># 恢复工作现场并删除stash内容</span></span><br><span class="line">$ git stash pop</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将刚刚的bug修复提交到当前分支</span></span><br><span class="line">$ git cherry-pick 4c805e2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行删除分支</span></span><br><span class="line"><span class="variable">$git</span> br -D bug-101</span><br></pre></td></tr></table></figure><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320" target="_blank" rel="noopener">廖</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看远程库信息</span></span><br><span class="line">$ git remote</span><br><span class="line"><span class="comment"># 显示可以抓取和推送的origin的地址。没有权限，就看不到。</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将分支上的所有本地提交推送到远程库</span></span><br><span class="line">$ git push origin master</span><br><span class="line"><span class="comment"># 推送至其它分支</span></span><br><span class="line">git push origin ybs</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整流程</span></span><br><span class="line">$ git <span class="built_in">clone</span> xx //克隆远程仓库</span><br><span class="line">$ git co -b ybs origin/ybs // 在本地创建和远程分支对应的分支</span><br><span class="line"><span class="comment"># 编写代码</span></span><br><span class="line">$ git status (查看文件发生了哪些变动)</span><br><span class="line">$ git add index.txt(按需提交，不要全部提交)</span><br><span class="line">$ git ci -m <span class="string">"xx"</span></span><br><span class="line">$ git push origin ybs</span><br></pre></td></tr></table></figure><ul><li><p>如果push失败，是因为 你的小伙伴的最新提交和你试图推送的提交有冲突 （如果分支完全是你自己在用， 那么不会有这个问题）</p></li><li><p>解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line"><span class="comment"># 若pull失败，是因为未与远端分支建立连接</span></span><br><span class="line">$ git br --<span class="built_in">set</span>-upstream-to=origin/ybs  ybs</span><br><span class="line">$ git pull </span><br><span class="line"><span class="comment"># 解决冲突</span></span><br><span class="line">$ git add xx</span><br><span class="line">$ git ci -m <span class="string">"commit message"</span></span><br><span class="line">$ git push origin ybs</span><br></pre></td></tr></table></figure></li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li>标签相当于版本库的一个快照，指向某个commit的指针。</li><li>与分支很像，但分支可以移动，标签不能移动。</li><li>相较于commit号，tag 是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 </li></ul><blockquote><p> 标签都只存储在本地，不会自动推送到远程 </p><p> 如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagName&gt;</code> </p><p> 或者，一次性推送全部尚未推送到远程的本地标签  <code>git push origin --tags</code></p></blockquote><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout ybs </span><br><span class="line"><span class="comment">#  打一个新标签</span></span><br><span class="line">$ git tag v1.0</span><br><span class="line"><span class="comment"># 查看标签(按字母排序)</span></span><br><span class="line">$ git tag</span><br><span class="line"><span class="comment"># 查看标签信息</span></span><br><span class="line">$ git show v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地标签</span></span><br><span class="line">$ git tag -d v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程标签</span></span><br><span class="line">$ git tag -d v0.9</span><br><span class="line">$ git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure><ul><li>如果是之前的提交忘记打标签了，那么需要先找到该commit id，然后打上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.1 f52c63</span><br></pre></td></tr></table></figure><ul><li><p>创建带有说明的标签(-a指定标签名)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.1 -m <span class="string">"version 0.1 released"</span> 1094adb</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config  user.name <span class="string">"wendingding"</span>      //配置当前仓库用户名</span><br><span class="line">git config  user.email <span class="string">"wendingding@126.com"</span>   //配置当前仓库邮箱</span><br><span class="line">git config  --global user.name  <span class="string">"wendingding"</span>           //配置全局用户名</span><br><span class="line">git config  --global user.email <span class="string">"wendingding@126.com"</span>   //配置全局邮箱</span><br><span class="line">git config --list/-l  显示配置信息</span><br><span class="line"></span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//找到D:\Program Files\Git\mingw64\etc\gitconfig文件</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br></pre></td></tr></table></figure><p>或者：使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><h3 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h3><p><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">gitignore</a></p><ul><li>在工作目录中的文件，不想提交</li></ul><blockquote><p>忽略文件的原则是：</p><ol><li>忽略操作系统<strong>自动生成</strong>的文件，比如缩略图等；</li><li>忽略<strong>编译生成的</strong>中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有<strong>敏感信息</strong>的配置文件，比如存放口令的配置文件。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/结束: 只匹配文件夹路径下的内容,不匹配文件夹</span><br><span class="line">node_modules   忽略当前路径的node_modules文件夹以及该文件夹下所有内容</span><br><span class="line">node_modules/  忽略当前路径的node_modules文件夹下的所有内容,不忽略node_modules</span><br><span class="line"></span><br><span class="line">/开始: 匹配 根目录</span><br><span class="line">/bin    忽略根目录下的bin文件</span><br><span class="line">/a.b忽略根目录下的a.b</span><br><span class="line"></span><br><span class="line">?匹配单个字符</span><br><span class="line">*匹配多个字符</span><br><span class="line">**匹配多级目录，可在开始，中间，结束</span><br></pre></td></tr></table></figure><ul><li><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure></li><li><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他命令行（无git前缀）"><a href="#其他命令行（无git前缀）" class="headerlink" title="其他命令行（无git前缀）"></a>其他命令行（无git前缀）</h3><ol><li><p><code>pwd</code> 查看当前目录</p></li><li><p><code>ls</code>显示当前目录内容</p></li><li><p><code>mkdir</code> 创建新の文件夹</p><pre><code>`-v demo`创建demo文件夹并输出**提示**信息`-p test/sub1`  创建`test`文件夹并在该目录中**创建**`sub1`文件</code></pre></li><li><p><code>touch</code> 创建新の文件</p><pre><code>`cat` 读取/合并文件内容        `cat a.txt b.txt &gt; c.txt`        `-n` 显示行号`echo` 输出字符串            ` xx &gt; 文件名` 向文件写入内容 (覆盖)             `&gt;&gt;` 向文件续写内容</code></pre></li></ol><pre><code>`wc`统计字数</code></pre><ol start="5"><li><p><code>rm</code>删除文件</p><pre><code>`-i` 删前询问`-f` 强制删除`-r *`删除所有文件`-rf /*` 递归删除</code></pre></li><li><p><code>mv</code> 移动文件或重命名</p></li><li><p><code>cp</code> 复制文件</p><pre><code>` 示例01：cp index.html ./demo/index.html`</code></pre></li><li><p><code>history</code>操作历史</p></li><li><p><code>curl</code>发送网络请求</p></li><li><p><code>who am i</code> 查看当前用户信息</p></li><li><p><code>tab</code>自动补全,连按两次会将所有匹配内容显示出来</p></li><li><p><code>xx --help</code> 帮助</p></li></ol><h3 id="更多命令查看"><a href="#更多命令查看" class="headerlink" title="更多命令查看"></a>更多命令查看</h3><h4 id="增加、删除文件"><a href="#增加、删除文件" class="headerlink" title="增加、删除文件"></a>增加、删除文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到'暂存区'</span></span><br><span class="line">$ git add [file1] [file2] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到'暂存区'，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到'暂存区'</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入'暂存区'</span></span><br><span class="line">$ git rm [file1] [file2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在'工作区'</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入'暂存区'</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交'暂存区'到'仓库'</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交'暂存区'的指定文件到'仓库'</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交'工作区'自上次commit之后的变化，直接到'仓库'</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h4 id="分支-1"><a href="#分支-1" class="headerlink" title="分支"></a>分支</h4><ul><li>追踪分支：  联系本地分支与远程分支。如果你在<strong>追踪分支</strong>上执行推送(push)或拉取(pull)时,　它会自动推送(push)或拉取(pull)到关联的远程分支上 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有'本地'分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有'远程'分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有'本地'分支和'远程'分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># '新建'一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并'切换'到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit(没看懂)</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在'现有分支'与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># '切换'到指定分支</span></span><br><span class="line">$ git checkout/switch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># '切换'到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># '合并'指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># '删 除'分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># '删 除远程'分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h4 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a>标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的commit版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显式最后一次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个'文件'的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><ul><li>在一次<code>push</code>前可以有多个<code>commit</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动到本地仓库</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复'暂存区'的指定文件到'工作区'</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复'暂存区'的所有文件到'工作区'</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置'暂存区'的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置'暂存区与工作区'，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><ol><li><p><code>git reset</code><br> <code>git reset --hard HEAD^</code>              //回退到上一个版本方式1<br> <code>git reset --hard HEAD^^</code>            //回到上上个版本<br> <code>git reset --hard HEAD~100</code>      //回到前100个版本<br> <code>git reset --hard HEAD~1</code>            //回退到上一个版本方式2<br> <code>git reset --hard (7位版本号)</code>   //回到指定的版本</p></li><li><p>参数</p><blockquote><p>–soft 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态） </p><p>–mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作。 </p><p>–hard 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。 </p><p>–merge 和–hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】</p><p> –keep 和–hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。</p></blockquote></li></ol><h5 id="reset和revert的区别"><a href="#reset和revert的区别" class="headerlink" title="reset和revert的区别"></a>reset和revert的区别</h5><blockquote><p>reset和revert的区别</p><ol><li><p>reset：回退到指定版本，同时删除该版本之后提交的版本</p><p>如果push至远端显示分支落后，请加上–force参数</p><p>适用于想要不留痕迹的撤回提交</p></li><li><p>revert：回退到指定版本，但不删除提交，而是在原先的基础上新建一个revert的提交</p></li></ol></blockquote><h5 id="ssh-key配置"><a href="#ssh-key配置" class="headerlink" title="ssh key配置"></a>ssh key配置</h5><p><a href="https://help.github.com/en/articles/connecting-to-github-with-ssh" target="_blank" rel="noopener">ssh key</a></p><ol><li><code>ssh-keygen -t rsa -b 4096 -C &quot;turing5467@163.com&quot;</code></li><li><code>PRESS enter *2</code></li><li><code>ls -al ~/.ssh</code> 检查是否生成ssh key</li><li>找到<code>id_rsa.pub</code>,并复制内容</li><li><code>github</code> =&gt; <code>profile</code> =&gt; <code>ssh keys</code> =&gt;  <code>add</code> =&gt; 粘贴刚刚赋值的内容</li><li>现在/以后就可以<code>clone with SSH</code>,这样之后<code>push</code>操作就无须输入账号、密码了</li></ol><h2 id="在VScode中使用git"><a href="#在VScode中使用git" class="headerlink" title="在VScode中使用git"></a>在VScode中使用git</h2><ul><li>Ctrl+Shift+P打开命令面板：输入Git 命令</li><li>插件：<ol><li>Git History：查看整个仓库文件提交历史及修改地方</li></ol></li></ul><h3 id="代码克隆"><a href="#代码克隆" class="headerlink" title="代码克隆"></a>代码克隆</h3><ul><li>Ctrl + Shift + P：Git clone回车并输入仓库地址</li></ul><h3 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h3><ul><li><p>红色箭头：删除行</p></li><li><p>蓝色开头：修改</p></li><li><p>绿色开头：新增</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/19/1637916331d03571?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="qq 20180503235533"> </p></li></ul><h3 id="源代码管理器"><a href="#源代码管理器" class="headerlink" title="源代码管理器"></a>源代码管理器</h3><ul><li><p>Ctrl+Shift+G：打开源代码管理器 </p><ul><li><p>M：修改但未add</p><ul><li>+：执行<code>git add</code>操作</li></ul></li><li><p>commit操作：</p><p> <img src="https://user-gold-cdn.xitu.io/2018/5/19/16379163744d4e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="qq 20180503235533"> </p></li></ul></li></ul><h3 id="拉取远程仓库代码并merge至自己的分支"><a href="#拉取远程仓库代码并merge至自己的分支" class="headerlink" title="拉取远程仓库代码并merge至自己的分支"></a>拉取远程仓库代码并merge至自己的分支</h3><ol><li>左下角切换分支，<code>...</code>拉取项目</li><li>切回自己的分支，<code>git merge master</code></li></ol><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p> 当有冲突时，VS code会标注出当前修改，冲突的修改，可以同时保存修改，或者只保存当前的或者已提交的。 </p><h3 id="git自动拉取"><a href="#git自动拉取" class="headerlink" title="git自动拉取"></a>git自动拉取</h3><p> 在设置中输入git, <code>git.autofetch</code> 设置为<code>true</code> </p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p> 大多数开发者都用git作为版本控制软件，但是好多时候git自带的功能像git diff，只在终端里显示并不够直观 ，像这样</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200802154513824.png" alt="image-20200802154513824"></p><p>这时可借助vscode的可视化工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将vscode作为git默认编辑器</span></span><br><span class="line">$ git config --global core.editor <span class="string">"code --wait"</span></span><br><span class="line"><span class="comment"># 2. 打开.gitconfig文件</span></span><br><span class="line">$ git config --global -e</span><br><span class="line"><span class="comment"># 3. 在里面加上</span></span><br><span class="line">[diff]</span><br><span class="line">    tool = default-difftool</span><br><span class="line">[difftool <span class="string">"default-difftool"</span>]</span><br><span class="line">    cmd = code --<span class="built_in">wait</span> --diff <span class="variable">$LOCAL</span> <span class="variable">$REMOTE</span></span><br><span class="line"><span class="comment"># 4. 运行diff命令</span></span><br><span class="line">$ git difftool [commit-1] [commit-2]</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200802155318669.png" alt="image-20200802155318669"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600/89606700
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DvaJS</title>
    <link href="https://turing5467.github.io/2020/07/12/js%E6%A1%86%E6%9E%B6/react/DvaJS/"/>
    <id>https://turing5467.github.io/2020/07/12/js框架/react/DvaJS/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-07-26T14:32:57.540Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/axel10/p/8503782.html" target="_blank" rel="noopener">参考</a></p><h2 id="DvaJS"><a href="#DvaJS" class="headerlink" title="DvaJS"></a>DvaJS</h2><ul><li><p><code>dva.js</code>是阿里前端团队开发的一个基于react、redux、webpack的一个前端框架，他能够实现<code>react-redux-webpack</code><strong>环境一键部署</strong>，能帮前端工程师节省不少环境搭建的时间。而且经过优化的redux跟原生redux相比使用起来要方便不少。</p></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i dva-cli -g</span><br><span class="line">dva -g //检测是否安装成功</span><br><span class="line">dva new project-name  //创建dva项目</span><br><span class="line"><span class="built_in">cd</span> project-name</span><br><span class="line">npm start //启动项目</span><br></pre></td></tr></table></figure></li><li><p>项目结构</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702165809956.png" alt="image-20200702165809956"></p></li></ul><h3 id="计数器实例"><a href="#计数器实例" class="headerlink" title="计数器实例"></a>计数器实例</h3><ol><li><p><code>routes</code>文件夹内新建<code>demo.js</code>及<code>demo.css</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'dva'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./demo.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">&#123;dispatch,num&#125;</span>) </span>&#123;      <span class="comment">//dispatch用来操作数据模型。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type:<span class="string">"num/add"</span>,       <span class="comment">//num代表数据模型，add代表方法。</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">decreace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type:<span class="string">"num/decreace"</span>,</span><br><span class="line">      payload: &#123;</span><br><span class="line">          step: <span class="number">3</span><span class="comment">//传递参数</span></span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;div className=&#123;styles.checkNum&#125;&gt;</span><br><span class="line">      &lt;input type=<span class="string">"button"</span> value=<span class="string">"+"</span> onClick=&#123;add&#125;/&gt;</span><br><span class="line">      &lt;input type=<span class="string">"input"</span> value=&#123;num&#125;/&gt;</span><br><span class="line">      &lt;input type=<span class="string">"button"</span> value=<span class="string">"-"</span> onClick=&#123;decreace&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default connect(        /</span><span class="regexp">/将组件与数据模型进行连接！！</span></span><br><span class="line"><span class="regexp">  (&#123;num&#125;)=&gt;(&#123;num&#125;)</span></span><br><span class="line"><span class="regexp">)(Demo);</span></span><br></pre></td></tr></table></figure><blockquote><p>非要在不一定payload中传递参数，也可以与payload同级传递，如<code>dispatch(type: &#39;xx&#39;, id: 5467)</code>，因为最后都可以通过解构赋值拿到传递的值</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.checkNum</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>models文件夹下新建文件<code>num.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    namespace: <span class="string">'num'</span>,<span class="comment">//num可以理解为数据模型</span></span><br><span class="line">    state: <span class="number">0</span>,<span class="comment">//数据的初始值</span></span><br><span class="line">    reducers: &#123;</span><br><span class="line">      <span class="string">'add'</span>(state) &#123;     <span class="comment">//add是方法名，用来修改num用的。参数为数据值，</span></span><br><span class="line">        state ++;</span><br><span class="line">        <span class="keyword">return</span> state;<span class="comment">//必须返回新的值</span></span><br><span class="line">      &#125;,</span><br><span class="line">        </span><br><span class="line">      <span class="string">'decreace'</span>(state, &#123;type, <span class="attr">payload</span>: &#123;step&#125;&#125;) &#123;</span><br><span class="line">        <span class="comment">//payload传递参数(解构写法)</span></span><br><span class="line">        state -= step;</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>前往<code>src/index.js</code>，注册num数据模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dva <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = dva();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册数据模型</span></span><br><span class="line">app.model(<span class="built_in">require</span>(<span class="string">'./models/num'</span>).default);</span><br><span class="line">app.router(<span class="built_in">require</span>(<span class="string">'./router'</span>).default);</span><br></pre></td></tr></table></figure></li><li><p>前往<code>src/router.js</code>，添加demo路由</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'dva/router'</span>;</span><br><span class="line"><span class="keyword">import</span> IndexPage <span class="keyword">from</span> <span class="string">'./routes/IndexPage'</span>;</span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./routes/demo'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RouterConfig</span>(<span class="params">&#123; history &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> exact component=&#123;IndexPage&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/demo"</span> component=&#123;Demo&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RouterConfig;</span><br></pre></td></tr></table></figure></li></ol><h3 id="model详解"><a href="#model详解" class="headerlink" title="model详解"></a>model详解</h3><ul><li><p>state</p></li><li><p>action：改变state的唯一途径，通过<code>dispatch(actionName)</code>发起action</p><ul><li><code>dispatch</code>是在connect组件后，通过props传入的</li></ul></li><li><p>reducers：描述如何改变数据</p><p>reducer参数：<code>(state, action)</code></p></li></ul><ul><li><p>effect：副作用，在我们的应用中，最常见的就是<strong>异步操作</strong>。之所以叫副作用是因为它使得我们的函数变得不纯，<strong>同样的输入不一定获得同样的输出</strong>。</p><p>dva 为了控制副作用的操作，底层引入了<code>redux-sagas</code>做异步流程控制，由于采用了<code>generator</code>的相关概念，所以将异步转成同步写法，从而将effects转为<strong>纯函数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">addAfter1Second</span>(<span class="params">action, &#123; put, call &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> call(delay, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'add'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dva 提供多个 effect 函数内部的处理函数，比较常用的是 <code>call</code> 和 <code>put</code>。</p><ul><li>call：执行异步函数</li><li>put：发出一个 Action，类似于 dispatch</li></ul></li></ul><ul><li><p>subscription：Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> key <span class="keyword">from</span> <span class="string">'keymaster'</span>;</span><br><span class="line">...</span><br><span class="line">app.model(&#123;</span><br><span class="line">  namespace: <span class="string">'count'</span>,</span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    keyEvent(&#123;dispatch&#125;) &#123;</span><br><span class="line">      key(<span class="string">'⌘+up, ctrl+up'</span>, () =&gt; &#123; dispatch(&#123;<span class="attr">type</span>:<span class="string">'add'</span>&#125;) &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/axel10/p/8503782.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;DvaJS&quot;&gt;&lt;a href=&quot;#DvaJS&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://turing5467.github.io/2020/06/25/html-css/Canvas%E5%AE%9E%E4%BE%8B/"/>
    <id>https://turing5467.github.io/2020/06/25/html-css/Canvas实例/</id>
    <published>2020-06-25T08:40:37.438Z</published>
    <updated>2020-06-25T08:40:37.438Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React服务端渲染(SSR)(未完)</title>
    <link href="https://turing5467.github.io/2020/06/20/js%E6%A1%86%E6%9E%B6/react/React-SSR/"/>
    <id>https://turing5467.github.io/2020/06/20/js框架/react/React-SSR/</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2020-06-24T04:34:11.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><ul><li><p>为什么要服务端渲染？</p><p>在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在<strong>“白屏”等待</strong>。</p></li></ul><ol><li><p>首屏等待： </p><p>而<strong>服务端渲染</strong>所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以<strong>更快的看到渲染内容</strong> 。</p></li><li><p>SEO</p><p> SPA 模式对搜索引擎不够友好 </p></li></ol><ul><li><p>方案：</p><p> 第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 <code>SPA</code> 的效果和体验，还不影响<code>SEO</code> 效果，这就有点完美。 </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务端渲染&quot;&gt;&lt;a href=&quot;#服务端渲染&quot; class=&quot;headerlink&quot; title=&quot;服务端渲染&quot;&gt;&lt;/a&gt;服务端渲染&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么要服务端渲染？&lt;/p&gt;
&lt;p&gt;在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React-组件复用</title>
    <link href="https://turing5467.github.io/2020/06/14/js%E6%A1%86%E6%9E%B6/react/React-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/"/>
    <id>https://turing5467.github.io/2020/06/14/js框架/react/React-组件复用/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T13:26:17.108Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a" target="_blank" rel="noopener">原文</a></p><h2 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h2><p>前端发展速度非常之快，页面和组件变得越来越复杂，如何更好的实现<code>状态逻辑复用</code>一直都是应用程序中重要的一部分，这直接关系着应用程序的质量以及维护的难易程度。</p><p>本文介绍了<code>React</code>采用的三种实现<code>状态逻辑复用</code>的技术，并分析了他们的实现原理、使用方法、实际应用以及如何选择使用他们。</p><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p> <code>Mixin</code>（混入）是一种通过扩展收集功能的方式，它本质上是<strong>将一个(或多个)对象的属性拷贝到另一个对象上</strong>面去 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LogMixin = &#123;</span><br><span class="line">  actionLog: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'action...'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  requestLog: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request...'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;  <span class="comment">/*..*/</span>  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Goods</span>(<span class="params"></span>) </span>&#123;  <span class="comment">/*..*/</span> &#125;</span><br><span class="line"></span><br><span class="line">_.extend(User.prototype, LogMixin);</span><br><span class="line">_.extend(Goods.prototype, LogMixin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">var</span> good = <span class="keyword">new</span> Goods();</span><br><span class="line">user.actionLog();</span><br><span class="line">good.requestLog();</span><br></pre></td></tr></table></figure><h4 id="React中应用Mixin"><a href="#React中应用Mixin" class="headerlink" title="React中应用Mixin"></a>React中应用Mixin</h4><p> <code>React</code>也提供了<code>Mixin</code>的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用<code>createClass</code>来创建<code>React</code>组件时才可以使用，因为在<code>React</code>组件的<code>es6</code>写法中它已经被废弃掉了。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LogMixin = &#123;</span><br><span class="line">  log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'log'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'out'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复用1</span></span><br><span class="line"><span class="keyword">var</span> User = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],   <span class="comment">//关键代码</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复用2</span></span><br><span class="line"><span class="keyword">var</span> Goods = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>危害</p><ol><li><code>Mixin</code> 可能会相互<strong>依赖</strong>，相互<strong>耦合</strong>，不利于代码维护</li><li>不同的<code>Mixin</code>中的方法可能会<strong>相互冲突</strong></li><li><code>Mixin</code>非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li></ol></li><li><p><code>React</code>现在已经不再推荐使用<code>Mixin</code>来解决代码复用问题，因为<code>Mixin</code>带来的危害比他产生的价值还要巨大，并且<code>React</code>全面推荐使用<strong>高阶组件</strong>来替代它。 </p></li></ul><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><ul><li><p>Higher-Order-Component： 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 </p></li><li><p>实现方式</p><ol><li><p>属性代理： 函数返回一个我们自己定义的组件，然后在<code>render</code>中返回要包裹的组件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>可操作所有传入的<code>props</code></li><li>可操作组件的生命周期</li><li>可操作组件的<code>static</code>方法</li><li>获取<code>refs</code></li></ul></li><li><p>反向继承： 返回一个组件，继承原组件，在<code>render</code>中调用原组件的<code>render</code>。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可操作所有传入的<code>props</code></p></li><li><p>可操作组件的生命周期</p></li><li><p>可操作组件的<code>static</code>方法</p></li><li><p>获取<code>refs</code></p></li><li><p>可操作<code>state</code></p></li><li><p>可以渲染劫持</p></li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testCPN.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">TestCPN</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        □被包裹组件□</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">WrappedComponent</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">          <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> function hoc2(WrappedComponent) &#123; </span></span><br><span class="line"><span class="xml">    return class extends WrappedComponent &#123;</span></span><br><span class="line"><span class="xml">        render() &#123;</span></span><br><span class="line">          return (&lt;div&gt;</span><br><span class="line">            &lt;div className="title"&gt;&#123;this.props.title&#125;&lt;/div&gt;</span><br><span class="line">            &#123;super.render()&#125;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default hoc(TestCPN)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APP.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/*从这里传入属性*/</span>&#125;</span><br><span class="line">      &lt;TestCPN title=&#123;<span class="string">"tr"</span>&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>在<code>vue</code>中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而<code>React</code>中没有做这样的处理，在默认情况下，表单元素都是<code>非受控组件</code>。给表单元素绑定一个状态后，往往需要手动书写<code>onChange</code>方法来将其改写为<code>受控组件</code>，在表单元素非常多的情况下这些重复操作是非常痛苦的。</p><p>我们可以借助高阶组件来实现一个简单的双向绑定。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>高阶组件就是一个没有副作用的纯函数，各个高阶组件<strong>不会互相依赖耦合</strong></li><li>高阶组件也有可能造成冲突，但我们可以<strong>在遵守约定的情况下避免这些冲突</strong></li><li>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加<strong>不会为原组件增加负担</strong></li></ul><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul><li><code>HOC</code>需要在原组件上进行包裹或者嵌套，如果大量使用<code>HOC</code>，将会产生非常多的嵌套，这让调试变得非常困难。</li><li><code>HOC</code>可以劫持<code>props</code>，在不遵守约定的情况下也可能造成冲突。</li></ul><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><ul><li><code>Hooks</code>是<code>React v16.7.0-alpha</code>中加入的新特性。它可以让你在<code>class</code>以外使用<code>state</code>和其他<code>React</code>特性。 </li><li>可以同时解决<code>Mixin</code>和<code>HOC</code>带来的问题。 </li></ul><h3 id="RenderProps"><a href="#RenderProps" class="headerlink" title="RenderProps"></a>RenderProps</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cad39b3f265da03502b1c0a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;组件复用&quot;&gt;&lt;a href=&quot;#组件复用&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Web安全（CSRF与XSS）</title>
    <link href="https://turing5467.github.io/2020/06/12/%E5%85%B6%E4%BB%96/Web%E5%AE%89%E5%85%A8/"/>
    <id>https://turing5467.github.io/2020/06/12/其他/Web安全/</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2020-06-14T16:16:11.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul><li><p>CSRF：跨站请求伪造（Cross-Site request forgery）</p></li><li><p>原理：攻击者盗用了你的身份，以你的名义发送原本合法的请求，但是却完成了攻击者所期望的一个操作。</p><p>如：以你的名义发送邮件、购买商品等</p></li><li><p>步骤</p><ol><li>受害者登录A站点，并保留了登录凭证（Cookie）。</li><li>攻击者诱导受害者访问了站点B。</li><li>站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。</li><li>站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li><li>站点A以受害者的名义执行了站点B的请求。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb8d5ab69386f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。</p><p>2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，并不会去获取cookie信息(cookie有同源策略)</p><p>3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击)</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ol><li><p>Token验证（主流）</p><blockquote><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。 </p><ul><li>服务端给用户生成一个token，加密后传递给用户 </li><li>用户在提交请求时，需要携带这个token </li><li>服务端验证token是否正确</li></ul></blockquote></li><li><p>Referer（页面来源）验证（ <strong>并不安全，Referer可以被更改</strong> ）</p></li><li><p>cookie的samesite属性（存在兼容性问题）</p></li><li><p>添加验证码（体验不好）</p></li></ol><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li><p>XSS：跨域脚本攻击（Cross-site scripting）</p></li><li><p>XSS是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p></li></ul><ul><li>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</li></ul><h4 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h4><ul><li><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。 </p></li><li><p>步骤</p><ol><li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li><li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol></li><li><p>防范：对URL的查询参数进行转义后再输出到页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/welcome'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//对查询参数进行编码，避免反射型 XSS攻击</span></span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(req.query.type)&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><ul><li>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。</li></ul><blockquote><p> 在使用 <code>innerHTML</code>、<code>outerHTML</code>、<code>appendChild</code>、<code>document.write()</code>等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p></blockquote><ul><li><p>步骤</p><ol><li>攻击者构造出特殊数据，其中包含恶意代码。</li><li>用户浏览器执行了恶意代码。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol></li><li><p>防范（核心：对输入内容进行转义）</p><ol><li><p>对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p></li><li><p>非<code>url</code>，我们可以这样进行编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;apos;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><ul><li><p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。 </p></li><li><p>存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。 </p></li><li><p>步骤</p><ol><li><p>攻击者将恶意代码提交到目标网站的数据库中。</p></li><li><p>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</p></li><li><p>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</p></li><li><p>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p></li></ol></li><li><p>防范</p><ol><li>前端数据传递给服务器之前，先<strong>转义/过滤</strong>(防范不了抓包修改数据的情况)</li><li>服务器接收到数据，在存储到数据库之前，进行转义/过滤</li><li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li></ol></li></ul><h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p>除了谨慎的转义，我们还需要一些手段来防范XSS攻击</p><ol><li><p>Content Security Policy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端响应头?</span></span><br><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前端</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Security-Policy"</span> content=<span class="string">"form-action 'self';"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>对输入内容长度进行限制</p></li><li><p>输入内容限制</p></li><li><p>其他</p><ol><li>cookie的httpOnly</li><li>验证码</li></ol></li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>XSS是向页面注入脚本运行</p><p>CSRF是利用漏洞执行原网页接口，且必须用户登录网站</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web安全&quot;&gt;&lt;a href=&quot;#Web安全&quot; class=&quot;headerlink&quot; title=&quot;Web安全&quot;&gt;&lt;/a&gt;Web安全&lt;/h2&gt;&lt;h3 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://turing5467.github.io/2020/06/12/js/%E7%AE%97%E6%B3%95/"/>
    <id>https://turing5467.github.io/2020/06/12/js/算法/</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2020-06-12T11:22:36.999Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://segmentfault.com/img/bVNIpc?w=554&h=337" alt="图片描述"> </p><h2 id="排序-升序"><a href="#排序-升序" class="headerlink" title="排序(升序)"></a>排序(升序)</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>原理：比较相邻的两个数，将值较大的数放右边，值较小的放左边</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化</li></ul><blockquote><p>冒泡排序总会执行(N-1)+(N-2)+(N-3)+..+2+1趟，但如果运行到当中某一趟时排序已经完成，那么后边的比较就都是多余的，为了避免这种情况：</p><p>​    我们增加一个flag，判断排序是否在中途就已经完成（即判断有无发生元素交换）.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// flag含义：如果某次循环中没有交换过元素，那么意味着排序已经完成</span></span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li>选取基准元素</li><li>比基准元素小的元素放到左边，大的放右边</li><li>在左右子数组中重复步骤一二，直到数组只剩下一个元素</li><li>向上逐级合并数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr          <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">const</span> pivot = arr.length / <span class="number">2</span> | <span class="number">0</span>        <span class="comment">//基准点</span></span><br><span class="line">    <span class="keyword">const</span> pivotValue = arr.splice(pivot, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> leftArr = []</span><br><span class="line">    <span class="keyword">const</span> rightArr = []</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        val &gt; pivotValue ? rightArr.push(val) : leftArr.push(val)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> [ ...quickSort(leftArr), pivotValue, ...quickSort(rightArr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边这个快排只是让读者找找感觉，我们不能这样写快排，如果每次都开两个数组，会<strong>消耗很多内存空间</strong>，数据量大时可能造成<strong>内存溢出</strong>，我们要避免开新的内存空间，即原地完成排序</p><p>我们可以用元素交换来取代开新数组，在每一次分区的时候直接在原数组上交换元素，<strong>将小于基准数的元素挪到数组开头</strong>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个left和right代表分区后“新数组”的区间下标，因为这里没有新开数组，所以需要left/right来确认新数组的位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;          </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = left - <span class="number">1</span>                    <span class="comment">//pos“被置换的位置”，初始值-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;  </span><br><span class="line">            <span class="keyword">let</span> pivot = arr[right]            <span class="comment">//选取数组最后一位作为基准数，</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= pivot) &#123;             <span class="comment">//若小于等于基准数，pos++，并置换元素, 这里使用小于等于而不是小于, 其实是为了避免因为重复数据而进入死循环</span></span><br><span class="line">                pos++</span><br><span class="line">                <span class="keyword">let</span> temp = arr[pos]</span><br><span class="line">                arr[pos] = arr[i]</span><br><span class="line">                arr[i] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一趟排序完成后，pos位置即基准数的位置，以pos的位置分割数组</span></span><br><span class="line">        quickSort(arr, left, pos - <span class="number">1</span>)        </span><br><span class="line">        quickSort(arr, pos + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr      <span class="comment">//数组只包含1或0个元素时(即left&gt;=right)，递归终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">quickSort(arr, start, end)</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li><p>定义：在函数中调用自身函数</p></li><li><p>它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 </p></li><li><p>好处： 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大减少程序的代码量。 </p></li><li><p>缺点：</p><p>如果递归的次数特别多，那么调用栈将非常之大，最终可能超出调用栈的缓存大小而导致程序执行失败。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace()</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><ul><li>尾递归是一种递归的写法，可以避免不断的将函数压栈最终导致堆栈溢出。</li><li>通过设置一个累加参数，并且每一次都将当前的值累加上去，然后递归调用。 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 调用栈不再需要多次对<code>factorial</code>进行压栈处理，因为每一个递归调用都不在<strong>依赖</strong>于上一个递归调用的值。因此，空间的复杂度为o(1)而不是0(n)。 </p><ul><li>注意：尾递归不一定会将你的代码执行速度提高；相反，可能会变慢。不过，尾递归可以让你使用<strong>更少的内存</strong>，使你的递归函数更加安全 (前提是你要开启<code>harmony</code>模式)。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;img src=&quot;https://segmentfault.com/img/bVNIpc?w=554&amp;h=337&quot; alt=&quot;图片描述&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;排序-升序&quot;&gt;&lt;a href=&quot;#排序-升序&quot; class=&quot;headerlink&quot; title=&quot;排序
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://turing5467.github.io/2020/06/11/%E9%9D%A2%E8%AF%95/128/"/>
    <id>https://turing5467.github.io/2020/06/11/面试/128/</id>
    <published>2020-06-11T04:01:22.872Z</published>
    <updated>2020-06-11T04:56:04.818Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eb55ceb6fb9a0436748297d" target="_blank" rel="noopener">原文</a></p><h3 id="1-DIV-CSS布局的好处"><a href="#1-DIV-CSS布局的好处" class="headerlink" title="1. DIV+CSS布局的好处"></a>1. DIV+CSS布局的好处</h3><ol><li>代码精简，且结构与样式分离，易于维护</li><li>代码量减少了，减少了大量的带宽，页面加载更快，提升用户的体验</li><li>对SEO更加友好，且H5又新增了许多语义化标签更是如此</li><li>允许更多炫酷的页面效果，丰富了页面</li><li>符合W3C标准，保证网站不会因为网络应用的升级而被淘汰</li></ol><p>缺点: 不同浏览器对web标准默认值不同，所以更容易出现对浏览器的兼容性问题。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a> 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的<code>then</code>方法和<code>catch、finally</code>方法会返回一个新的<code>Promise</code>所以可以允许我们链式调用，解决了传统的回调地狱问题。 </p><h3 id="Promise-all中如果有一个抛出异常了会如何处理"><a href="#Promise-all中如果有一个抛出异常了会如何处理" class="headerlink" title="Promise.all中如果有一个抛出异常了会如何处理"></a>Promise.all中如果有一个抛出异常了会如何处理</h3><p><code>all和race</code>传入的数组中如果有会抛出异常的异步任务，那么只有<strong>最先抛出的错误</strong>会被捕获，并且是被<code>then</code>的第二个参数或者后面的<code>catch</code>捕获；但并<strong>不会影响</strong>数组中其它的异步任务的执行。</p><h3 id="创建自定义事件的3种"><a href="#创建自定义事件的3种" class="headerlink" title="创建自定义事件的3种"></a>创建自定义事件的3种</h3><ol><li><p><code>Event</code></p></li><li><p><code>CustomEvent</code>可以传递参数</p></li><li><p><code>document.createEvent(type)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件名为'build'.</span></span><br><span class="line">event.initEvent(<span class="string">'build'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e.target matches elem</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发对象可以是任何元素或其他事件目标</span></span><br><span class="line">elem.dispatchEvent(event);</span><br></pre></td></tr></table></figure></li></ol><h3 id="所有的事件都有冒泡吗"><a href="#所有的事件都有冒泡吗" class="headerlink" title="所有的事件都有冒泡吗"></a>所有的事件都有冒泡吗</h3><p><img src="C:%5CUsers%5CAdministrator%5CDesktop%5Ctr%5CimgURL%5C%E5%86%92%E6%B3%A1.jpg" alt></p><h3 id="一句话描述一下this"><a href="#一句话描述一下this" class="headerlink" title="一句话描述一下this"></a>一句话描述一下this</h3><p>指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用</p><h3 id="CommonJS和ES6模块的区别"><a href="#CommonJS和ES6模块的区别" class="headerlink" title="CommonJS和ES6模块的区别"></a><a href="https://juejin.im/post/5eaacd175188256d4345ea3a" target="_blank" rel="noopener">CommonJS和ES6模块的区别</a></h3><ul><li>CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</li><li>CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li><li>CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li><li>且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li></ul><p>关于第一个差异，是因为CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><blockquote><p>模块的异步加载可以使用AMD或CMD规范</p></blockquote><h3 id="webpack中如何处理图片"><a href="#webpack中如何处理图片" class="headerlink" title="webpack中如何处理图片"></a>webpack中如何处理图片</h3><p>在<code>webpack</code>中有两种处理图片的<code>loader</code>：</p><ul><li><code>file-loader</code>：解决<code>CSS</code>等中引入图片的路径问题；(解决通过<code>url</code>,<code>import/require()</code>等引入图片的问题)</li><li><code>url-loader</code>：当图片小于设置的<code>limit</code>参数值时，<code>url-loader</code>将图片进行<code>base64</code>编码(当项目中有很多图片，通过<code>url-loader</code>进行<code>base64</code>编码后会减少<code>http</code>请求数量，提高性能)，大于limit参数值，则使用<code>file-loader</code>拷贝图片并输出到编译目录中；</li></ul><p>（详细使用可以查看这里：<a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/前端工程化/webpack/霖呆呆的webpack之路-loader篇.md#file-loader" target="_blank" rel="noopener">霖呆呆的webpack之路-loader篇</a>）</p><h3 id="在移动端中怎样初始化根元素的字体大小"><a href="#在移动端中怎样初始化根元素的字体大小" class="headerlink" title="在移动端中怎样初始化根元素的字体大小"></a>在移动端中怎样初始化根元素的字体大小</h3><p>一个简易版的初始化根元素字体大小。</p><p>页面开头处引入下面这段代码，用于动态计算<code>font-size</code>：(假设你需要的<code>1rem = 20px</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onWindowResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取html的宽度(窗口的宽度)</span></span><br><span class="line">    html.style.fontSize = html.getBoundingClientRect().width / <span class="number">20</span> + <span class="string">'px'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, onWindowResize);</span><br><span class="line">  onWindowResize();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一般还需要配合一个<code>meta</code>头：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="animation有一个steps-功能符知道吗？"><a href="#animation有一个steps-功能符知道吗？" class="headerlink" title="animation有一个steps()功能符知道吗？"></a>animation有一个steps()功能符知道吗？</h3><p>一句话介绍：<code>steps()</code>功能符可以<strong>让动画不连续。</strong></p><p>地位和作用：和贝塞尔曲线(<code>cubic-bezier()</code>修饰符)一样，都可以作为<code>animation</code>的第三个属性值。</p><p>和贝塞尔曲线的区别：贝塞尔曲线像是滑梯且有4个关键字(参数)，而<code>steps</code>像是楼梯坡道且只有<code>number</code>和<code>position</code>两个关键字。</p><p>语法：<code>steps(number, position)</code></p><ul><li><p>number: 数值，表示把动画分成了多少段</p></li><li><p>position: 表示动画是从时间段的开头连续还是末尾连续。支持<code>start</code>和<code>and</code></p><p>两个关键字，含义分别如下： </p><ul><li><code>start</code>：表示直接开始。</li><li><code>end</code>：表示戛然而止。是默认值。</li></ul></li></ul><p>具体可以看这里：<a href="https://www.zhangxinxu.com/wordpress/2018/06/css3-animation-steps-step-start-end/" target="_blank" rel="noopener">www.zhangxinxu.com/wordpress/2…</a></p><h3 id="在项目中如何把http的请求换成https"><a href="#在项目中如何把http的请求换成https" class="headerlink" title="在项目中如何把http的请求换成https"></a>在项目中如何把http的请求换成https</h3><p>由于我在项目中是会对<code>axios</code>做一层封装，所以每次请求的域名也是写在配置文件中，有一个<code>baseURL</code>字段专门用于存储它，所以只要改这个字段就可以达到替换所有请求<code>http</code>为<code>https</code>了。</p><p>当然后面我也有了解到：</p><p>利用<code>meta</code>标签把<code>http</code>请求换为<code>https</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span> =<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"upgrade-insecure-requests"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eb55ceb6fb9a0436748297d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-DIV-CSS布局的好处&quot;&gt;&lt;a href=&quot;#1-D
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React-Hooks</title>
    <link href="https://turing5467.github.io/2020/06/09/js%E6%A1%86%E6%9E%B6/react/React-Hooks/"/>
    <id>https://turing5467.github.io/2020/06/09/js框架/react/React-Hooks/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2020-06-29T12:55:19.568Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d" target="_blank" rel="noopener">引用文章1</a></p><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><ul><li>Hooks 是 React 16.8 新增的特性，它可以让你在<strong>不编写 class</strong> 的情况下<strong>使用 state 以及其他的 React 特性(如生命周期)</strong> </li></ul><h3 id="Hooks解决的问题"><a href="#Hooks解决的问题" class="headerlink" title="Hooks解决的问题"></a>Hooks解决的问题</h3><h4 id="1-类组件的的不足"><a href="#1-类组件的的不足" class="headerlink" title="1.类组件的的不足"></a>1.类组件的的不足</h4><ul><li><p><strong>状态逻辑难复用</strong></p><p>在组件之间复用状态逻辑很难，可能要用到 <strong>render props</strong> （<strong>渲染属性</strong>）或者 <strong>HOC</strong>（<strong>高阶组件</strong>），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），<strong>导致层级冗余</strong> </p></li><li><p><strong>趋向复杂难以维护</strong></p><ul><li>在生命周期函数中混杂不相干的逻辑（如：在 <code>componentDidMount</code> 中注册事件以及其他的逻辑，在 <code>componentWillUnmount</code> 中卸载事件，这样分散不集中的写法，很容易写出 bug ）</li><li>组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件</li></ul></li><li><p><strong>this指向问题</strong></p><ul><li>父组件给子组件传递函数时，必须绑定 this </li><li>react 中的组件四种绑定 this 方法的区别 （ 前提：子组件内部做了性能优化）<ul><li><strong>构造函数中绑定 this</strong>：那么每次父组件刷新的时候，如果传递给子组件其他的 <code>props 值不变</code>，那么子组件就不会刷新；</li><li><strong>在 render() 函数里面绑定 this</strong>：因为 <strong>bind 函数会返回一个新的函数</strong>，所以每次父组件刷新时，<code>都会重新生成</code>一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新</li><li><strong>使用箭头函数</strong>：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件<code>每次都会刷新</code></li><li><strong>使用类的静态属性：原理和第一种方法差不多，比第一种更简洁</strong></li></ul></li></ul></li></ul><h4 id="2-Hooks优势"><a href="#2-Hooks优势" class="headerlink" title="2.Hooks优势"></a>2.Hooks优势</h4><ul><li>能优化类组件的三大问题 </li><li>能在无需修改组件结构的情况下<strong>复用状态逻辑</strong>：使用自定义 Hooks </li><li>能将组件中相互关联的部分拆分成更小的函数（如订阅、请求数据） ：<code>useEffect</code></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614215115698.png" alt="image-20200614215115698"></p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul><li>多次调用<code>useState</code>，渲染时调用顺序不变</li><li>重复渲染时保留<code>state</code></li><li>参数为初始<code>state</code></li><li>返回值为一个数组<ol><li>第一项为返回的<code>state</code></li><li>第二项为更新<code>state</code>的函数，不会合并新旧<code>state</code>，而是直接替换</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可以任意命名，因为返回的是数组，数组解构</span></span><br><span class="line"><span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="每次渲染都是独立的闭包"><a href="#每次渲染都是独立的闭包" class="headerlink" title="每次渲染都是独立的闭包"></a>每次渲染都是独立的闭包</h4><ul><li>每一次渲染都有它自己的 Props 和 State</li><li>每一次渲染都有它自己的事件处理函数</li><li>当点击更新状态的时候，函数组件都会重新被调用，那么每次渲染都是独立的，取到的值不会受后面操作的影响。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">TestCPN</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">alertNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// alert 只能获取到点击按钮时的那个状态</span></span><br><span class="line">        alert(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;alertNumber&#125;&gt;alertNumber&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击alertNumber =&gt;  (即使中间点击过+号)  =&gt; 弹出的值就是一开始的0</p><h4 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h4><ul><li>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将回调函数传递给 setState的参数。该回调函数将接收先前的 state，并返回一个更新后的值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 这样每次执行时都会去获取一遍 state，而不是使用点击触发时的那个 state</span></span><br><span class="line">            setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">           &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">           &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">           &lt;button onClick=&#123;lazy&#125;&gt;lazy&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击lazy  =&gt; (期间点击+号) =&gt; 3秒后的number为多次点击+号后的结果</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ul><li><p>effect(副作用)：指那些没有发生在数据向视图转换过程中的逻辑，如<code>ajax</code>请求，访问原生<code>dom</code>元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志。</p></li><li><p>副作用可分为两类：需要清除的、不需要清楚的</p></li><li><p><code>useEffect</code>就是一个effect Hook，给函数组件增加了操作副作用的能力。</p></li><li><p>它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API 。</p><p>与 <code>componentDidMount</code> 或 <code>didUpdate</code> 不同， <code>useEffect</code> 不会阻塞浏览器更新屏幕，这让你的应用看起来<strong>响应更快</strong>。 </p></li><li><p><code>useEffect</code><strong>接收一个函数</strong>，该函数会<strong>在组件渲染后才执行</strong>，该函数有要求：要么<strong>返回一个能清除副作用的函数</strong>，要么就<strong>不返回任何内容</strong></p></li></ul><h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><ul><li>可以通过给<code>useEffect</code>返回一个函数来指定如何清除副作用， 为防止内存泄漏，清除函数会在在组件卸载前执行</li><li>如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useEffect, useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> [text,setText] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="comment">// 相当于componentDidMount 和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">        <span class="keyword">let</span> $timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用</span></span><br><span class="line">        <span class="comment">// useEffect 在执行副作用函数之前，会先调用上一次返回的函数</span></span><br><span class="line">        <span class="comment">// 清除副作用: 返回一个清除副作用的函数</span></span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'destroy effect'</span>);</span><br><span class="line">            clearInterval($timer);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;input value=&#123;text&#125; onChange=&#123;(event)=&gt;setText(event.target.value)&#125;/&gt;</span><br><span class="line">          &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button&gt;+&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 通过使用 Hook，你可以把组件内<strong>相关的副作用</strong>组织在一起（例如创建订阅及取消订阅），而不要把它们拆分到不同的生命周期函数里。 </p></blockquote><h4 id="跳过effect进行性能优化"><a href="#跳过effect进行性能优化" class="headerlink" title="跳过effect进行性能优化"></a>跳过effect进行性能优化</h4><ul><li>依赖项数组控制着useEffect的执行</li><li>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用：传递数组作为 <code>useEffect</code>的第二个可选参数即可 </li><li>如果想执行<strong>只运行一次的 effect</strong>（仅在组件挂载和卸载时执行），可以传递一个空数组<code>[]</code>作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 </li></ul><h4 id="使用多个Effect实现关注点分离"><a href="#使用多个Effect实现关注点分离" class="headerlink" title="使用多个Effect实现关注点分离"></a>使用多个Effect实现关注点分离</h4><ul><li>解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。 </li><li>例如 ：设置 <code>document.title</code> 的逻辑被分割到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 中，订阅逻辑又被分割到 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 中的，而<code>componentDidMount</code>中同时包含了两个不同功能的代码。这样会使<strong>生命周期函数变得混乱</strong></li><li><strong>Hook 允许我们按照代码的用途分离他们</strong> </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//设置document.title逻辑</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">          setIsOnline(status.isOnline);</span><br><span class="line">      &#125;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟ComponentDidUpdate"><a href="#模拟ComponentDidUpdate" class="headerlink" title="模拟ComponentDidUpdate"></a>模拟ComponentDidUpdate</h4><p> <code>componentDidUpdate</code>就相当于除去第一次调用的<code>useEffect</code>，我们可以借助<code>useRef</code>生成一个标识，来记录是否为第一次执行： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDidUpdate</span>(<span class="params">callback, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> init = useRef(<span class="literal">true</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.current) &#123;</span><br><span class="line">      init.current = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟ComponentDidMount"><a href="#模拟ComponentDidMount" class="headerlink" title="模拟ComponentDidMount"></a>模拟ComponentDidMount</h4><p><code>componentDidMount</code>等价于<code>useEffect</code>的回调仅在页面初始化完成后执行一次，当<code>useEffect</code>的第二个参数传入一个空数组时可以实现这个效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function useDidMount(callback) &#123;</span><br><span class="line">  useEffect(callback, []);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>官方不推荐上面这种写法，因为这有可能导致一些错误。</p></blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p> <img src="https://user-gold-cdn.xitu.io/2019/11/1/16e25d2b5844206c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p><ul><li><p><code>useEffect</code>在全部渲染完毕后才会执行</p></li><li><p><code>useLayoutEffect</code>会在 浏览器 <code>layout</code>之后，<code>painting</code>之前执行</p></li><li><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect</p></li><li><p>可以使用它来读取 DOM 布局并<strong>同步触发重渲染</strong></p></li><li><p>在浏览器执行绘制之前 <code>useLayoutEffect</code>内部的更新计划将被<strong>同步</strong>刷新</p></li><li><p><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useLayoutEffect,useEffect, useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">LayoutEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = useState(<span class="string">'red'</span>);</span><br><span class="line">    useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        alert(color);</span><br><span class="line">    &#125;);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'color'</span>, color);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div id=<span class="string">"myDiv"</span> style=&#123;&#123; <span class="attr">background</span>: color &#125;&#125;&gt;颜色&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setColor('red')&#125;&gt;红&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setColor(<span class="string">'yellow'</span>)&#125;&gt;黄&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setColor('blue')&#125;&gt;蓝&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">alert(<span class="string">'red'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'red'</span>)</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h4 id="惰性初始化state"><a href="#惰性初始化state" class="headerlink" title="惰性初始化state"></a>惰性初始化state</h4><ul><li><code>initialState</code>参数只会在组件的<strong>初始化渲染</strong>中起作用，后续渲染时会被忽略</li><li>如果初始 state 需要通过复杂计算获得，则可以<strong>传入一个函数</strong>，在函数中计算并返回初始的 state，此函数只在<strong>初始渲染</strong>时被调用</li></ul><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><ul><li><p>接收一个 <code>context</code>对象（<code>React.createContext</code> 的返回值）并返回该 <code>context</code></p></li><li><p>当前的 <code>context</code>值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code>决定</p></li><li><p>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染</p></li><li><p><code>useContext(MyContext)</code> 相当于 class 组件中的  <code>&lt;MyContext.Consumer&gt;</code></p></li><li><p><code>useContext(MyContext)</code> 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用  来为下层组件提供 context</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button style=&#123;&#123; <span class="attr">background</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Toolbar /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><ul><li><code>useReducer</code>和 redux 中的 reducer 很像</li><li><code>useState</code>内部就是靠 <code>useReducer</code>来实现的</li><li><code>useState</code>的替代方案，它接收一个形如 <code>(state, action) =&gt; newState</code>的 reducer，并返回当前的 <code>state</code>以及与其配套的 <code>dispatch</code>方法</li><li>在某些场景下，<code>useReducer</code>会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一种传参方式：reducer, initialState</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值：initialState</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第二种传参方式：(reducer, initFnParam, initFn)</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">&#123;<span class="comment">/* payload为额外参数，传入reducer.action */</span>&#125;</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="useMemo-amp-amp-useCallBack"><a href="#useMemo-amp-amp-useCallBack" class="headerlink" title="useMemo &amp;&amp; useCallBack"></a>useMemo &amp;&amp; useCallBack</h3><ul><li>默认情况，只要父组件状态变了（不管子组件依不依赖该状态），子组件也会重新渲染</li><li>优化<ol><li>类组件：可以使用<code>PureComponent</code></li><li>函数组件：使用<code>React.memo</code>， 将函数组件传递给 <code>memo</code> 之后，就会返回一个新的组件，新组件的功能：<strong>如果接受到的属性不变，则不重新渲染函数</strong>； </li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,memo, useMemo,useCallback&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCounter</span>(<span class="params">&#123;onClick,data&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'SubCounter render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;&#123;data.number&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/返回新组件：接收属性不变，则不重新渲染函数</span></span><br><span class="line"><span class="regexp">SubCounter = memo(SubCounter);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export  default  function Counter4()&#123;</span></span><br><span class="line"><span class="regexp">    console.log('Counter4 render');</span></span><br><span class="line"><span class="regexp">    const [name,setName]= useState('计数器');</span></span><br><span class="line"><span class="regexp">    const [number,setNumber] = useState(0);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/组件更新时，变量和函数每次都会重新创建，那么子组件接受到的属性每次都会认为是新的</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/因此需要使用useMemo：缓存&lt;变量&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/注意：必须传递第二个参数：依赖项数组，否则还是会重新渲染</span></span><br><span class="line"><span class="regexp">    const data =useMemo(() =&gt;(&#123;number&#125;), [number]);</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/useCallback: 缓存&lt;函数&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/注意：必须传递第二个参数：依赖项数组，否则还是会重新渲染</span></span><br><span class="line"><span class="regexp">    const addClick = useCallback(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">        setNumber(number+1);</span></span><br><span class="line"><span class="regexp">    &#125;, [number]);</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;input type="text" value=&#123;name&#125; onChange=&#123;(e)=&gt;setName(e.target.value)&#125;/</span>&gt;</span><br><span class="line">            &lt;SubCounter data=&#123;data&#125; onClick=&#123;addClick&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 你也可以通过给<code>React.memo</code>的第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。 </p></blockquote><blockquote><p>useCallback的依赖项如果时<code>空数组</code>只会在挂载阶段执行；</p><p>如果依赖项是一个<code>变化的值</code>，那么在依赖项变化的时候执行；</p><p>如果<code>不传</code>第二个参数，那么每次都会执行 </p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li><strong>类组件</strong>使用 <code>React.createRef</code>，<strong>函数组件</strong>使用 <code>useRef</code><ol><li>useRef 返回的 ref 对象在组件的<strong>整个生命周期内保持不变</strong>，也就是说每次重新渲染函数组件时，返回的ref 对象都是同一个</li><li>使用 <code>React.createRef</code>，每次重新渲染组件都会重新创建 ref</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现类似实例变量的东西"><a href="#实现类似实例变量的东西" class="headerlink" title="实现类似实例变量的东西"></a>实现类似实例变量的东西</h4><p> <code>useRef()</code> Hook 不仅可以用于 DOM refs。</p><p>「ref」 对象是一个 <code>current</code> 属性可变且可以容纳任意值的通用容器，类似于一个 class 的实例属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> intervalRef = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    intervalRef.current = timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearInterval(intervalRef.current);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何测量DOM节点"><a href="#如何测量DOM节点" class="headerlink" title="如何测量DOM节点"></a>如何测量DOM节点</h4><p> 获取 DOM 节点的位置或是大小的基本方式是使用 <a href="https://react.docschina.org/docs/refs-and-the-dom.html#callback-refs" target="_blank" rel="noopener">callback ref</a>。每当 ref 被附加到一个另一个节点，React 就会调用 callback。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MeasureExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [height, setHeight] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> measuredRef = useCallback(<span class="function"><span class="params">node</span> =&gt;</span> &#123;    </span><br><span class="line">      <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;     </span><br><span class="line">          setHeight(node.getBoundingClientRect().height);    </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 ref=&#123;measuredRef&#125;&gt;Hello, world&lt;<span class="regexp">/h1&gt;      </span></span><br><span class="line"><span class="regexp">  &lt;h2&gt;The above header is &#123;Math.round(height)&#125;px tall&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>  我们没有选择使用 <code>useRef</code>，因为当 ref 是一个对象时它并不会把当前 ref 的值的 <em>变化</em> 通知到我们。  使用 callback ref 可以确保 即便子组件延迟显示被测量的节点(比如为了响应一次点击)，我们依然能够在父组件接收到相关的信息，以便更新测量结果。 </p><p> 注意到我们传递了 <code>[]</code> 作为 <code>useCallback</code> 的依赖列表。这确保了 ref callback 不会在再次渲染时改变，因此 React 不会在非必要的时候调用它。 </p><h4 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h4><ul><li><strong>因为函数组件没有实例，所以函数组件无法像类组件一样可以接收 ref 属性</strong> ：<code>&lt;Child ref={xxx} /&gt;</code>是不行的</li><li>forwardRef 可以在父组件中操作<strong>子组件</strong>的 ref 对象</li><li>forwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props,ref</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> ref=&#123;ref&#125;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1（相较普通ref多的一步）</span></span><br><span class="line">Child = React.forwardRef(Child);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>); </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();<span class="comment">//&#123;current:''&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    inputRef.current.value = <span class="string">'focus'</span>;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      <span class="comment">/* 3 */</span></span><br><span class="line">        &lt;Child ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;setNumber(&#123;<span class="attr">number</span>:number+<span class="number">1</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><ul><li><code>useImperativeHandle</code>可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useRef,forwardRef,useImperativeHandle&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props, ref</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> focusRef = useRef();</span><br><span class="line">    <span class="keyword">let</span> inputRef = useRef();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父组件将要传进来的ref</span></span><br><span class="line">    useImperativeHandle(ref,()=&gt;&#123;</span><br><span class="line">      <span class="comment">// 这个函数会返回一个对象，作为父组件 current 属性的值</span></span><br><span class="line">      <span class="comment">// 通过这种方式，父组件可以使用操作子组件中的多个 ref</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            focusRef,</span><br><span class="line">            inputRef,</span><br><span class="line">            name:<span class="string">'计数器'</span>,</span><br><span class="line">            focus()&#123;</span><br><span class="line">                focusRef.current.focus();</span><br><span class="line">            &#125;,</span><br><span class="line">            changeText(text)&#123;</span><br><span class="line">                inputRef.current.value = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input ref=&#123;focusRef&#125;/&gt;</span><br><span class="line">            &lt;input ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Child = forwardRef(Child);</span></span><br><span class="line"><span class="regexp">export default function Parent()&#123;</span></span><br><span class="line"><span class="regexp">  const parentRef = useRef();/</span><span class="regexp">/&#123;current:''&#125;</span></span><br><span class="line"><span class="regexp">  function getFocus()&#123;</span></span><br><span class="line"><span class="regexp">    parentRef.current.focus();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效，不注释会报错</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ parentRef.current.addNumber(666);</span></span><br><span class="line"><span class="regexp">    parentRef.current.changeText('&lt;script&gt;alert(1)&lt;/</span>script&gt;<span class="string">');</span></span><br><span class="line"><span class="string">    console.log(parentRef.current.name);//计数器</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">      &lt;&gt;</span></span><br><span class="line"><span class="string">        &lt;Child ref=&#123;parentRef&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h3><p>自定义 Hook 更像是一种约定，而不是一种功能。</p><p>如果函数的名字以 <code>use</code> 开头，并且<strong>调用了其他的 Hook</strong>，则就称其为一个<strong>自定义 Hook</strong></p><p>有时候我们会想要在组件之间<strong>重用一些状态逻辑</strong>，之前要么用 render props ，要么用高阶组件，要么使用 redux。自定义 Hook 可以让你在不增加组件的情况下达到同样的目的</p><blockquote><p> 每个组件调用同一个 hook，只是复用 hook 的状态逻辑，并<strong>不会共用一个状态</strong> 。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;,[]);</span><br><span class="line">  <span class="keyword">return</span> [number,setNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>只能在<strong>函数最外层</strong>调用 Hook 。不要在循环，条件或嵌套函数中调用Hook。 </p><p><code>Hook</code>通过数组实现的，每次<code>useState</code> 都会改变下标，<code>React</code>需要利用调用顺序来正确更新相应的状态，如果<code>useState</code> 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。 </p></li><li><p>只能在 <strong>React 的函数组件</strong>中调用 Hook。 （自定义Hook除外）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引用文章1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-Hooks&quot;&gt;&lt;a href=&quot;#Rea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试题收集</title>
    <link href="https://turing5467.github.io/2020/06/07/%E9%9D%A2%E8%AF%95/5467/"/>
    <id>https://turing5467.github.io/2020/06/07/面试/5467/</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-06-22T10:11:44.290Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/qiu-deqing/FE-interview#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">1</a></p><h3 id="前端需要注意哪些-SEO"><a href="#前端需要注意哪些-SEO" class="headerlink" title="前端需要注意哪些 SEO"></a>前端需要注意哪些 SEO</h3><ol><li>合理的 title、description、keywords：搜索对着三项的权重逐个减小，<ul><li><code>title</code>值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；</li><li><code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；</li><li><code>keywords</code>列举出重要关键词即可</li></ul></li><li><strong>语义化</strong>的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li><li>少用 <code>iframe</code>：搜索引擎不会抓取 iframe 中的内容</li><li>非装饰性图片必须加 alt</li><li><strong>提高网站速度</strong>：网站速度是搜索引擎排序的一个重要指标</li></ol><h3 id="什么是-web-语义化-有什么好处"><a href="#什么是-web-语义化-有什么好处" class="headerlink" title="什么是 web 语义化,有什么好处"></a>什么是 web 语义化,有什么好处</h3><p>web 语义化是指通过 HTML 标记表示页面包含的信息，包含了 HTML 标签的语义化和 css 命名的语义化。 </p><p>HTML 标签的语义化：通过使用包含语义的标签（如 h1-h6）恰当地表示文档结构 </p><p>css 命名的语义化：为 html 标签添加有意义的 class，id 补充未表达的语义，如<a href="http://en.wikipedia.org/wiki/Microformats" target="_blank" rel="noopener">Microformat</a>通过添加符合规则的 class 描述信息 为什么需要语义化：</p><ul><li>去掉样式后页面呈现清晰的结构</li><li>无障碍阅读：盲人使用读屏器更好地阅读</li><li><strong>搜索引擎</strong>更好地理解页面，有利于收录</li><li>便团队项目的<strong>可持续运作及维护</strong></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1&guce_referrer=aHR0cHM6Ly9naXRodWIuY29tL3FpdS1kZXFpbmcvRkUtaW50ZXJ2aWV3&guce_referrer_sig=AQAAAGCBP4o39rOh6MQI2wJq1jnXE-fn4Y-QMWSTUxOygtHtjvtuqMQKvj-xBmfOVL-VkBlowdS8TuND8_KVv-KgiJoeZ_SSrgdv-O_vLk18Lypkbg-PnaKOwPOjXwh_XUJUHRK9qAVqTKQsBzdw4DwkcdtZ9pZcLq5jy9dbPCgyRvZ7" target="_blank" rel="noopener">雅虎性能优化</a></p><ul><li>content 方面<ol><li>减少 HTTP 请求：合并文件、CSS 精灵、inline Image</li><li>减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询</li><li>非必须组件延迟加载</li><li>减少 DOM 元素数量</li><li>避免空 src 的 img 标签</li></ol></li><li>Server 方面<ol><li>使用 CDN</li><li>添加 Expires 或者 Cache-Control 响应头</li><li>对组件使用 Gzip 压缩</li><li>配置 ETag</li></ol></li><li>Cookie 方面<ol><li>减小 cookie 大小</li></ol></li><li>css 方面<ol><li>将样式表放到页面顶部</li><li>不使用 CSS 表达式</li><li>使用<code>&lt;link&gt;</code>不使用@import</li><li>不使用 IE 的 Filter</li></ol></li><li>Javascript 方面<ol><li>将脚本放到页面底部</li><li>将 javascript 和 css 从外部引入</li><li>压缩 javascript 和 css</li><li>删除不需要的脚本</li><li>减少 DOM 访问</li></ol></li><li>图片方面<ol><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化 css 精灵</li><li>不要在 HTML 中拉伸图片</li><li>保证 favicon.ico 小并且可缓存</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/qiu-deqing/FE-interview#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Immutable</title>
    <link href="https://turing5467.github.io/2020/06/05/js/%E5%BA%93/Immutable/"/>
    <id>https://turing5467.github.io/2020/06/05/js/库/Immutable/</id>
    <published>2020-06-04T16:00:00.000Z</published>
    <updated>2020-06-05T13:03:01.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h2><p> 通过<code>Immutable</code>创建的<code>Immutable Data</code>一旦被创建，就不能再更改。对<code>Immutable</code>对象进行修改、添加或删除操作，都会返回一个新的<code>Immutable</code>对象。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Immutable&quot;&gt;&lt;a href=&quot;#Immutable&quot; class=&quot;headerlink&quot; title=&quot;Immutable&quot;&gt;&lt;/a&gt;Immutable&lt;/h2&gt;&lt;p&gt; 通过&lt;code&gt;Immutable&lt;/code&gt;创建的&lt;code&gt;Immutabl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端面试视频笔记</title>
    <link href="https://turing5467.github.io/2020/06/03/%E9%9D%A2%E8%AF%95/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://turing5467.github.io/2020/06/03/面试/视频笔记/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-14T16:22:46.084Z</updated>
    
    <content type="html"><![CDATA[<p>1</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603091751928.png" alt="image-20200603091751928"></p><p>2 3</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603091849574.png" alt="image-20200603091849574"></p><p>4</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603092023557.png" alt="image-20200603092023557"></p><h3 id="什么是面试"><a href="#什么是面试" class="headerlink" title="什么是面试"></a>什么是面试</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603092544423.png" alt="image-20200603092544423"></p><h3 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h3><ul><li><p>职业描述（JD）分析</p><p>通过分析决定该职位是否为我想要的/我能胜任的，之后，对所需要的技术做准备</p><p>根据JD对简历进行相应的修改</p></li><li><p>业务分析或实战模拟</p><p>去公司的网站看使用了什么技术 ，如Vue、Webpack、存储技术</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603101707355.png" alt="image-20200603101707355"></p><p>第一行：处理兼容性</p><p>第二行：使用双核浏览器时，优先使用哪个内核</p><p>三、四行：DNS预解析，可以做性能优化</p></li><li><p>技术栈准备</p><p>jQuery、Vue、React、node（源码、原理（看文章））</p><p>Less、Sass、Gulp、webpack、grunt、npm、browserify</p></li></ul><ul><li><p>自我介绍</p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200603103925701.png" alt="image-20200603103925701" style="zoom:67%;"><ol><li>把握面试的沟通方向（面试官会根据你说的来提问）</li><li>豁达、自信的适度发挥（声音清晰，自信）    </li></ol></li><li><p>实例</p><ol><li><p>适时讨疑问：</p><p>当面试官问到了一些 你还不会的问题，不要回答：我不知道…</p><p>而是，这个问题我要回去思考一下（面试官可以指导一下吗，给我点建议之类）</p></li><li><p>节奏要适宜 ，切记小聪明</p></li><li><p>方向要对，过程要细：</p><p>如性能优化，有哪几个方向，如何实现…</p></li><li><p>胆子要大，心态要和：</p><p>遇见难题不要怕，要多想，答错也比什么都不想强</p><p>勇于承担责任，敢于挑战未知，不要轻易放弃</p><p>：<em>面试官可不可以给我一点提示呀</em></p></li></ol></li></ul><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h4><ul><li>语义化掌握到位</li><li>页面布局理解深刻</li><li>CSS基础扎实</li><li>思维灵活且积极上进（会用grid布局…）</li><li>代码书写规范</li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603151616502.png" alt="image-20200603151616502"></p><h4 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h4><p>1.基本概念：标准模型 + IE模型</p><ul><li><p>标准模型：    BoxWidth = contentWidth</p></li><li><p>IE模型：BoxWidth = contentWidth + padding + border</p></li></ul><p>2.如何设置这两种模型：<code>box-sizing: content/border-box;</code></p><p>3.JS如何获取盒模型对应的宽高：</p><ol><li><code>dom.style.width</code>：只能获取内联属性，没有则返回空串</li><li><code>dom.currentStyle.width</code>：获取css中的属性，只有IE支持</li><li><code>window.getComputedStyle(dom).width</code>：获取的是content-box的宽度（带单位），所有浏览器支持</li><li><code>dom.getBoundingClientRect().width</code>：获取的是border-box的宽度同上（不带单位）</li></ol><p>4.根据盒模型解释边距重叠：</p><ol><li>父子</li><li>兄弟</li></ol><p>BFC（边距重叠解决方案）：</p><ul><li>BFC：块级格式化上下文</li><li>两栏布局时，左边浮动</li><li>清除浮动</li></ul><h4 id="DOM事件类"><a href="#DOM事件类" class="headerlink" title="DOM事件类"></a>DOM事件类</h4><p>1.DOM事件级别：</p><ul><li>DOM0：<code>ele.onclick = function(){}</code></li><li>DOM2：<code>ele.addEventListener(&#39;click&#39;, fucntion(){}, false)</code>false表示在冒泡阶段触发，true表示在捕获阶段触发</li><li>DOM3：<code>ele.addEventListener(&#39;keyup&#39;, function(){}, false)</code>添加了很多事件类型</li></ul><p>2.DOM事件模型：捕获、冒泡</p><p>3.DOM事件流：捕获-&gt;目标-&gt;冒泡</p><p>​    事件通过捕获到达目标元素 =&gt; 目标阶段</p><p>​    事件从目标元素冒泡到window对象 =&gt; 冒泡</p><p>4.事件捕获具体流程：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603201243266.png" alt="image-20200603201243266"></p><p>5.Event对象的常见应用：</p><ol><li><code>e.preventDefault()</code></li><li><code>e.stopPropogation()</code></li><li><code>e.stopImmediatePropagation()</code> 阻止事件冒泡,同时将该元素の同类型事件也阻止</li><li><code>e.target/srcElement</code>触发当前事件的元素</li><li><code>e.currentTarget</code>绑定当前事件的元素</li></ol><p>6.自定义事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法向回调函数添加数据</span></span><br><span class="line"><span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">'jump'</span>)</span><br><span class="line">ele.addEventListener(<span class="string">'jump'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'jump'</span>); </span><br><span class="line">&#125;)</span><br><span class="line">ele.dispatchEvent(eve);  <span class="comment">//参数不能写字符串</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//customEvent: 可以向回调函数添加数据</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">"build"</span>, &#123;</span><br><span class="line">    <span class="comment">//参数写在这里</span></span><br><span class="line">    detail: &#123;</span><br><span class="line">        name: <span class="string">'turing'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bubbles: <span class="literal">true</span>,</span><br><span class="line">    cancelable: <span class="literal">false</span> <span class="comment">//是否取消默认事件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ele.addEventListener(<span class="string">"build"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我叫"</span> + e.detail.name)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">ele.dispatchEvent(event); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure><h4 id="HTTP协议类"><a href="#HTTP协议类" class="headerlink" title="HTTP协议类"></a>HTTP协议类</h4><p>1.主要特点</p><p>​        简单快速  灵活   </p><ul><li><strong>无连接</strong>：连接一次就会断开</li><li><strong>无状态</strong>：无法区分不同连接</li></ul><p>2.报文的组成部分</p><p>3.HTTP方法</p><ul><li>GET：获取资源</li><li>POST：传输资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获得报文首部</li></ul><p>4.GET和POST的区别</p><p>5.HTTP状态码</p><p>6.什么是持久连接</p><p>7.什么是管线化</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>1.创建对象的几种方式</p><p>2.原型、构造函数、实例、原型链</p><p>3.instanceof</p><p>4.new运算符</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>继承的几种方式和优缺点</p><h4 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h4><p>1.什么是同源策略及限制</p><p>2.前后端如何通信</p><ul><li>Ajax</li><li>WebSocket：不受同源策略限制</li><li>CORS：都支持</li></ul><p>3.如何创建Ajax</p><ul><li>XHR对象的工作流程</li><li>兼容性处理</li><li>事件的触发条件</li><li>事件的触发顺序</li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103713775.png" alt="image-20200604103713775"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103233402.png" alt="image-20200604103233402"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103435122.png" alt="image-20200604103435122"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103400308.png" alt="image-20200604103400308"></p><p>4.跨域通信的几种方式</p><ul><li>jsonp</li><li>Hash（原理：Hash的改变不会刷新页面，?xx=xx会）</li><li>postMessage（H5）</li><li>Websocket</li><li>CORS（原理：改变Ajax请求头中的origin）</li><li>nginx</li></ul><h4 id="安全类"><a href="#安全类" class="headerlink" title="安全类"></a><a href="https://juejin.im/post/5cd6ad7a51882568d3670a8e" target="_blank" rel="noopener">安全类</a></h4><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li><p><a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">排序</a>：快速、选择、希尔、冒泡</p><p> <img src="https://segmentfault.com/img/bVNIpc?w=554&h=337/view" alt="preview"> </p></li><li><p><a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">堆栈、队列、链表</a></p></li><li><p><a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">递归</a></p></li><li><p>波兰式和逆波兰式：<a href="https://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">理论</a>、<a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">源码</a></p></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><h4 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h4><p>1.<a href="https://blog.csdn.net/sunhl951/article/details/79763727" target="_blank" rel="noopener">什么是DOCTYPE及作用</a></p><p>2.浏览器渲染过程</p><p>3.重排Reflow、重绘Repaint</p><p>4.布局Layout</p><h4 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h4><p>1.理解JS单线程的概念</p><p>2.理解任务队列</p><p>3.理解Event Loop</p><h4 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h4><ul><li>提升页面性能的方法有哪些<ol><li>资源压缩合并，减少HTTP请求</li><li>非核心代码异步加载 </li><li>利用浏览器缓存 =&gt; 缓存的分类 =&gt; 缓存的原理</li><li>使用CDN(内容分发网络)：使网络快速到达服务端然后下载下来</li><li>预解析DNS<ul><li><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code>强制打开a标签的DNS预解析（大部分默认on，https默认off）</li><li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//hostname_to_prefetch.com&quot;&gt;</code></li></ul></li></ol></li></ul><ul><li><p>异步加载：①动态加载脚本 ② defer  ③async</p></li><li><p>缓存</p><ol><li><p>强缓存（不询问直接缓存）</p><ul><li><p><code>Expires:Thu,21 Jan 2020 23:59:59 GMT</code>绝对时间</p></li><li><p><code>Cache-Control: max-age=3600(s)</code>相对时间，优先级更高</p><p><img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp" alt="img"> </p></li></ul></li></ol></li></ul><ol start="2"><li><p>协商缓存（询问服务器资源能否使用后再决定缓不缓存）</p><ul><li><p><code>Last-Modified</code> 、<code>If-Modified-Since</code>：将<code>Last-Moodified</code>值发送给服务端，询问资源是否已经过期，过期则返回新资源</p><p>  缺点：修改时间变化，而内容没变时，也会返回新资源</p><ul><li><code>Etag</code>、<code>If-None-Match</code>： 当且仅当服务器上没有任何资源的 <code>ETag</code>属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 <code>200</code> 。 </li></ul></li></ul></li></ol><h4 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a><a href="https://www.cnblogs.com/gaoning/p/7928497.html" target="_blank" rel="noopener">错误监控</a></h4><ul><li><p>错误分类</p><ol><li>即时运行错误：代码错误</li><li>资源加载错误</li></ol></li><li><p>错误的捕获方式</p><ol><li><p>即时运行错误的捕获方式：</p><ul><li><code>try...catch</code></li><li><code>window.onerror</code></li></ul></li><li><p>资源加载错误的捕获</p><ul><li><p><code>ele.onerror</code>：ele指的是img、script需要加载资源的标签，且这种事件<strong>无法冒泡</strong>，无法通过window.onerror捕获</p></li><li><p><code>performance.getEntries(filterOption)</code>获取已成功加载的资源的<code>PerformanceEntry</code>对象数组</p></li><li><p>Error事件<strong>捕获</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>, e)</span><br><span class="line">&#125;, <span class="literal">true</span>) <span class="comment">//事件捕获</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604172559631.png" alt="image-20200604172559631"></p></li></ul><ul><li><p>上报错误的基本原理</p><ol><li><p>Ajax通信的方式上报</p></li><li><p>利用Image对象上报</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src = <span class="string">'http://baidu.com/sdfsd?r=fdsfds'</span></span><br></pre></td></tr></table></figure><p>通过Network可以看到请求已经发出了</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604172941479.png" alt="image-20200604172941479"></p></li></ol></li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><h4 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604174051451.png" alt="image-20200604174051451"></p><h4 id="团队协作能力"><a href="#团队协作能力" class="headerlink" title="团队协作能力"></a>团队协作能力</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604175054428.png" alt="image-20200604175054428"></p><h4 id="事务推动能力"><a href="#事务推动能力" class="headerlink" title="事务推动能力"></a>事务推动能力</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604175304851.png" alt="image-20200604175304851"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604175423737.png" alt="image-20200604175423737"></p><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><ol><li>乐观积极</li><li>主动沟通</li><li>逻辑顺畅</li><li>上进有责任心</li><li>有主张、做事果断</li></ol><h4 id="职业竞争力"><a href="#职业竞争力" class="headerlink" title="职业竞争力"></a>职业竞争力</h4><ol><li><p>业务能力</p></li><li><p>思考能力</p><p> 对同一件事可以从不同角度去思考，找到最优解</p></li><li><p>学习能力</p><p>不断学习新的业务和技术，沉淀、总结</p></li><li><p>无上限的付出</p><p>对于无法解决的问题可以熬夜、加班</p></li></ol><h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604180149862.png" alt="image-20200604180149862"></p><p>5、学会赞美（公司、HR ）</p><h4 id="还有什么想要问我的吗？"><a href="#还有什么想要问我的吗？" class="headerlink" title="还有什么想要问我的吗？"></a>还有什么想要问我的吗？</h4><ul><li>团队人员分布情况</li><li>技术栈</li><li>我进去主要是负责哪块内容</li><li>年终奖/季度奖</li><li>调薪的频率以及幅度</li><li>加班多不多</li></ul><h3 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604182437767.png" alt="image-20200604182437767"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604182705610.png" alt="image-20200604182705610"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604183055883.png" alt="image-20200604183055883"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604183454802.png" alt="image-20200604183454802"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603091751928.png&quot; alt=&quot;image
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器的缓存机制</title>
    <link href="https://turing5467.github.io/2020/06/01/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98/"/>
    <id>https://turing5467.github.io/2020/06/01/js/性能优化/缓存/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-06-17T03:24:56.708Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">原文</a></p><h2 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h2><p>缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以<strong>缩短网页请求资源的距离</strong>，减少延迟，并且由于缓存文件可以重复利用，还可以<strong>减少带宽</strong>，<strong>降低网络负荷</strong>。</p><p>对于一个数据请求来说，可以分为发起<strong>网络请求</strong>、<strong>后端处理</strong>、<strong>浏览器响应</strong>三个步骤。</p><p>浏览器缓存可以帮助我们在第一和第三步骤中优化性能。</p><p>比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p> 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 </p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>Service Worker 是<strong>运行在浏览器背后的独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <code>HTTPS</code>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p><strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong>。</p><p>Service Worker 实现缓存功能一般分为三个步骤：</p><ol><li>注册 Service Worker，</li><li>监听到 install 事件以后就可以缓存需要的文件，</li><li>下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li></ol><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>Memory Cache 也就是<strong>内存</strong>中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 <strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</strong>。</p><blockquote><p>Q：<strong>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</strong><br>A：这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 </p></blockquote><p>内存缓存中有一块重要的缓存资源是preloader相关指令（例如<code>&lt;link rel=&quot;prefetch&quot; &gt;</code>）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p> Disk Cache 也就是存储在<strong>硬盘</strong>中的缓存，读取<strong>速度慢</strong>点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在<strong>容量和存储时效性</strong>上。 </p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会<strong>根据 HTTP Header 中的字段判断</strong>哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读<code>Jake Archibald</code>的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p><ul><li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><h3 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h3><ul><li><p>浏览器与服务器通信的方式为<strong>应答模式</strong>，即是：浏览器发起HTTP请求 – 服务器响应该请求 </p></li><li><p>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong>。 </p><p><img src="https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip%7CimageView2/2/w/670/format/webp" alt="img"> </p></li></ul><p>由上图我们可以知道：</p><ul><li>浏览器每次<strong>发起</strong>请求，都会先在浏览器缓存中<strong>查找</strong>该请求的结果以及缓存标识</li><li>浏览器每次<strong>拿到</strong>返回的请求结果都会将该结果和缓存标识<strong>存入</strong>浏览器缓存中</li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><ul><li>强缓存：不会向服务器发送请求，直接从缓存中读取资源.</li><li>在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示<code>from disk cache</code>或<code>from memory cache</code>。</li><li>强缓存可以通过设置两种 HTTP Header 实现：<code>Expires</code>和 <code>Cache-Control</code>。</li></ul><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><ul><li><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。 </p></li><li><p>Expires是Web服务器<strong>响应头</strong>字段，在响应http请求时<strong>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求</strong>。 </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><p> 这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是<strong>服务器的时间和浏览器的时间可能并不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。 </p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><ul><li><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当<code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p></li><li><p>值（可以组合）</p><p> <img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp" alt="img"> </p></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li>协议版本：1.0  &amp;&amp;  1.1</li><li>优先级： Cache-Control更高</li></ul><p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容。</p><p><strong>那我们如何获知服务器端内容是否已经发生了更新呢</strong>？此时我们需要用到<strong>协商缓存策略</strong>。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p> 协商缓存就是<strong>强缓存失效</strong>后，浏览器携带<strong>缓存标识</strong>向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： </p><ol><li>协商缓存生效：返回304和Not Modified</li><li>协商缓存失效：返回200和请求结果</li></ol><h4 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h4><ul><li>浏览器第一次给服务器发送请求，服务器会在响应头中加上<code>Last-Modified</code></li><li>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，字段值为之前接收到的<code>Last-Modified</code>值</li><li>服务器拿到该值，会与该资源的最后修改时间对比<ol><li>如果没有变化，返回304和空的响应体</li><li>值小于最后修改时间，返回200和新的资源文件</li></ol></li></ul><ul><li>弊端<ol><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改  ，服务端不能命中缓存导致发送相同的资源 </li><li>能够感知的单位时间为<code>s</code>，若在一秒内改变多次，无法体现出修改，仍然返回修改之前的资源</li></ol></li></ul><h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h4><ul><li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识，只要资源有变化，Etag就会重新生成。 </li></ul><ul><li>浏览器第一次给服务器发送请求，服务器会在响应头中加上<code>ETag</code></li><li>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-None-Match</code>字段，字段值为之前接收到的<code>ETag</code>值</li><li>服务器拿到该值，会与该资源的最新<code>ETag</code>对比<ol><li>如果没有变化，返回304和空的响应体</li><li>值小于最后修改时间，返回200和新的资源文件</li></ol></li></ul><h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h4><ul><li><p>精确度：ETag &gt; Last-Modified</p></li><li><p>性能：Etag &lt;  Last-Modified</p><p>Last-Modified只记录一个时间点，而ETag根据文件具体内容生成Hash值。</p></li><li><p>优先级：ETag &gt; Last-Modified</p></li></ul><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>强制缓存优先于协商缓存进行，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存。</p><h3 id="实际场景应用"><a href="#实际场景应用" class="headerlink" title="实际场景应用"></a>实际场景应用</h3><h4 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h4><p>对于频繁变动的资源，首先需要使用<code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者<code>Last-Modified</code> 来验证资源是否有效。</p><p>这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><h4 id="不常变化的资源"><a href="#不常变化的资源" class="headerlink" title="不常变化的资源"></a>不常变化的资源</h4><p> 通常在处理这类资源时，给它们的 <code>Cache-Control</code> 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。 </p><h3 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h3><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ul><li>打开网页，地址栏输入地址： 查找 <code>disk cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)。其次才是 <code>disk cache</code>。</li><li>强制刷新 (Ctrl + F5)：<strong>浏览器不使用缓存</strong>，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/54cc04190252&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;浏览器的缓存机制&quot;&gt;&lt;a href=&quot;#浏览器的缓存机制&quot; class=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React Native(未完)</title>
    <link href="https://turing5467.github.io/2020/05/21/js%E6%A1%86%E6%9E%B6/react/React_Native/"/>
    <id>https://turing5467.github.io/2020/05/21/js框架/react/React_Native/</id>
    <published>2020-05-20T16:00:00.000Z</published>
    <updated>2020-06-24T04:33:18.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>目前比较成熟的跨平台方案</p><ol><li><strong>React Native</strong>， Vue + Weex</li><li>AppCan：</li><li>Flutter：基于dart语言，学习成本较大</li></ol></li><li><p>React Native已经完成了对多端的支持，实现了真正意义上的面向配置开发：开发人员可以只使用JavaScript也能编写原生移动，结合React语法构建组件，实现Android，IOS两端代码的复用，并发布上线。</p></li><li><p>本质上还是用Objective-C或Java编写的，只是用JS对其进行了封装</p><p>所以它产出的是一个真正的移动应用，在使用感受上和用OC或Java几乎无法区分</p></li></ul><h4 id="开发平台选择"><a href="#开发平台选择" class="headerlink" title="开发平台选择"></a>开发平台选择</h4><ol><li>MacOS系统：支持Android和IOS</li><li>Windows和Linux：目前只支持Android</li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><p>跨平台开发</p></li><li><p>追求极致的用户体验：<strong>热更新</strong>和<strong>热部署</strong></p></li><li><p>learn one，write everywhere</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200521130850845.png" alt="image-20200521130850845"></p></li></ol><h4 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h4><ul><li>良好的JS 功底，最好还需要懂一些IOS和Android原生开发，才能够很好驾驭<strong>中大型</strong>移动端跨平台项目<ul><li>功能适中，交互一般，不需要特别多的系统原生支持</li><li>对于部分复杂的应用，可以考虑原生+React Native混合开发</li></ul></li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">官网教程</a></p><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li>必须安装的以来有：Node（&gt;= 12）、Python（2.x）、JDK（1.8）和Android Studio</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用nrm工具切换淘宝源</span></span><br><span class="line">npx nrm use taobao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果之后需要切换回官方源可使用</span></span><br><span class="line">npx nrm use npm</span><br></pre></td></tr></table></figure><ul><li><a href="http://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line"><span class="comment"># 安装完 yarn 之后就可以用 yarn 代替 npm 了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Native&quot;&gt;&lt;a href=&quot;#React-Native&quot; class=&quot;headerlink&quot; title=&quot;React Native&quot;&gt;&lt;/a&gt;React Native&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
