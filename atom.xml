<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>图小灵</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://turing5467.github.io/"/>
  <updated>2019-10-25T06:01:06.537Z</updated>
  <id>https://turing5467.github.io/</id>
  
  <author>
    <name>turing5467</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue_响应式原理</title>
    <link href="https://turing5467.github.io/2019/10/25/js%E6%A1%86%E6%9E%B6/Vue_%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>https://turing5467.github.io/2019/10/25/js框架/Vue_深入响应式原理/</id>
    <published>2019-10-25T03:00:00.000Z</published>
    <updated>2019-10-25T06:01:06.537Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="Obejct-defineProperty"><a href="#Obejct-defineProperty" class="headerlink" title="Obejct.defineProperty"></a>Obejct.defineProperty</h3><ul><li><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty</code></a> 把这些属性全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters" target="_blank" rel="noopener">getter/setter</a>。 </p></li><li><p>当我们修改某一属性时，触发<code>setter</code>，而Vue在<code>setter</code>内部封装了触发视图层变化的代码，实现<strong>M层-&gt;V层</strong>的数据传输</p></li><li><p>当我们使用到某一属性时，触发<code>getter</code>，实时获取当前属性值，实现<strong>V层 -&gt; M层</strong>的数据传输</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/reactivity.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Obejct-defineProperty&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>基于vue的MVVM笔记(9)</title>
    <link href="https://turing5467.github.io/2019/10/25/js%E6%A1%86%E6%9E%B6/Vue_MVVM/"/>
    <id>https://turing5467.github.io/2019/10/25/js框架/Vue_MVVM/</id>
    <published>2019-10-25T02:41:43.566Z</published>
    <updated>2019-10-25T03:03:51.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571159614161&di=e15e2c671e5840d5dba7c002340824b0&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180502140243353675.png" alt="img"></p><ul><li><p>MVVM   ——    Model-View-ViewModle的缩写，MVC设计模式的改进版。</p><ul><li><p><strong>Model</strong>是我们应用中的<strong>数据模型</strong></p></li><li><p><strong>View</strong>是我们的<strong>UI层</strong></p></li><li><p>通过<strong>ViewModle</strong>，可以把我们Modle中的数据<strong>映射</strong>到View视图上，</p><p>同时，在View层修改了一些数据，也会反应<strong>更新</strong>我们的Modle。</p></li></ul></li></ul><blockquote><p>用白话讲，就是双向数据绑定</p><p>即当<strong>数据</strong>发生变化的时候，<strong>视图</strong>也就发生变化，当<strong>视图</strong>发生变化的时候，<strong>数据</strong>也会跟着同步变化。</p></blockquote><p><a href="https://www.cnblogs.com/iovec/p/7840228.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=
      
    
    </summary>
    
    
    
      <category term="Vue MVVM" scheme="https://turing5467.github.io/tags/Vue-MVVM/"/>
    
  </entry>
  
  <entry>
    <title>Vue的生产环境部署</title>
    <link href="https://turing5467.github.io/2019/10/25/js%E6%A1%86%E6%9E%B6/Vue_%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%20/"/>
    <id>https://turing5467.github.io/2019/10/25/js框架/Vue_生产环境部署 /</id>
    <published>2019-10-25T02:00:00.000Z</published>
    <updated>2019-10-25T03:36:22.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章项目基于Vue-cli构建</p></blockquote><h3 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h3><p><a href="https://cli.vuejs.org/zh/config/#%E5%85%A8%E5%B1%80-cli-%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">vue-cli-配置</a></p><ul><li>可选配置文件，与<code>package.json</code>同级</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;文章项目基于Vue-cli构建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;vue-config-js&quot;&gt;&lt;a href=&quot;#vue-config-js&quot; class=&quot;headerlink&quot; title=&quot;vue.config.js&quot;&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue风格指南(8)</title>
    <link href="https://turing5467.github.io/2019/10/24/js%E6%A1%86%E6%9E%B6/Vue_%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>https://turing5467.github.io/2019/10/24/js框架/Vue_风格指南/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-25T03:02:54.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优先级A：必要的"><a href="#优先级A：必要的" class="headerlink" title="优先级A：必要的"></a>优先级A：必要的</h3><ul><li><p><strong>组件名为多个单词</strong>，避免与未来的HTML元素冲突</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'TodoItem'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组件的 data 必须是一个函数。</strong></p></li><li><p><strong><code>props</code>尽量详细</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  status: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'syncing'</span>,</span><br><span class="line">        <span class="string">'synced'</span>,</span><br><span class="line">        <span class="string">'version-conflict'</span>,</span><br><span class="line">        <span class="string">'error'</span></span><br><span class="line">      ].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>总是用 key 配合 v-for。</strong></p></li><li><p><strong>避免<code>v-for</code>和<code>v-if</code>用在一起</strong></p></li><li><p>为组件<strong>样式</strong>设置<strong>作用域</strong></p></li></ul><h3 id="优先级B：强烈推荐"><a href="#优先级B：强烈推荐" class="headerlink" title="优先级B：强烈推荐"></a>优先级B：强烈推荐</h3><ul><li><p>组件模块化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoItem.vue</span><br></pre></td></tr></table></figure></li><li><p>单文件组件的文件名应该要么始终是<strong>单词大写开头</strong>（PascalCase），要么始终是<strong>横线连接</strong>（kebab-case）</p></li><li><p>应用<strong>特定样式</strong>和约定的<strong>基础组件</strong> (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个<strong>特定的前缀开头</strong>，比如 Base、App 或 V。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- BaseButton.vue</span><br><span class="line">|- BaseTable.vue</span><br><span class="line">|- BaseIcon.vue</span><br></pre></td></tr></table></figure></li><li><p>只应该拥有<strong>单个活跃实例</strong>的组件应该以 <strong>The 前缀</strong>命名，以示其唯一性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TheHeading.vue</span><br><span class="line">|- TheSidebar.vue</span><br></pre></td></tr></table></figure></li><li><p>和父组件紧密耦合的子组件应该<strong>以父组件名作为前缀</strong>命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoListItem.vue</span><br><span class="line">|- TodoListItemButton.vue</span><br></pre></td></tr></table></figure></li><li><p>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- SearchButtonClear.vue</span><br><span class="line">|- SearchButtonRun.vue</span><br><span class="line">|- SearchInputQuery.vue</span><br><span class="line">|- SearchInputExcludeGlob.vue</span><br></pre></td></tr></table></figure></li><li><p>在<strong>单文件组件、字符串模板和 JSX</strong> 中没有内容的组件应该是<strong>自闭合</strong>的——但在 DOM 模板里永远不要这样做。</p></li><li><p><strong>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在所有地方都适用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>JS/JSX 中的组件名应该始终是 PascalCase 的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent.vue'</span></span><br></pre></td></tr></table></figure></li><li><p><strong>完整单词的组件名</strong></p></li><li><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase</strong></p></li><li><p><strong>多个特性的元素应该分多行撰写，每个特性一行。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://vuejs.org/images/logo.png"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"Vue Logo"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p></li><li><p><strong>应该把复杂计算属性分割为尽可能多的更简单的属性。</strong></p></li><li><p><strong>非空 HTML 特性值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。</strong></p></li><li><p>指令缩写（<code>:</code> <code>@</code>  <code>#</code>）</p></li><li><p><strong>元素 (包括组件) 的特性应该有统一的顺序。</strong></p><ol><li>定义 <code>is</code></li><li>列表渲染 <code>v-for</code></li><li>条件渲染</li><li>渲染方式 <code>v-pre</code> <code>v-once</code></li><li>全局感知：<code>id</code></li><li>唯一特性：<code>ref</code> <code>key</code> </li><li>双向绑定 ：<code>v-model</code></li><li>事件：<code>@</code></li><li>内容：<code>v-html</code> <code>v-text</code></li></ol></li><li><p>单文件徐建的顶级元素顺序</p><ul><li><code>script =&gt; template =&gt; style</code></li><li><code>template =&gt; script =&gt; style</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优先级A：必要的&quot;&gt;&lt;a href=&quot;#优先级A：必要的&quot; class=&quot;headerlink&quot; title=&quot;优先级A：必要的&quot;&gt;&lt;/a&gt;优先级A：必要的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;组件名为多个单词&lt;/strong&gt;，避免与未来的HTML元
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>axios基本使用</title>
    <link href="https://turing5467.github.io/2019/10/24/js%E6%A1%86%E6%9E%B6/axios%E5%85%A5%E9%97%A8/"/>
    <id>https://turing5467.github.io/2019/10/24/js框架/axios入门/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-24T14:34:51.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><ul><li>支持node</li><li>基于promise语法,jq3.0才支持</li><li>短小精悍,jq大而全,加载较慢</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>创建请求,参数为请求的配置信息<ol><li><code>axios(config)</code> 默认发送GET请求</li><li><code>axios(url[, config])</code> 默认发送GET请求</li></ol></li><li>实例方法<ol><li><code>axios.get(url[, config])</code></li><li><code>axios.post(url[, data[, config]])</code></li><li><code>axios.request(config)</code></li><li><code>axios.delete(url[, config])</code></li><li><code>axios.head(url[, config])</code></li><li><code>axios.put(url[, data[, config]])</code></li><li><code>axios.patch(url[, data[, config]])</code></li></ol></li></ul><blockquote><p>注：data: res.config.data(用于POST请求) res.data(get)<br>config: res.config(其params 为请求参数对象)(用于GET请求)</p></blockquote><ul><li>并发<ol><li><code>axios.all(iterable)</code></li><li><code>axios.spread(callback)</code></li></ol></li></ul><ul><li>创建实例<ol><li><code>axios.create([config])</code></li></ol></li></ul><h5 id="常见传参方式"><a href="#常见传参方式" class="headerlink" title="常见传参方式"></a>常见传参方式</h5><h6 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见GET</span></span><br><span class="line">axios.get(<span class="string">'/user?id=12345&amp;name=user'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为方便全局统一 调用封装的axios</span></span><br><span class="line">axios.get(url,&#123;</span><br><span class="line">   params: &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then( <span class="function"><span class="params">response</span> =&gt;</span> &#123; <span class="comment">/*readyState=4时的回调函数*/</span> &#125;)</span><br><span class="line">    .catch( <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">/**/</span> &#125;)</span><br></pre></td></tr></table></figure><h6 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h6><ol><li><p><code>Content-type: application/json</code> 第二个参数为对象<br> <img src="./1567516788313.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.post(url,data)   /*data通过res.config.data访问*/</span><br><span class="line">.then(</span><br><span class="line">res =&gt; console.log(res.config.data)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>Content-Type: multipart/form-data;</code>第二个参数为<code>formData</code>对象<br><img src="./1567517023353.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">oBtn2.onclick = function() &#123;</span><br><span class="line">       let fd = new FormData(); </span><br><span class="line">       /*可通过res.config.data方法操作formData*/   </span><br><span class="line">       /*可通过res.data获得查询字符串响应体数据*/        </span><br><span class="line">       /*或res.request.responseText获取*/</span><br><span class="line">       fd.append(&apos;name&apos;, oUsername.value);</span><br><span class="line">       fd.append(&apos;pwd&apos;, oPassword.value);</span><br><span class="line">       axios.post(&apos;php/02_server.php&apos;, fd).then(</span><br><span class="line">           res =&gt; console.log(res)   </span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Content-Type: multipart/x-www-form-urlencoded;</code>(第二个参数为查询字符串)<br><img src="./1567518556995.png" alt="Alt text"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&apos;php/02_server.php&apos;, </span><br><span class="line">obj2str(data))  /*可通过res.config.data获得查询字符串*/</span><br><span class="line">/*可通过res.data获得响应体数据*/</span><br><span class="line">/*也可通过PHP*/</span><br><span class="line">.then(</span><br><span class="line">       res =&gt; console.log(res)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></li></ol><h5 id="请求config"><a href="#请求config" class="headerlink" title="请求config"></a>请求config</h5><ul><li><code>config属性</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  url: &apos;/user&apos;,</span><br><span class="line">  </span><br><span class="line">  //请求的方法 GET POST OPTIONS HEAD PUT DELETE TRACE CONNECT PATCH</span><br><span class="line">  method: &apos;get&apos;, // 默认是 get</span><br><span class="line"></span><br><span class="line">  // 请求根路径</span><br><span class="line">  baseURL: &apos;https://some-domain.com/api/&apos;,</span><br><span class="line"></span><br><span class="line">  // 向服务器发送前，修改&quot;请求&quot;数据</span><br><span class="line">  // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; </span><br><span class="line">  // 数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span><br><span class="line">  transformRequest: [function (data) &#123;</span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `transformResponse` 拿到数据后，且传递给 then/catch 前，允许修改&quot;响应&quot;数据</span><br><span class="line">  transformResponse: [function (data) &#123;</span><br><span class="line">    // 对 data 进行任意转换处理</span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `headers` 是即将被发送的自定义请求头</span><br><span class="line">  headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;,</span><br><span class="line"></span><br><span class="line">  // 查询字符串对象</span><br><span class="line">  // 必须是一个无格式对象或 URLSearchParams 对象</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: 12345</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 请求体 参数对象</span><br><span class="line">  // 只适用于这些请求方法 &apos;POST&apos;, &apos;PUT&apos; 和 &apos;PATCH&apos;</span><br><span class="line">  data: &#123; &#125;,</span><br><span class="line"></span><br><span class="line">  timeout: 1000,</span><br><span class="line"></span><br><span class="line">  // 表示跨域请求时是否需要使用凭证</span><br><span class="line">  withCredentials: false, // 默认</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span><br><span class="line">  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: &apos;janedoe&apos;,</span><br><span class="line">    password: &apos;s00pers3cret&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 服务器响应的数据类型，</span><br><span class="line">  //可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos;</span><br><span class="line">  responseType: &apos;json&apos;, // 默认</span><br><span class="line"></span><br><span class="line">  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span><br><span class="line">  xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default</span><br><span class="line"></span><br><span class="line">  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span><br><span class="line">  xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 默认的</span><br><span class="line"></span><br><span class="line">  // 处理上传进度事件</span><br><span class="line">  onUploadProgress: function (progressEvent) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // 处理下载进度事件</span><br><span class="line">  onDownloadProgress: function (progressEvent) &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // 响应内容的最大长度</span><br><span class="line">  maxContentLength: 2000,</span><br><span class="line"></span><br><span class="line">  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject。</span><br><span class="line">  // 返回 `true`，promise 将被 resolve; 否则，promise 将被 rejecte</span><br><span class="line">  validateStatus: function (status) &#123;</span><br><span class="line">    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 定义在 node.js 中 follow 的最大重定向数目</span><br><span class="line">  maxRedirects: 5, // 默认的</span><br><span class="line"></span><br><span class="line">  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span><br><span class="line">  // `keepAlive` 默认没有启用</span><br><span class="line">  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),</span><br><span class="line">  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),</span><br><span class="line"></span><br><span class="line">  // &apos;proxy&apos; 定义代理服务器的主机名称和端口</span><br><span class="line">  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class="line">  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: &apos;127.0.0.1&apos;,</span><br><span class="line">    port: 9000,</span><br><span class="line">    auth: : &#123;</span><br><span class="line">      username: &apos;mikeymike&apos;,</span><br><span class="line">      password: &apos;rapunz3l&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `cancelToken` 指定用于取消请求的 cancel token</span><br><span class="line">  cancelToken: new CancelToken(function (cancel) &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h5><ul><li><code>then</code>方法的回调函数の参数<code>response</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // `config` 是为请求提供的配置信息</span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // 响应体</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  status: 200,   //响应行status</span><br><span class="line">  statusText: &apos;OK&apos;,  //响应行statusText</span><br><span class="line"></span><br><span class="line">  // `headers` 服务器响应头</span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  //XMLHttpRequest 对象</span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><ul><li><p>全局修改axios默认配置<br>  <code>axios.defaults.baseURL = &quot;...&quot;;</code></p></li><li><p>实例默认配置：适用于一个项目中使用到了多个服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建axios实例 时修改配置</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例发送请求</span></span><br><span class="line">instance(&#123;</span><br><span class="line">    url:<span class="string">'/home'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例创建之后修改配置</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure></li><li><p>配置优先级<br>  <code>request config</code> &gt; <code>instance.defaults</code> &gt; <code>系统默认</code></p></li></ul><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul><li><p>请求拦截器（在发送请求前调用）<br>  <code>axios.interceptors.request.use(onFulfilled,onReject)</code></p><ul><li><code>onFulfilled</code> 参数为<code>config</code><ul><li>如果请求是成功的，那么拦截之后一定要放行：将config返回<code>return config</code></li></ul></li><li><code>onReject</code>参数为<code>err</code></li></ul></li><li><p>响应拦截器<br>  <code>axios.interceptors.response.use(/*同上*/)</code></p><ul><li><p><code>onFulfilled</code> 参数为<code>result</code></p></li><li><p>如果响应是成功的，那么拦截之后一定要放行：将<code>result</code>返回<code>return result</code></p><ul><li>也可以直接<code>return result.data</code>，那么在请求成功的回调函数中拿到的就是data</li></ul></li></ul></li><li><p>移除拦截器<br>  <code>axios.interceptors.request.eject(myInterceptor);</code></p></li><li><p>应用：</p><ul><li>请求未返回前，显示请求/加载图表</li><li>某些网络请求，必须携带一些特殊的信息</li></ul></li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;user/12345&apos;)</span><br><span class="line">    .catch(function(error)&#123;</span><br><span class="line">        if(error.response)&#123;</span><br><span class="line">            //存在请求，但是服务器的返回一个状态码</span><br><span class="line">            //他们是在2xx之外</span><br><span class="line">            console.log(error.response.data);</span><br><span class="line">            console.log(error.response.status);</span><br><span class="line">            console.log(error.response.headers);</span><br><span class="line">        &#125;else if(error.request)&#123;</span><br><span class="line">          //如果是请求时的错误，且没有收到相应</span><br><span class="line">          //`error.request`是一个浏览器的XMLHttpRequest实例，或者node.js的 ClientRequest实例。</span><br><span class="line">          console.log(error.request)</span><br><span class="line">        &#125; </span><br><span class="line">        else&#123;</span><br><span class="line">            //一些错误是在设置请求时触发的</span><br><span class="line">            console.log(&apos;Error&apos;,error.message);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(error.config);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>可以使用validStatus设置选项自定义HTTP状态码的错误范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;user/12345&apos;,&#123;</span><br><span class="line">    validateStatus:function(status)&#123;</span><br><span class="line">        return status &lt; 500;//当返回码小于等于500时视为错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h5><ol><li><p>通过<code>CancelToken.source</code>工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(function(thrown) &#123;</span><br><span class="line">  if (axios.isCancel(thrown)) &#123;</span><br><span class="line">    console.log(&apos;Request canceled&apos;, thrown.message);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // handle error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// cancel the request (the message parameter is optional)</span><br><span class="line">source.cancel(&apos;Operation canceled by the user.&apos;);</span><br></pre></td></tr></table></figure></li><li><p>通过传递一个执行器函数给CancelToken构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var cancel;</span><br><span class="line"></span><br><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">  cancelToken: new CancelToken(function executor(c) &#123;</span><br><span class="line">    // An executor function receives a cancel function as a parameter</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// cancel the request</span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure></li></ol><h3 id="vue-axios实践"><a href="#vue-axios实践" class="headerlink" title="vue-axios实践"></a>vue-axios实践</h3><ul><li><p>如果项目中有许多文件使用到<code>axios</code>，且直接引用该模块，</p><p>这样会导致 项目与axios的耦合性太高</p><p>一旦该模块不再使用，就需要一个一个改文件，后期项目维护难度大，</p></li><li><p>因此我们需要将该<strong>模块封装</strong>成一个单独的文件</p></li></ul><blockquote><p>这一原则对大部分第三方库都有效</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        baseURL: <span class="string">'xx'</span>,</span><br><span class="line">        timeout: <span class="number">5000</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//请求本身返回的是一个Promise，方便异步操作</span></span><br><span class="line">    <span class="keyword">return</span> instance(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'./request.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用封装好的request</span></span><br><span class="line">request(&#123;<span class="attr">url</span>:<span class="string">'/home'</span>&#125;).then().catch();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Axios&quot;&gt;&lt;a href=&quot;#Axios&quot; class=&quot;headerlink&quot; title=&quot;Axios&quot;&gt;&lt;/a&gt;Axios&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;支持node&lt;/li&gt;
&lt;li&gt;基于promise语法,jq3.0才支持&lt;/li&gt;
&lt;li&gt;短小精悍,j
      
    
    </summary>
    
    
    
      <category term="Vue axios" scheme="https://turing5467.github.io/tags/Vue-axios/"/>
    
  </entry>
  
  <entry>
    <title>Vuex(7)</title>
    <link href="https://turing5467.github.io/2019/10/23/js%E6%A1%86%E6%9E%B6/Vue_6_Vuex/"/>
    <id>https://turing5467.github.io/2019/10/23/js框架/Vue_6_Vuex/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-25T03:02:38.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</li><li>它采用<strong>集中式</strong>存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li><li>实现原理：<strong>浅拷贝</strong></li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>每一个 Vuex 应用的核心就是 <strong>store</strong>（仓库）。</li><li><strong>store</strong>基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。<ol><li>Vuex 的状态存储是<strong>响应式</strong>的。当 Vue 组件从 store 中读取状态的时候，若状态发生变化，那么相应的组件也会得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue-cli开发</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line">Vue.use(Vuex);  <span class="comment">//调用插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment(state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>核心概念</p><p><img src="http://img.souche.com/20161214/png/750205ca124c5065c6ef47c5913221a3.png" alt="vuex"></p></li></ul><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h3><ul><li>核心：<code>cpmputed</code>来返回某个状态（不可以是data，因为是响应式的）</li></ul><ul><li><strong>根实例</strong>中注册 <code>store</code> 选项，该 <code>store</code>实例会注入到根组件下的所有<strong>子组件</strong>中，</li><li><strong>子组件</strong>能通过 <code>this.$store.state</code> 访问到<code>store</code>中的状态。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h3><ul><li><p>使用前需要导入<code>import {mapState} from &#39;vuex&#39;</code> </p></li><li><p><code>mapState(Array | Object)</code>：辅助生成计算属性，返回值：一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重命名 等同于`countAlias: state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果计算属性名称与state子节点名称相同时，可以给mapState传递一个字符串数组，如<code>mapState([&#39;count&#39;,&#39;offset&#39;])</code></p></li><li><p>与局部计算属性混合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><ul><li><p><strong>getter</strong>：可以被认为是<code>store</code>的<strong>计算属性</strong>，用来对<code>store</code>中的<code>state</code>进行进一步计算</p></li><li><p><code>getter</code>函数的参数：</p><ul><li><code>state</code> 当前模块的所有状态</li><li><code>getters</code>当前模块的所有<code>getter</code></li></ul></li><li><p>获取<code>getter</code>：<code>this.$store.getters.getterName</code></p></li><li><p><code>getter</code><strong>传参</strong>：让<code>getter</code>返回一个函数</p><p>​    然后在调用时传递参数</p></li><li><p><code>mapGetters</code>：同<code>mapState</code></p></li></ul><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><ul><li><p><strong>mutation</strong>：改变store中的<strong>状态</strong></p></li><li><p>类似于事件，有事件类型(type)和回调函数(handler)</p><ul><li><code>handler</code>的第一个参数为<code>state</code>，剩余不固定</li></ul></li><li><p>提交mutation：<code>this.$store.commit(&#39;type&#39;, payload?)</code></p><ul><li>第一个参数为mutation名</li></ul></li><li><p><strong>载荷</strong>：mutation的第二个参数，大多数情况下应该是一个对象 </p></li><li><p>对象风格的提交方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入一个包含type属性的对象</span></span><br><span class="line">store.commit(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>, <span class="attr">amount</span>: <span class="number">10</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>mapMutations(Array | Object)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// this.increment() =&gt; this.$store.commit('increment')</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//支持载荷：</span></span><br><span class="line">      <span class="string">'add'</span>, <span class="comment">// this.add(amount)` =&gt; this.$store.commit('add', amount)</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">//add: 'increment' // 别名</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>通常情况下，Vuex要求我们mutation中的方法必须是<strong>同步</strong>的，</p><ul><li><p>这是因为当我们使用devtools时，devtools可以帮助我们捕捉到mutation的快照</p></li><li><p>而如果是异步操作，那么devtools将无法跟踪到state发生的变化</p></li></ul></li></ul><blockquote><p>其实mutation是可有可无的，通过<code>action</code>就可以完成同步、异步操作</p></blockquote><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ul><li><p>Action 类似于 mutation，不同在于</p><ol><li><p>Action 提交的是 <strong>mutation</strong>，而不是直接变更<strong>state</strong>。</p></li><li><p>Action 可以包含任意<strong>异步</strong>操作。</p></li></ol></li><li><p>Action 函数<strong>参数</strong>：一个与 <code>store</code>实例具有相同方法和属性的 <code>context</code>对象</p></li><li><p>分发action：<code>store.dispatch(&#39;action&#39;)</code></p><ul><li><p>和mutation一样支持<strong>载荷</strong>和<strong>对象方式分发</strong></p><ul><li>载荷一般是一个对象，对象中可以有函数，但不够优雅</li></ul></li><li><p><code>dispatch</code>可以处理action中函数返回的<code>Promise</code>，</p><p>并且  <code>dispatch</code>返回的也是一个<code>Promise</code>，利用这点可以处理复杂的异步流程</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">//参数解构简化代码！！</span></span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="comment">//分发另一个action</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>async/await</code>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>mapActions</code> 同上</p></li></ul><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul><li>将store分割成模块，每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</li><li>对于模块内部的 <strong>mutation</strong> ，接收的第一个参数是模块的<strong>局部</strong>状态对象。</li><li>对于模块内部的 <strong>action</strong>，第一个参数为与 store 实例具有相同方法和属性的 <strong>context</strong> 对象<ul><li>局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code></li><li>局部getter：  <code>getters</code>，根节点getter： <code>rootGetters</code></li></ul></li><li>对于模块内部的 <strong>getter</strong>，参数1：局部<code>state</code> ，参数2：<code>getters</code>，参数3：<code>rootState</code>，参数4：<code>rootGetters</code></li></ul><ul><li><p>模块内部的<strong>state</strong>通过<code>$store.state.a.xx</code></p></li><li><p>模块内部的 <strong>action、mutation 和 getter</strong> 默认是注册在全局命名空间的</p><ul><li>可以通过添加 <code>namespaced: true</code> 的方式使其成为带<strong>命名空间</strong>的模块。<ul><li>getter：<code>getters[a/xxgetter]</code></li><li>action：<code>dispatch(&#39;a/xxAction&#39;)</code></li><li>mutation：<code>commit(&#39;a/xxMutation&#39;)</code></li></ul></li></ul></li><li><p>嵌套模块会继承父模块的<strong>命名空间</strong></p></li><li><p>对于各辅助函数，如<code>mapState</code>，可以将模块的命名空间字符串作为第一个参数传给对应函数，这样所有绑定都会自动将该模块作为上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.b</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'some/nested/module/foo'</span>, <span class="comment">// -&gt; this['some/nested/module/foo']()</span></span><br><span class="line">    <span class="string">'some/nested/module/bar'</span> <span class="comment">// -&gt; this['some/nested/module/bar']()</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'some/nested/module'</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">'some/nested/module'</span>, [<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><p>适用：<strong>中大型单页应用</strong></p></li><li><p>不适用：小型简单应用，更适合用简单的<strong>store模式</strong></p></li></ul><h3 id="一个简单的store模式"><a href="#一个简单的store模式" class="headerlink" title="一个简单的store模式"></a>一个简单的store模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = &#123;</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    message: <span class="string">'Hello!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setMessageAction (newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.debug) <span class="built_in">console</span>.log(<span class="string">'setMessageAction triggered with'</span>, newValue)</span><br><span class="line">    <span class="keyword">this</span>.state.message = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  clearMessageAction () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.debug) <span class="built_in">console</span>.log(<span class="string">'clearMessageAction triggered'</span>)</span><br><span class="line">    <span class="keyword">this</span>.state.message = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API参考"><a href="#API参考" class="headerlink" title="API参考"></a>API参考</h2><h3 id="Vuex-Store构造器"><a href="#Vuex-Store构造器" class="headerlink" title="Vuex.Store构造器"></a>Vuex.Store构造器</h3><ul><li><code>state</code> <code>mutations</code> <code>actions</code> <code>getters</code> <code>modules</code></li><li><code>plugins</code></li></ul><h3 id="Vuex-Store实例属性"><a href="#Vuex-Store实例属性" class="headerlink" title="Vuex.Store实例属性"></a>Vuex.Store实例属性</h3><ul><li><code>state</code></li><li><code>getters</code></li></ul><h3 id="Vuex-Store实例方法"><a href="#Vuex-Store实例方法" class="headerlink" title="Vuex.Store实例方法"></a>Vuex.Store实例方法</h3><ul><li><p><code>commit</code></p></li><li><p><code>dispatch</code></p></li><li><p><code>subscribe(handler)</code> 订阅store的mutation，会在每个<code>mutation</code>完成后调用，通常用于插件</p><ul><li>接收 <strong>mutation</strong> 和经过 mutation 后的 <strong>state</strong> 作为参数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.type)</span><br><span class="line">  <span class="built_in">console</span>.log(mutation.payload)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>要停止订阅，调用此方法返回的函数即可停止订阅。</li></ul></li><li><p><code>subscribeAction(handler)</code> 通常用于插件</p><ul><li>接收 <strong>action</strong> 描述和当前的 store 的 <strong>state</strong> 这两个参数    </li><li>从 3.1.0 起，<code>subscribeAction({before, after})</code> 也可以指定订阅处理函数的被调用时机应该在一个 action 分发<em>之前<em>还是</em>之后</em> (默认行为是<em>之前</em>)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Token</title>
    <link href="https://turing5467.github.io/2019/10/23/js%E6%A1%86%E6%9E%B6/%E7%99%BB%E5%BD%95%E4%BB%A4%E7%89%8CToken/"/>
    <id>https://turing5467.github.io/2019/10/23/js框架/登录令牌Token/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-23T06:47:00.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><ul><li><p>登录令牌.利用 token 值来判断用户的登录状态.类似于 MD5 加密之后的长字符串.</p></li><li><p>一般的 app ,token值的失效时间都在 1 年以上.</p></li><li><p>银行类 app /支付类 app : token值失效时间 15 分钟左右.</p></li><li><ul><li>一旦用户信息改变(密码改变),会在服务器生成新的 token 值,原来的 token值就会失效.需要再次输入账号和密码,以得到生成的新的 token 值.</li><li>唯一性判断: 每次登录,都会生成一个新的token值.原来的 token 值就会失效.利用时间来判断登录的差异性.</li></ul></li></ul><h2 id="登录验证案例"><a href="#登录验证案例" class="headerlink" title="登录验证案例"></a>登录验证案例</h2><ol><li><p>第一次登录的时候，前端调后端的<strong>登陆</strong>接口，发送用户名和密码</p></li><li><p>后端收到请求，验证用户名和密码，<strong>验证</strong>成功，就给前端返回一个token</p></li><li><p>前端拿到token，将token<strong>存储</strong>到<code>localStorage</code>和<code>vuex</code>中，并跳转路由页面</p></li><li><p>前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面：<code>beforeEach</code></p></li><li><p>每次调后端接口，都要在<strong>请求头</strong>中加<code>token</code></p></li><li><p>后端判断请求头中有无token</p><ul><li>有token，就拿到token并验证token，验证成功就返回数据</li><li>验证失败或请求头中没有token也返回401</li></ul></li><li><p>如果前端拿到状态码为401，就清除token信息并跳转到登录页面</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = localStorage.token ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span>(to.path === <span class="string">'/login'</span> || to.path === <span class="string">'/register'</span>) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isLogin ? next() : next(<span class="string">'/login'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><ul><li>令牌：同于保存登录信息</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">    user:<span class="string">'tr'</span>,</span><br><span class="line">    pwd:<span class="string">'tr5467'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> token = Buffer.from(<span class="built_in">JSON</span>.stringify(info)).toString(<span class="string">'base64'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'fdgfsd'</span>;</span><br><span class="line"><span class="keyword">const</span> token = Buffer.from(key, <span class="string">'base64'</span>).toString(<span class="string">'utf8'</span>);<span class="comment">//string类型</span></span><br></pre></td></tr></table></figure><h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Token&quot;&gt;&lt;a href=&quot;#Token&quot; class=&quot;headerlink&quot; title=&quot;Token&quot;&gt;&lt;/a&gt;Token&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登录令牌.利用 token 值来判断用户的登录状态.类似于 MD5 加密之后的长字符串.&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>node--crypto</title>
    <link href="https://turing5467.github.io/2019/10/23/node/node_crypto%E6%A8%A1%E5%9D%97/"/>
    <id>https://turing5467.github.io/2019/10/23/node/node_crypto模块/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-25T03:05:18.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><ul><li>令牌：同于保存登录信息</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">    user:<span class="string">'tr'</span>,</span><br><span class="line">    pwd:<span class="string">'tr5467'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> token = Buffer.from(<span class="built_in">JSON</span>.stringify(info)).toString(<span class="string">'base64'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'fdgfsd'</span>;</span><br><span class="line"><span class="keyword">const</span> token = Buffer.from(key, <span class="string">'base64'</span>).toString(<span class="string">'utf8'</span>);<span class="comment">//string类型</span></span><br></pre></td></tr></table></figure><ul><li>由于cookie存密码非常不安全，所以：第一次发密码到后端，如果校验正确，后端会将密码处理成一个<strong>令牌</strong>，我们只需要将令牌保存到cookie</li></ul><blockquote><p>如果拿到令牌，我们不需要账号、密码也可以以该用户身份进入</p></blockquote><h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;buffer&quot;&gt;&lt;a href=&quot;#buffer&quot; class=&quot;headerlink&quot; title=&quot;buffer&quot;&gt;&lt;/a&gt;buffer&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;令牌：同于保存登录信息&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
    
      <category term="node" scheme="https://turing5467.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Vue_Router(6)</title>
    <link href="https://turing5467.github.io/2019/10/21/js%E6%A1%86%E6%9E%B6/Vue_5_Router/"/>
    <id>https://turing5467.github.io/2019/10/21/js框架/Vue_5_Router/</id>
    <published>2019-10-20T16:00:00.000Z</published>
    <updated>2019-10-25T03:02:32.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端路由发展"><a href="#前端路由发展" class="headerlink" title="前端路由发展"></a>前端路由发展</h2><ul><li>后端路由阶段：后端处理URL和页面之间的映射关系</li><li>前后端分离阶段<ul><li>后端只负责提供数据，前端通过ajax请求数据，并且可以通过js将数据渲染到页面中</li><li>优点：前后端责任清晰，后端专注数据，前端专注交互和可视化</li></ul></li><li><strong>单页面富应用阶段</strong> SPA（Single Page  Application）<ul><li>在前后端分离的基础上加了一层前端路由</li><li>单页面，根据不同的 <strong>url</strong> 地址展示不同的内容和页面。</li><li>前端路由：前端处理URL和页面之间的映射关系（核心：<strong>改变URL，但是页面不进行整体的刷新</strong>）<ul><li>优点：体验好，不需要每次从服务器获取全部，快速展现给用户。</li><li>缺点：不利于SEO；使用浏览器的前进，后退键的时候会重新发送请求，没有合理的利用缓存；单页面无法记住之前滚动的位置，无法在前进和后退的时候记住滚动的位置。</li></ul></li></ul></li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li><p>路由表本质上就是一个映射表，决定了数据包的指向</p></li><li><p>前端路由の两种模式实现：</p><ol><li><strong>hash模式</strong>：兼容性好、但url不美观（带有#）<ul><li>通过<code>location.hash = &#39;/&#39;</code> 修改url的<code>hash</code>值</li><li>通过<code>hashchange</code>事件来监听hash、值得变化，从而进行页面跳转/渲染</li></ul></li><li>h5的<strong>history模式</strong>：url看上去更美观<ul><li>通过<code>history.pushState()</code>或<code>replaceState()</code>来操作url</li><li>通过<code>popstate</code>事件来监听url的变化</li></ul></li></ol></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="vue-router-起步"><a href="#vue-router-起步" class="headerlink" title="vue-router 起步"></a>vue-router 起步</h3><ul><li>Vuejs官方の路由插件，和vuejs深度集成，适合构建单页面应用</li><li>路由用于设定访问路径，将路径和组件映射起来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置路由组件之间的映射关系(path =&gt; component)</span></span><br><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">    path:<span class="string">'/home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">&#125;</span><br><span class="line">]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes,</span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js 主入口文件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./main.js'</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;router-link to="/home"&gt;&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">&lt;router-view /&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;router-link&gt;</code> 内置组件，最终会被渲染为a标签</p><ul><li><p><code>to</code>  <code>&lt;String&gt; | &lt;Location&gt;</code></p><ul><li><code>path/fullPath/query/params</code><a href="https://router.vuejs.org/zh/api/#路由对象属性" target="_blank" rel="noopener">路由对象属性</a></li><li><code>name</code>命名路由</li></ul></li><li><p><code>tag</code>规定最终被渲染成什么标签</p></li><li><p><code>replace</code> 默认改变url使用的是<code>pushState</code>，会保留历史记录，</p></li><li><p><code>append</code> 设置 <code>append</code> 属性后，则总是在当前路径前添加基路径。</p></li><li><p><code>active-class</code>修改处于<strong>激活</strong>状态时的类名：默认<code>router-link-active</code></p><p>默认值可以通过路由的构造选项 <code>linkActiveClass</code> 来全局配置。</p></li></ul><blockquote><p>注意：在router-link上定义的<code>click</code>事件是不起作用的！</p></blockquote></li><li><p><code>&lt;router-view&gt;</code> 根据当前路径，动态渲染成不同的组件</p><ul><li><code>name</code>命名视图</li></ul></li><li><p>路由切换时，切换的是<code>router-view</code>挂载的组件，其他内容不发生变化</p></li><li><p><strong>重定向</strong>：设置缺省值(默认显示的组件)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">''</span>,</span><br><span class="line">redirect: <span class="string">'/home'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Router构建选项"><a href="#Router构建选项" class="headerlink" title="Router构建选项"></a>Router构建选项</h3><ul><li><code>routes&lt;Array&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RouteConfig</span> </span>= &#123;</span><br><span class="line">  path: string,</span><br><span class="line">  component?: Component,</span><br><span class="line">  name?: string, <span class="comment">// 命名路由</span></span><br><span class="line">  components?: &#123; [name: string]: Component &#125;, <span class="comment">// 命名视图组件</span></span><br><span class="line">  redirect?: string | Location | Function,<span class="comment">//重定向</span></span><br><span class="line">  props?: <span class="keyword">boolean</span> | Object | Function,</span><br><span class="line">  alias?: string | Array&lt;string&gt;,<span class="comment">//别名：访问别名(url会改变)相当于访问当前路由</span></span><br><span class="line">  children?: Array&lt;RouteConfig&gt;, <span class="comment">// 嵌套路由</span></span><br><span class="line">  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; <span class="keyword">void</span>,<span class="comment">//导航守卫</span></span><br><span class="line">  meta?: any,<span class="comment">//元数据信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.6.0+</span></span><br><span class="line">  caseSensitive?: <span class="keyword">boolean</span>, <span class="comment">// 匹配规则是否大小写敏感？(默认值：false)</span></span><br><span class="line">  pathToRegexpOptions?: Object <span class="comment">// 编译正则的选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mode</code>    <code>hash | history | abstract</code> 默认模式为hash，带有#，不好看</li><li><code>base</code>基路径</li><li><code>linkActiveClass</code>  |  <code>linkExactActiveClass</code></li><li><code>scrollBehavior(to, from, savedPosition)</code></li><li><code>fallback</code>当浏览器不支持 <code>pushState</code> 是否回退到 <code>hash</code> 模式。默认值为 <code>true</code>。</li></ul><h3 id="Router实例属性"><a href="#Router实例属性" class="headerlink" title="Router实例属性"></a>Router实例属性</h3><ul><li>实例属性：即<code>this.$router</code>或<code>router</code>身上的属性</li><li><code>app</code> router的Vue根实例</li><li><code>mode</code></li><li><code>currentRoute</code> 当前路由对应的<strong>路由信息对象</strong>(<code>Route</code>)</li><li><code>beforeEach()</code> <code>afterEach()</code>  <code>beforeResolve()</code></li><li><code>push(location, onComplete?, onAbort?)</code> 返回一个<code>Promise</code></li><li><code>replace(location, onComplete?, onAbort?)</code>  返回一个<code>Promise</code> 不会保留历史记录</li><li><code>go(n)</code> 前进/后退n步，记录不够用则报错</li><li><code>back()</code>  <code>forward()</code></li><li><code>getMatchedComponents(location?)</code> 返回目标位置或是当前路由匹配的组件数组 (是数组的定义/构造类，不是实例)。通常在服务端渲染的数据预加载时使用。</li><li><a href="https://router.vuejs.org/zh/api/#router-resolve" target="_blank" rel="noopener">router.resolve</a></li><li><a href="https://router.vuejs.org/zh/api/#router-addroutes" target="_blank" rel="noopener">router.addRoutes</a></li><li><code>onReady(callback, errorCallback?)</code> 在路由完成初始导航时调用</li><li><code>onError(callback)</code></li></ul><h3 id="Route对象"><a href="#Route对象" class="headerlink" title="Route对象"></a>Route对象</h3><ul><li><p>一个<strong>路由对象 (route object)</strong> 表示<strong>当前</strong>激活的路由的状态信息，包含了当前 <strong>URL</strong> 解析得到的信息，还有 URL 匹配到的<strong>路由记录</strong> 。</p></li><li><p>出现在</p><ul><li><code>this.$route</code></li><li><code>router.match(location)</code> 的返回值</li><li><code>beforeEach(to, from, next)</code> 中的<code>to</code>和<code>from</code></li><li><code>scrollBehavior(to, from, savedPosition)</code> 方法的参数</li></ul></li><li><p><code>path</code></p></li><li><p><code>params</code>  <code>query</code></p></li><li><p><code>hash</code></p></li><li><p><code>fullPath</code></p></li><li><p><code>matched</code> 数组，包含一个路由匹配到的所有<strong>路由记录</strong></p></li><li><p><code>name</code> 当前路由的名称，如果有的话。</p></li><li><p><code>redirectedForm</code>重定向来源的路由的名字，如果有的话</p></li></ul><h3 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h3><ul><li>将不同路由对应的组件分割成不同的代码块，只有当路由被访问的时候才加载对应组件，提高加载效率<ul><li><code>bundle</code> 所有业务逻辑代码</li><li><code>manifest</code> 模块化的底层支撑</li><li><code>vendor</code>第三方代码库</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/home'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span> <span class="string">'../components/Home'</span></span><br><span class="line">        <span class="comment">//vue-cli中 () =&gt; import('../components/Home')</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>打包后每一个懒加载会对应一个js文件</li></ul><h3 id="路由的嵌套"><a href="#路由的嵌套" class="headerlink" title="路由的嵌套"></a>路由的嵌套</h3><ol><li>创建对应的<strong>子组件</strong>，并在路由映射中配置对应的子路由</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">path: <span class="string">'news'</span>, <span class="comment">//这里不需要加/</span></span><br><span class="line">            component: </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>父组件</strong>内部使用<code>&lt;router-view&gt;</code>标签来渲染子组件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//parent.vue</span><br><span class="line">//to后面接完整路径</span><br><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;新闻&lt;/router-link&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><ul><li><p>声明式导航：<code>&lt;router-link to=&quot;/&quot;&gt;&lt;/router-link&gt;</code></p></li><li><p>编程式导航<code>this.$router.push(String | Object)</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    path: <span class="string">'/profile'</span>,<span class="comment">//name</span></span><br><span class="line">    query: &#123;<span class="comment">//params</span></span><br><span class="line">        name: <span class="string">'turing'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>如果提供<code>path</code>，则<code>params</code>会被忽略</p><p>一般来说：<strong><code>name</code>配对<code>params</code>，<code>path</code>配对<code>query</code></strong></p></blockquote><ol><li><p>动态路由（路由参数）：</p><ul><li><p>配置路由：<code>path: &#39;/user/:uid&#39;</code></p></li><li><p>动态传参：<code>:to=&quot;&#39;/user/&#39; + userId&quot;</code></p></li><li><p>获取参数：<code>this.$route.params.uid</code>或<code></code></p></li></ul></li></ol><blockquote><p>当使用路由参数时，原来的组件实例会被复用。</p><p>因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。</p><p><strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p><p>想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) <code>$route</code> 对象或者使用<code>beforeRouteUpdate</code>导航守卫</p></blockquote>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>查询字符串<code>query</code></p><ul><li><p>配置路由：普通配置</p></li><li><p>传递参数 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&#123;path:</span> '/<span class="attr">home</span>', <span class="attr">query:</span> &#123;<span class="attr">name:</span>'<span class="attr">turing</span>'&#125;&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>获取参数：<code>this.$route.query.xx</code></li></ul><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><ul><li><p>需求考虑：由于SPA页面只有一个固定的HTML，切换页面时，标题并不会改变，那么如何实现切换页面时改变标题呢</p></li><li><p>监听路由的跳转过程</p></li><li><p><strong>全局前置守卫</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.ts</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter([</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">'/home'</span>,</span><br><span class="line">component: Home,</span><br><span class="line">        <span class="comment">//定义元数据信息(描述数据的数据)</span></span><br><span class="line">meta: &#123;</span><br><span class="line">title: <span class="string">'首页'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//拿到title =&gt; to.meta.title ||to.matched[0].meta.title(适用于嵌套路由)</span></span><br><span class="line"><span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title;</span><br><span class="line">next();<span class="comment">//必须主动调用next()，否则钩子不会被主动resolve</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>beforeEach(to&lt;Router&gt;, from&lt;Router&gt;, next&lt;Function&gt;)</code> 全局前置守卫</p><ul><li><code>to</code>即将要进入的路由对象 <a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">Router API</a></li><li><code>next(false)</code>中断导航,地址重置到<code>from</code>对应的地址</li><li><code>next(&#39;/&#39;)</code>或<code>next({path:&#39;/&#39;})</code> 跳转到一个不同の地址，选项同</li></ul></li><li><p><code>beforeResolve(to, from, next)</code> 全局解析守卫</p></li><li><p><code>afterEach(to&lt;Router&gt;, from&lt;Router&gt;)</code> 后置钩子</p></li><li><p><strong>路由独享守卫</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/foo'</span>,</span><br><span class="line">    component: Foo,</span><br><span class="line">    <span class="comment">//在路由配置上直接定义beforeEnter守卫</span></span><br><span class="line">    beforeEnter(to, <span class="keyword">from</span>, next)&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组件内的守卫</strong>：定义在组件内部</p><ol><li><code>beforeRouteEnter(to, from, next)</code> 无法访问<code>this</code>，因为此时组件还未被创建,但它是支持给<code>next</code>传递回调的唯一守卫，参数为<code>vm</code></li><li><code>beforeRouteUpdate(to, from, next)</code>当前路由改变，但是组件被服用时调用<ul><li>如对于路径<code>/foo/:id</code>，在<code>/foo/1</code>和<code>/foo/2</code>之间跳转的时候</li></ul></li><li><code>beforeRouteLeave(to, from, next)</code> 可以访问<code>this</code></li></ol></li></ul><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><ul><li>背景：想同时展示多个<code>router-view</code>视图，比如主内容和侧导航</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="keyword">default</span>: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><a href="https://jsfiddle.net/posva/6du90epg/" target="_blank" rel="noopener">官方演示链接</a></p><h3 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h3><ul><li><p>只有页面刷新/后退时 保持页面原先滚动位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">  <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> savedPosition</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p><a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">官方文档</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">参考链接</a></h3><ul><li>正则路由匹配 <a href="https://github.com/pillarjs/path-to-regexp/tree/v1.7.0#parameters" target="_blank" rel="noopener">regexp</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端路由发展&quot;&gt;&lt;a href=&quot;#前端路由发展&quot; class=&quot;headerlink&quot; title=&quot;前端路由发展&quot;&gt;&lt;/a&gt;前端路由发展&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;后端路由阶段：后端处理URL和页面之间的映射关系&lt;/li&gt;
&lt;li&gt;前后端分离阶段&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue_单文件组件及Vue-cli(5)</title>
    <link href="https://turing5467.github.io/2019/10/21/js%E6%A1%86%E6%9E%B6/Vue_4_%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/"/>
    <id>https://turing5467.github.io/2019/10/21/js框架/Vue_4_单文件组件/</id>
    <published>2019-10-20T16:00:00.000Z</published>
    <updated>2019-10-25T03:02:25.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><ul><li><p>在很多 Vue 项目中，我们使用 <code>Vue.component</code> 来定义全局组件，紧接着用 <code>new Vue({ el: &#39;#container &#39;})</code> 在每个页面内指定一个容器元素。</p></li><li><p>这种方式在很多中小规模的项目中运作的很好，在这些项目里 JavaScript 只被用来加强特定的视图。但当在更复杂的项目中，或者你的前端完全由 JavaScript 驱动的时候，下面这些缺点将变得非常明显：</p><ul><li><strong>全局定义 (Global definitions)</strong> 强制要求每个 component 中的命名不得重复</li><li><strong>字符串模板 (String templates)</strong> html与js混在一起，缺乏语法高亮，格式丑陋</li><li>难以实现<strong>局部样式</strong></li><li>难以使用<strong>预编译</strong>语言</li></ul></li><li><p>文件扩展名为 <code>.vue</code> 的 <strong>single-file components(单文件组件)</strong> 为以上所有问题提供了解决方法，并且还可以使用 <code>webpack</code>或 <code>Browserify</code>等构建工具。</p></li></ul><h3 id="vue模板"><a href="#vue模板" class="headerlink" title=".vue模板"></a>.vue模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;p&gt;Hello Vue&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//scoped表示局部样式</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    p &#123;</span><br><span class="line">        color: #194;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><p>好处</p><ul><li>语法高亮</li><li>模块化</li><li>组件作用域的CSS</li></ul></li><li><p>需要安装<code>vue-loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'./vue-loader/lib/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//rules...</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">            loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [<span class="keyword">new</span> VueLoaderPlugin()]</span><br></pre></td></tr></table></figure></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><p>引入<code>.vue</code>，<code>import trHeader from &#39;./xx.vue&#39;</code></p></li><li><p>注册组件 ：让组件拥有活动范围和不同的名字（不注册的组件无法使用）</p><ol><li><p>全局：<code>Vue.component(&#39;tr-header&#39;,trHeader)</code></p></li><li><p>局部：<code>components: { trHeader }</code></p></li></ol></li><li><p>将<code>index.js</code>中的<code>template</code>改为<code>render</code>函数，且直接引入<code>vue</code>即可</p></li></ul><h3 id="Vue-Cli-4-0"><a href="#Vue-Cli-4-0" class="headerlink" title="Vue-Cli 4.0"></a>Vue-Cli 4.0</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装</span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line">//创建项目</span><br><span class="line">vue create [项目目录]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//启动（编译和热更新）</span><br><span class="line">npm serve</span><br><span class="line"></span><br><span class="line">//打开ui界面，可管理vue项目</span><br><span class="line">vue ui</span><br><span class="line"></span><br><span class="line">//编译并压缩</span><br><span class="line">npm build</span><br></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在很多 Vue 项目中，我们使用 &lt;code&gt;Vue.component&lt;/code&gt; 来定义全局组件，紧接着用 &lt;cod
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue_生命周期(4)</title>
    <link href="https://turing5467.github.io/2019/10/18/js%E6%A1%86%E6%9E%B6/Vue_3_%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://turing5467.github.io/2019/10/18/js框架/Vue_3_生命周期/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2019-10-25T04:04:34.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h3><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue å®ä¾çå½å¨æ"></p><ul><li><p>三大阶段</p><ol><li>初始化：<code>mounted</code>之前</li><li>更新：</li><li>死亡：<code>vm.$destroy()</code></li></ol></li><li><p>常用声明周期方法</p><ol><li><p><code>mounted()</code>初始化显示之后立即调用(1次)</p><p>□ 发送ajax请求，启动定时器等异步任务</p></li><li><p><code>beforeDestroy</code>：实例销毁之前调用，这一步时，实例还是可用的</p><p>□ 做收尾工作，如清除定时器</p></li></ol></li></ul><h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><ul><li>创建前后<ul><li><code>beforeCreate</code> </li><li><code>created</code></li></ul></li><li>挂载<ul><li><code>beforeMount</code> 如果有<code>el</code>属性，则<code>$el</code>可用，但数据还未渲染</li><li><code>mounted</code> 处理<code>template</code></li></ul></li><li>更新<ul><li><code>beforeUpdate</code></li><li><code>updated</code></li></ul></li><li>激活 <code>keep-alive</code>：销毁真实DOM,保留虚拟DM，<ul><li><code>activated</code> 组件是否被激活</li><li><code>dectivated</code></li></ul></li><li>销毁：真实DOM和虚拟DOM都会销毁，如<code>componnet :is</code>或<code>v-if</code>都会触发激活事件<ul><li>可用来关闭定时器</li><li><code>beforeDestory</code></li><li><code>destroyed</code></li></ul></li><li>监听路由错误<ul><li><code>errorCaptured</code> 当捕获一个来自子孙组件的错误时被调用<ul><li>参数：<code>(错误对象，发生错误的组件实例， 错误信息字符串)</code></li></ul></li></ul></li></ul><blockquote><p>注意点，Vue的所有生命周期函数都是自动绑定到<code>this</code>的上下文上。</p><p>编译模板优先级：<code>render</code>函数  &gt;  内部<code>template</code>  &gt;   外部 <code>html</code></p></blockquote><table><thead><tr><th>钩子</th><th align="left">详细介绍（ 完成 后执行 钩子函数）</th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td align="left">实例在内存中被创建，初始化事件和生命周期</td></tr><tr><td><code>created</code></td><td align="left">初始化  <code>props</code>,<code>methods</code> ,<code>data</code>,<code>computed</code> 和 <code>watch</code></td></tr><tr><td><code>beforeMount</code></td><td align="left">检查是否存在 <code>el</code> ，存在的话<strong>编译</strong>模板，<code>render</code> =&gt; 生成虚拟DOM</td></tr><tr><td><code>mounted</code></td><td align="left">挂载点将虚拟DOM<strong>渲染</strong>为真实DOM</td></tr><tr><td><code>beforeUpdate</code></td><td align="left">实例上的数据已经更新，但是还没有同步到页面上</td></tr><tr><td><code>updated</code></td><td align="left">数据已同步至页面，<br>检查当前的 <code>watcher</code> 列表中，是否存在当前要更新数据的 <code>watcher</code> ，如果存在就执行 <code>updated</code> ；</td></tr><tr><td><code>beforeDestroy</code></td><td align="left">检查是否已经被卸载，如果已经被卸载，就直接 <code>return</code> 出去，否则执行 <code>beforeDestroy</code> ；</td></tr><tr><td><code>destroyed</code></td><td align="left">把所有有关自己痕迹的地方，都给删除掉；</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 beforeMount 和 mounted</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">'Hello Vue'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML);</span><br><span class="line">        <span class="comment">// &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML);</span><br><span class="line">        <span class="comment">//&lt;p&gt;Hello Vue&lt;/p&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 beforeUpdate 和 updated</span></span><br><span class="line"><span class="comment">//点击修改msg，后打印结果如下</span></span><br><span class="line"><span class="comment">//开发中一般使用watch，监听某个数据</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    ...,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.innerText);<span class="comment">//Hello Vue(未改变)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);<span class="comment">//Hello React(已改变)</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.innerText);<span class="comment">//Hello React</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg); <span class="comment">//Hello React</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h3><ul><li><p>数据层变化的时候，并不会立即更新真实DOM，它需要一个差异对比的更新过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(data,<span class="string">'name'</span>,<span class="string">'turing'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML);  <span class="comment">//tr(原来的name)</span></span><br></pre></td></tr></table></figure></li><li><p>为了让数据完全渲染到视图后再去触发逻辑，我们可以使用<code>Vue.nextTick()</code>函数</p><ul><li><code>Vue.nextTick</code>实现原理其实就是<code>setTimeout()</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue-的生命周期&quot;&gt;&lt;a href=&quot;#Vue-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Vue 的生命周期&quot;&gt;&lt;/a&gt;Vue 的生命周期&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cn.vuejs.org/images/life
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue_组件(3)</title>
    <link href="https://turing5467.github.io/2019/10/16/js%E6%A1%86%E6%9E%B6/Vue_2_%E7%BB%84%E4%BB%B6/"/>
    <id>https://turing5467.github.io/2019/10/16/js框架/Vue_2_组件/</id>
    <published>2019-10-15T16:00:00.000Z</published>
    <updated>2019-10-25T03:01:49.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote><p>一个项目中只需要一个<code>new Vue()</code>，作为根容器，上面挂载着许多组件</p></blockquote><ul><li><p><code>Vue.component(id, [definition])</code> 全局注册组件</p></li><li><p><code>id</code>组件名</p><ul><li>短横线分隔命名：模板引用时也只能时<code>xx-xx</code></li><li>首字母大写命名：模板引用时两种方式均可,但在DOM中只能使用<code>xx-xx</code><ul><li>因此建议移植使用短横线分隔命名</li></ul></li></ul></li><li><p><code>definition</code>可接受选项同<code>new Vue()</code>，除了<code>el</code></p><ol><li><code>data</code>必须是一个<strong>函数</strong><ul><li>因为这样每个实例的<code>data</code>属性都拥有独立的<strong>函数作用域</strong>，每个组件之间互不影响</li></ul></li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义一个名为 tr5467 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'tr5467'</span>, &#123;</span><br><span class="line">    <span class="comment">// M层</span></span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            title: <span class="string">'Hello Component'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// V层</span></span><br><span class="line">    template: <span class="string">'&lt;button&gt;&#123;&#123;title&#125;&#125;&lt;/button&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在Vue实例中，将该组件作为自定义标签来使用</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#component'</span>,</span><br><span class="line">    template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">           &lt;tr5467&gt;&lt;/tr5467&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>局部注册<code>components</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义组件，该对象选项与Vue.component的第二个参数一致</span></span><br><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用组件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;div id="component"&gt;</span></span><br><span class="line"><span class="string">        &lt;component-a&gt;&lt;/component-a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><ul><li><code>component</code> + <code>keep-alive</code></li><li><code>transition</code> + <code>transition-group</code></li><li><code>slot</code></li></ul><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul><li>子组件：注册一个组件的时候引用了另一个组件</li><li>父组件：使用到组件的Vue实例</li></ul><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ul><li><p><code>props</code>是你可以在组件上<strong>注册</strong>的一些自定义特性</p></li><li><p>在模板中，我们可以访问<code>props</code>中的值，如同<code>author</code></p></li><li><p>将数据传递进组件</p><blockquote><p>子组件只能在<strong>模板/HTML代码</strong>中使用到<code>props</code>中的变量，在js代码中无法使用，会报错</p></blockquote><ol><li>传递静态<code>prop</code>：<code>&lt;com title=&quot;turing&#39;s mystery&quot;&gt;&lt;/com&gt;</code></li><li>传递动态<code>prop</code>：<code>v-bind</code></li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册组件</span></span><br><span class="line">Vue.component(<span class="string">'alan-turing'</span>,&#123;</span><br><span class="line">    <span class="comment">//data省略</span></span><br><span class="line">    <span class="comment">//注册组件的自定义特性</span></span><br><span class="line">    props: [<span class="string">'author'</span>],</span><br><span class="line">    template: <span class="string">'&lt;p @click="count++"&gt;&#123;&#123;author&#125;&#125; : &#123;&#123;count&#125;&#125;&lt;/p&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用组件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#component'</span>,</span><br><span class="line">    <span class="comment">//通过data向组件传递数据</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        author: <span class="string">'turing'</span></span><br><span class="line">    &#125;</span><br><span class="line">    template: <span class="string">`&lt;div id="component"&gt;</span></span><br><span class="line"><span class="string">&lt;alan-turing :author="author"&gt;&lt;/alan-turing&gt;</span></span><br><span class="line"><span class="string">   &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>prop</code>验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span>  <span class="comment">//default</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><blockquote><p>原理：<strong>观察者模式</strong></p></blockquote><ol><li>子组件：通过<code>this.$emit(&#39;xxxx&#39;，[data])</code> 触发父组件的自定义事件，并将数据作为参数传递给父组件</li><li>父组件：通过``v-bind:on`为子组件标签 绑定事件，接收子组件传来的数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line"><span class="comment">//在父子组件的衔接处，为子组件绑定xx事件，定义回调，接收子组件传来的数据</span></span><br><span class="line">&lt;Child @xx=<span class="string">"doSomething"</span>/&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">"xx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><ul><li><p>插槽：可以向组件标签内部写入内容的</p></li><li><p>通过在组件中添加<code>slot</code>标签，可以选择向组件中 传递/不传递/传递什么 内容/组件</p></li><li><p>通过插槽可以定义组件的不同<strong>状态</strong></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'alert-box'</span>, &#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class="demo-alert-box"&gt;</span></span><br><span class="line"><span class="string">            &lt;strong&gt;Error!&lt;/strong&gt;</span></span><br><span class="line"><span class="string">            &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div id="app"&gt;</span></span><br><span class="line"><span class="string">            &lt;alert-box&gt;Something bad happened.&lt;/alert-box&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>具名插槽：<code>v-slot</code>指令，缩写<code>#</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'named-slot'</span>, &#123;</span><br><span class="line">    <span class="comment">//name属性与下方的v-slot相对应</span></span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;header&gt;</span></span><br><span class="line"><span class="string">            &lt;slot name="header"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">            &lt;/header&gt;</span></span><br><span class="line"><span class="string">            &lt;main&gt;</span></span><br><span class="line"><span class="string">            &lt;slot name="main"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">            &lt;/main&gt;</span></span><br><span class="line"><span class="string">            &lt;footer&gt;</span></span><br><span class="line"><span class="string">            &lt;slot name="footer"&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">            &lt;/footer&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div id="app"&gt;</span></span><br><span class="line"><span class="string">        &lt;named-slot&gt;</span></span><br><span class="line"><span class="string">            &lt;template v-slot:header&gt;</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &lt;template v-slot:main&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;And another one.&lt;/p&gt; </span></span><br><span class="line"><span class="string">            &lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &lt;template v-slot:footer&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;Here's some contact info&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;/template&gt;</span></span><br><span class="line"><span class="string">        &lt;/named-slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过Vue自带的component元素，给其加一个特殊的is特性</span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"当前显示组件id"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>缺点：</p><ol><li>组件被缓存，内存消耗大</li></ol></li><li><p>优点：</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件&quot;&gt;&lt;a href=&quot;#组件&quot; class=&quot;headerlink&quot; title=&quot;组件&quot;&gt;&lt;/a&gt;组件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个项目中只需要一个&lt;code&gt;new Vue()&lt;/code&gt;，作为根容器，上面挂载着许多组件&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue简单使用(2)</title>
    <link href="https://turing5467.github.io/2019/10/15/js%E6%A1%86%E6%9E%B6/Vue_1_%E5%9F%BA%E7%A1%80/"/>
    <id>https://turing5467.github.io/2019/10/15/js框架/Vue_1_基础/</id>
    <published>2019-10-15T04:00:00.000Z</published>
    <updated>2019-10-25T03:01:38.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><ul><li><p>文本插值：</p><p>Mustache语法：<code></code></p><p>无论何时，数据对象上 的<code>msg</code> 属性发生了改变，插值处的内容都会更新。</p><blockquote><p>插值语句或标签内部中的<code>data</code>和<code>computed</code>属性，不能跟<code>()</code>,而<code>methods</code>属性，必须跟<code>()</code></p><p>特殊的是：<strong>事件</strong>中引用的 <code>methods</code>，如果不需要传参，则<code>()</code>可省略</p></blockquote></li><li><p>HTML插值</p><blockquote><p>Mustache语法会将数据解释为<strong>普通文本</strong>，而非 <strong>HTML 代码</strong>。</p><p>为了输出真正的 HTML，你需要使用 <code>v-html</code> 指令。</p></blockquote></li><li><p>标签的prop</p><p>Mustache语法不能用在标签属性上，这是用使用<code>v-bind</code>指令</p></li><li><p>表达式</p><p>对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p></li></ul><h2 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h2><ul><li><p>Class</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//对象语法</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//数组语法</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>内联样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//属性名：fontSize、fontsize、'font-size'、'font-Size'</span><br><span class="line">//1. 对象语法</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: 'red',</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//多重值 =&gt; 只会渲染数组中'最后'一个被浏览器支持的值。</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//数组语法</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleColor, styleSize]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">   color: 'red'</span><br><span class="line">   &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">     fontSize:'23px'</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当 <code>v-bind:style</code> 使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix" target="_blank" rel="noopener">浏览器引擎前缀</a>的 CSS 属性时，如 <code>transform</code>，Vue.js </p><p>会自动侦测并添加相应的前缀。</p></blockquote><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><ul><li><p><code>computed({ key: Function | { get: Function, set: Function } })</code>  </p><p><strong>计算属性</strong>将被混入到 Vue 实例中。</p></li><li><p>键为属性名，值为返回键值的函数</p><p>虽然值是函数，但它本质上是一个属性，调用时不可加上<code>()</code></p></li><li><p><code>get</code>与<code>set</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fullName: &#123;</span><br><span class="line">    <span class="comment">//一般来说，我们不希望外部修改到计算属性，所以一般不声明set方法</span></span><br><span class="line">    set: function(newV)&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    get: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>计算属性的<strong>缓存</strong></p><ul><li><code>computed</code> 和 <code>methods</code><ul><li><code>computed</code>只在相关响应式依赖发生<strong>改变</strong>时它们才会重新求值。</li><li><code>methods</code>每次重新渲染，调用方法<strong>都会</strong>再次执行函数。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            firstName: <span class="string">'Alan'</span>,</span></span><br><span class="line"><span class="javascript">            lastName: <span class="string">'Turing'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            getFullName() &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.count(<span class="string">'method'</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'  '</span> + <span class="keyword">this</span>.lastName</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line"><span class="javascript">            fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.count(<span class="string">'computed'</span>)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'  '</span> + <span class="keyword">this</span>.lastName</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">打印结果</span><br><span class="line">method: 1</span><br><span class="line">method: 2</span><br><span class="line">method: 3</span><br><span class="line">computed: 1</span><br><span class="line"></span><br><span class="line">修改firstName后(改变fullName响应式依赖)</span><br><span class="line">computed: 2</span><br><span class="line">method: 4</span><br><span class="line">method: 5</span><br><span class="line">method: 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><h2 id="侦听watch"><a href="#侦听watch" class="headerlink" title="侦听watch"></a>侦听watch</h2><ul><li><p><code>watch({ key: string | Function | Object | Array })</code> 监听<code>data</code>或<code>computed</code>属性的变化</p><p>回调函数参数为<code>(newValue, oldValue)</code></p></li><li><p><code>computed({ key: Function | { get: Function, set: Function } })</code>  </p><p><strong>计算属性</strong>将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    firstName: <span class="string">'Alan'</span>,</span><br><span class="line">    lastName: <span class="string">'Turing'</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">computed: &#123;</span><br><span class="line">    title: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'  '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="混入mixin"><a href="#混入mixin" class="headerlink" title="混入mixin"></a>混入mixin</h2><ul><li><p>一个混入对象可以包含任意组件选项</p></li><li><p>当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mixins/index.js</span></span><br><span class="line"><span class="keyword">export</span> deafult &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据对象在内部会进行递归合并，并在发生冲突时以<strong>组件数据优先</strong>。</p></li><li><p>全局混入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 </li></ul></li></ul><h2 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h2><ul><li><p>只能在插值语句和<code>v-bind:</code>中使用</p></li><li><p><strong>调用</strong>：<code>msg | msgFilter</code></p><p>可以调用多个过滤器 <code>a | fa |fb</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg | msgFilter('猪')&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!--Hello 猪--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;title | msgFilter&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!--Bye React--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>定义一个过滤器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局过滤器 Vue.filter(name, callback)</span></span><br><span class="line"><span class="comment">//回调 第一个参数为 待过滤的属性 ，该属性取决于调用时过滤器前面的属性</span></span><br><span class="line"><span class="comment">//剩余参数为 调用时传递进来的参数</span></span><br><span class="line">Vue.filter(<span class="string">'msgFilter'</span>, (msg, repl)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.replace(<span class="string">'Vue'</span>, repl || <span class="string">'React'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        title: <span class="string">'Hello Vue'</span>,</span><br><span class="line">        msg: <span class="string">'Bye Vue'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//局部过滤器 优先级 &gt; 全局过滤器</span></span><br><span class="line">    filters: &#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用较少，可以交给<code>computed</code>实现</p></li></ul><h2 id="特殊特性"><a href="#特殊特性" class="headerlink" title="特殊特性"></a>特殊特性</h2><h3 id="v-for中的key"><a href="#v-for中的key" class="headerlink" title="v-for中的key"></a>v-for中的key</h3><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1" target="_blank" rel="noopener">参考文章链接</a></p><ul><li><p><strong>key</strong>：每一个vnode的唯一id，可以判断两个节点是否相同，相同就复用，不相同就删除旧的创建新的。</p></li><li><p>作用：在diff算法执行时更快找到对应的节点，提升diff速度</p></li><li><p>使用建议</p><ol><li><p>最好不使用index作为key</p><ul><li>因为当列表中间发生改变时，会发现同一个<code>item</code>前后两个<code>index</code>却是不同的，无法发生复用，最好使用<code>item.id</code>（或与<code>item</code>相关的唯一值），那么<code>item</code>与<code>key</code>就是一一对应的，可以实现复用</li></ul></li><li><p>输出<strong>简单列表</strong>的情况下，不带key的性能更高</p></li></ol></li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li><code>$refs.xx</code></li></ul><h2 id="过渡-or-动画"><a href="#过渡-or-动画" class="headerlink" title="过渡 or 动画"></a>过渡 or 动画</h2><ul><li><p>过渡</p><blockquote><p><code>&lt;transition&gt;</code>：内部只能有一个根标签</p><p><code>&lt;transition-group tag=&quot;ul&quot; name=&quot;xx&quot;&gt;</code>：内部可以有多个</p></blockquote></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line">//1. 在要添加动画的元素外面套一层transition标签，并设置name属性</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"show = !show"</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue实例化</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到之前设置的name属性，类名均以name-开头</span></span><br><span class="line"><span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>过渡类名(v指代设置的<code>name</code>属性)</p><ol><li><code>v-enter/leave</code> 进场、离场前</li><li><code>v-enter/leave-active</code> 进场、离场的持续效果</li><li><code>v-enter/leave-to</code> 进场、离场后</li></ol></li><li><p><strong>动画</strong>：可搭配<code>animate.css</code>使用</p><ul><li>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 <code>animationend</code> 事件触发时删除。</li><li>一般只需两个类名<code>v-enter/leave-active</code></li></ul></li><li><p>自定义过度类名</p><p>利用<code>transition</code>标签中的<code>enter/..-class</code>来设置过度类名，它们的优先级高于普通类名</p></li><li><p>显示的过渡持续时间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"1000"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模板语法&quot;&gt;&lt;a href=&quot;#模板语法&quot; class=&quot;headerlink&quot; title=&quot;模板语法&quot;&gt;&lt;/a&gt;模板语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文本插值：&lt;/p&gt;
&lt;p&gt;Mustache语法：&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无论何时，数据对
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://turing5467.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue入门(1)</title>
    <link href="https://turing5467.github.io/2019/10/15/js%E6%A1%86%E6%9E%B6/Vue/"/>
    <id>https://turing5467.github.io/2019/10/15/js框架/Vue/</id>
    <published>2019-10-15T03:00:00.000Z</published>
    <updated>2019-10-25T03:01:19.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li><p>通过<code>npm</code>安装<code>npm i vue --save</code></p></li><li><p>入口文件<code>index.js</code>编写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//引入严格版本，会把template去掉</span></span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//引入完整版本，可使用template</span></span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue/dist/vue'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">          name: <span class="string">'turing'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//render用于发布环境</span></span><br><span class="line">      render(h) &#123;</span><br><span class="line">          <span class="keyword">return</span> h(<span class="string">'div'</span>,<span class="literal">null</span>,<span class="string">'hello world'</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//视图层--</span></span><br><span class="line">      <span class="comment">//template用于生产环境，&#123;&#123;&#125;&#125;：声明式渲染，用来引入变量，this可省略</span></span><br><span class="line">      <span class="comment">//一定仅需要一个&lt;div&gt;标签包起来(相当于outerHTML)</span></span><br><span class="line">      template: <span class="string">`&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器辅助工具：<code>vue-devtools</code></p></blockquote><h3 id="new-Vue-options"><a href="#new-Vue-options" class="headerlink" title="new Vue(options)"></a>new Vue(options)</h3><p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">参考链接</a></p><ul><li>核心选项<ol start="2"><li><code>data &lt;Object | Function(组件中must)&gt;</code> 创建的Vue实例的数据对象</li><li><code>methods</code> 定义一些方法，可以在指令中调用，也可在其他地方 </li><li><code>template</code> 模板声明了数据和最终展现给用户的DOM之间的映射关系。</li><li><code>props</code> 组件接收的<strong>外部参数</strong>，<strong>组件</strong>之间通过参数来进行数据的传递和共享。</li><li><strong>生命周期钩子函数</strong>：一个组件会触发多个生命周期钩子函数。</li></ol></li></ul><blockquote><p><code>methods</code>和 <code>data</code>和 <code>computed</code> 将直接挂载到实例对象上</p></blockquote><h3 id="Vue-instance"><a href="#Vue-instance" class="headerlink" title="Vue instance"></a>Vue instance</h3><ul><li><p>事件</p><ol><li><p><code>$on</code> 监听实例上的<strong>自定义</strong>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指令中可配合$emit使用,剩余参数也可以是传入参数</span></span><br><span class="line">&#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;button v-on:click="$emit('welcome',...args)"&gt;</span></span><br><span class="line"><span class="string">          Click me to be welcomed</span></span><br><span class="line"><span class="string">        &lt;/button&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>$once</code></p></li><li><p><code>$emit</code> 触发当前实例上的事件。附加参数都会传给监听器回调。</p></li><li><p><code>$off</code> 移除自定义事件监听器。</p></li></ol></li><li><p>方法</p><ol><li><p><code>$mount(string | element)</code> 手动地挂载一个未挂载（实例化时没有收到<code>el</code>选项）的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;Hello!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并挂载到 #app (会替换 #app)</span></span><br><span class="line"><span class="keyword">new</span> MyComponent().$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">new</span> MyComponent(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，在文档之外渲染并且随后挂载</span></span><br><span class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> MyComponent().$mount()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).appendChild(component.$el)</span><br></pre></td></tr></table></figure></li><li><p><code>$nextTick(cb)</code> 将回调延迟到下次 DOM 更新循环之后执行。</p></li></ol></li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li><p><code>Vue</code>下达给视图层的一个命令，能够更改视图层的效果</p></li><li><p>以<code>v-</code>前缀，存放在标签的属性值里</p></li><li><p>指令列表（与jQuery的关联）</p><ul><li><code>v-text</code>&amp; <code>$().text()</code></li><li><code>v-html</code>&amp; <code>$().html()</code></li><li><code>v-show</code>&amp; <code>$().show()</code></li><li><code>v-if</code>&amp; <code>$().remove()</code>+ <code>$().append()</code></li><li><code>v-else</code></li><li><code>v-else-if</code></li><li><code>v-for</code>&amp; <code>$().each()</code></li><li><code>v-on</code>&amp;<code>$().on()</code>绑定事件</li><li><code>v-bind</code>&amp; <code>$().attr().css().addClass().removeClass()</code> 更改属性值</li><li><code>v-model</code>&amp; <code>$().val()</code></li><li><code>v-slot</code> 插槽</li><li><code>v-pre</code> 让<code></code> 声明式失效</li><li><code>v-cloak</code> 让<code></code> 完全编译成功之后再出现</li><li><code>v-once</code> 让<code></code> 只能编译一次</li></ul></li></ul><ul><li><p><code>v-if</code>与<code>v-show</code></p><ul><li><p><code>v-if</code>：只有条件变为真时，才会渲染元素。</p></li><li><p>在切换时元素及它的数据绑定 / 组件被销毁并重建。</p></li><li><p>搭配指令<code>v-else</code>或<code>v-else-if=&quot;条件&quot;</code></p></li><li><p><code>v-show</code>：不管初始条件是什么，始终渲染元素，然后根据条件设置样式<code>display</code></p></li></ul><blockquote><p> 一般来说，<code>v-if</code> 有更高的<strong>切换</strong>开销，而 <code>v-show</code> 有更高的<strong>初始渲染</strong>开销。</p><p>如果需要非常<strong>频繁地切换</strong>，则使用 <code>v-show</code> 较好；</p><p>如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p></blockquote></li></ul><ul><li><p><code>v-text</code> 更新元素的<code>textContent</code></p></li><li><p><code>v-html</code> <code>innerHTML</code></p><p><strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong> 。</p></li></ul><ul><li><p><code>v-for</code>基于源数据多次渲染元素或模板块</p><p><code>in</code>后面可以是number、string(需加<code>&#39;&#39;</code>)、array、object、Iterable(2.6)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot;&gt;</span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//参数 先 value 后 key 最后 index</span><br><span class="line">&lt;div v-for=&quot;(val, name, index) in object&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//如果是数字，那么item从1开始计数</span><br></pre></td></tr></table></figure><ul><li><p>组件中的<code>key</code>属性</p><ul><li><p>当我们希望在列表节点中间，插入一个新的节点时，默认diff算法是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C=&gt;F  D=&gt;C E=&gt;D F=&gt;E//十分麻烦</span><br></pre></td></tr></table></figure></li><li><p>这时如果使用key给每个节点做一个唯一标识</p></li></ul></li></ul></li></ul><ul><li><p><code>v-on:type=&quot;fnName&quot;</code> 绑定事件监听器。</p><ul><li><p>缩写：<code>@</code></p></li><li><p>参数: <code>event</code></p></li><li><p>修饰符：</p><ol><li><p><code>.stop</code>阻止事件冒泡到父元素</p></li><li><p><code>.prevent</code>禁止默认行为</p></li><li><p><code>.passive</code> 告诉浏览器立即触发默认行为</p></li><li><p><code>.once</code>只触发一次回调</p></li><li><p><code>.(keyCode | Alias)</code> 在监听<strong>键盘事件</strong>时添加按键修饰符</p><p>一些别名：<code>enter/tab/delete/esc/space/up/down/laft/down/f1</code></p></li><li><p><code>.ctrl/alt/shift/meta</code> 仅在按下相应按键时才触发<strong>鼠标或键盘</strong>事件的监听器。</p></li><li><p><code>.native</code>监听组件根元素的原生事件</p></li></ol><blockquote><p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰器别名</p><p><code>Vue.config.keyCodes.f1 = 112</code></p></blockquote></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"fnName"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--串联修饰符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对象语法 (2.4.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">"&#123; mousedown: doThis, mouseup: doThat &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>事件监听函数如果 不需要传参，则后面的<code>()</code>可以省略</p><p>如果不传入参数，默认第一个参数为<code>event</code></p><p>如果需要传入其它参数，那么通过传入<code>$event</code>可以获取到浏览器参数的<code>event</code>对象</p></blockquote></li></ul><ul><li><p><code>v-bind</code> 动态地绑定一个或多个属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imageSrc"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- class 绑定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, classB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- style 绑定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><ul><li><p>本质是监听<code>input</code>事件</p></li><li><p>修饰符</p></li><li><p><code>.lazy</code>改为监听<code>change</code>事件</p><ul><li><code>.number</code> 输入字符串转为有效的数字</li><li><code>.trim</code> 输入首尾空格过滤</li></ul></li></ul></li><li><p><code>v-model</code>指令能轻松实现表单输入和应用状态之间的双向绑定</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个复选框，v-model绑定到布尔值：</span></span><br><span class="line"><span class="comment">//多个复选框，v-model绑定到数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单选按钮，v-model绑定到值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//select框</span></span><br><span class="line"><span class="comment">//单选时，绑定到值</span></span><br><span class="line"><span class="comment">//多选时，绑定到数组</span></span><br></pre></td></tr></table></figure><ul><li><p><code>v-slot</code>具名插槽，缩写<code>#</code></p></li><li><p><code>v-pre</code> 使声明式失效</p><p>跳过大量没有指令的节点会加快编译。</p></li><li><p><code>v-clock</code> 完全编译成功之后再出现</p></li><li><p><code>v-once</code> 只渲染一次</p></li></ul><h3 id="vue中的this"><a href="#vue中的this" class="headerlink" title="vue中的this"></a>vue中的this</h3><blockquote><p>对于Vue的<strong>HTML</strong>代码中的<strong>表达式</strong>，所有的表达式隐式带有<code>this</code>，使用时必须省略<code>this</code>。</p><p>而<strong>script</strong>中的代码属于js内容，<code>this</code>不可以省略</p></blockquote><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><blockquote><p>全局属性一般不加s，如<code>Vue.filter()</code>、<code>Vue.component()</code>等</p><p>局部组件一般加s，如选项中的<code>components</code>、<code>filters</code></p></blockquote><ul><li><p><code>Vue.directive(dirName, function | obj)</code></p><ul><li><p><code>dirName</code>：指令名称 定义时不需要加<code>v-</code>，调用时必须加<code>v-</code></p></li><li><p><code>obj</code>：提供指令的钩子函数</p><ul><li><code>bind</code>  指令第一次<strong>绑</strong>定到元素时调用。（表现：如css样式）</li><li><code>inserted</code> 被绑定元素<strong>插入</strong>父节点时调用 （行为：如获取焦点）</li><li><code>update</code>  所在组件的 VNode <strong>更新</strong>时调用。</li><li><code>componentUpdated</code> 指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li><code>unbind</code> 解绑时调用。</li></ul></li><li><p>钩子函数参数</p><ul><li><p><code>el</code>指令绑定元素</p></li><li><p><code>binding</code> 一个对象，包含以下属性</p><ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的<strong>绑定值</strong>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li><li><code>expression</code>：字符串形式的指令<strong>表达式</strong>。</li><li><code>arg</code>：传给指令的<strong>参数</strong>，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：<strong>修饰符</strong>对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li></ul></li><li><p><code>vnode</code>：Vue 编译生成的虚拟节点。</p></li><li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-focus&gt;  <span class="comment">//自动获取焦点的输入框</span></span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    inserted: <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">        el.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>function</code>函数简写，该函数将会同时被 <code>bind</code> 和 <code>update</code> 调用</li></ul></li><li><p>自定义私有指令</p><ul><li><code>directives</code>参数同上</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;npm&lt;/code&gt;安装&lt;code&gt;npm i vue --save&lt;/code&gt;&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
    
    
      <category term="Vue js框架" scheme="https://turing5467.github.io/tags/Vue-js%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>typescript入门</title>
    <link href="https://turing5467.github.io/2019/10/15/%E5%85%B6%E4%BB%96/TypeScript/"/>
    <id>https://turing5467.github.io/2019/10/15/其他/TypeScript/</id>
    <published>2019-10-14T16:00:00.000Z</published>
    <updated>2019-10-15T04:14:47.055Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><ol><li><p><code>boolean</code></p></li><li><p><code>number</code></p></li><li><p><code>string</code></p></li><li><p><strong>数组</strong>：<code>Array&lt;number&gt;</code> 或<code>number[]</code></p></li><li><p><strong>元组</strong>类型允许表示一个已知元素数量和类型的<strong>数组</strong>，各元素的类型可以<strong>不同</strong></p></li><li><p>枚举(<code>enum</code>：可以定义一些有名字的<strong>数字常量</strong>，索引默认从0递增</p><p>可以从枚举值到枚举名进行<strong>反向映射</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ts</span></span><br><span class="line">enum Color &#123;Red = <span class="number">1</span>,Green = <span class="number">2</span>,Blue = <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Color</span>) </span>&#123;</span><br><span class="line">    Color[Color[<span class="string">"Red"</span>] = <span class="number">1</span>] = <span class="string">"Red"</span>; <span class="comment">//Color['red']=1; Color[1]='red'</span></span><br><span class="line">    Color[Color[<span class="string">"Green"</span>] = <span class="number">2</span>] = <span class="string">"Green"</span>;</span><br><span class="line">    Color[Color[<span class="string">"Blue"</span>] = <span class="number">4</span>] = <span class="string">"Blue"</span>;</span><br><span class="line">&#125;)(Color || (Color = &#123;&#125;));</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p><code>any</code> 表示任何类型</p></li><li><p><code>void</code> 表示没有任何类型,只能赋予<code>null</code>和<code>undefined</code>，一般用于无返回值的函数</p></li><li><p><code>null</code> 和<code>undefined</code></p></li><li><p><code>never</code> 永不存在的值的类型，</p><p>例如 <code>throw new Error</code></p><p>​        <code>return error(&#39;sth failed&#39;)</code> </p><p>​         <code>while(true) {...}</code></p></li></ol><ul><li><p>类型断言<code>assert</code>：可以用来手动指定一个值的类型</p><ol><li><p>尖括号语法：<code>&lt;string&gt;variable</code></p></li><li><p>as语法：<code>variable as string</code></p><p>当在TypeScript里使用<code>JSX</code>时，只有<code>as</code>语法断言是被允许的。</p></li></ol><ul><li><p>场景：在还不确定类型的时候 就得访问其中一个类型的属性或方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: string | number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当something为字符串时</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>something).length) &#123;</span></span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>泛型：函数中的变量的类型与传入参数的类型相同</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明泛型的两种方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen_func1</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen_func2: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line">gen_func1&lt;<span class="built_in">string</span>&gt;(<span class="string">'Hello world'</span>);</span><br><span class="line">gen_func2(<span class="string">'Hello world'</span>);</span><br><span class="line"><span class="comment">// 第二种调用方式可省略类型参数，因为编译器会根据传入参数来自动识别对应的类型。</span></span><br></pre></td></tr></table></figure><ul><li><p>泛型约束</p><ul><li><p><code>extends</code>     </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> hasLengthP&#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//约束传入参数必须具有length属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">hasLengthP</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"打印length值 = "</span> + arg.length);</span><br><span class="line"><span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>- `keyof` 索引类型查询操作符。  `keyof T`产生的类型是T的**属性所属类型**构成的**联合类型**。</code></pre><ul><li><p>函数 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> add = (a:number,<span class="attr">b</span>:number) :<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>函数可选参数：参数后跟<code>?</code></p><blockquote><p>注意：可选参数必须位于参数列表的最后。</p></blockquote></li><li><p>参数默认值：<code>形参名称 : 参数类型 = 默认值</code></p></li></ul><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><pre><code>1. `interface` 2. `type`</code></pre><ul><li><p>相同点：</p><ol><li><p>都可以用来描述一个对象或函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">interface</span> SetUser &#123;</span><br><span class="line">(name: <span class="built_in">string</span>, age: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SetUser = (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>都允许继承，且可相互继承</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Name_1 &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Name_2 = &#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface继承interface / type</span></span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> [<span class="keyword">interface</span> | type] &#123;</span><br><span class="line">age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//type继承type / interface</span></span><br><span class="line"><span class="keyword">type</span> User = [<span class="keyword">interface</span> | type] &amp; &#123;</span><br><span class="line">    age:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>不同点</p><ol><li><code>type</code>可以而<code>interface</code>不可以<ul><li>声明基本类型别名，联合类型，元组等类型</li><li>可以使用<code>typeof</code>获取实例的类型进行赋值</li><li><code>| keyof</code>等</li></ul></li><li><code>interface</code>可以而<code>type</code>不行<ul><li>声明合并</li><li>可选属性：后跟<code>?</code></li><li>只读属性：前用<code>readonly</code></li></ul></li></ol></li></ul><h3 id="实现与继承"><a href="#实现与继承" class="headerlink" title="实现与继承"></a>实现与继承</h3><ol><li><code>implements</code> 明确的强制一个类去符合某种契约</li><li><code>extends</code> 继承父类</li></ol><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul><li><code>public</code>默认</li><li><code>private</code> 无法被外部访问</li><li><code>protected</code>只能在子类中访问</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;number&lt;/c
      
    
    </summary>
    
    
    
      <category term="typescript" scheme="https://turing5467.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack入门</title>
    <link href="https://turing5467.github.io/2019/10/13/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack/"/>
    <id>https://turing5467.github.io/2019/10/13/工程化/webpack/</id>
    <published>2019-10-12T16:00:00.000Z</published>
    <updated>2019-10-25T06:36:35.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul><li>webpack可以从npm下载第三方模块，并能够使用于浏览器/前端</li><li>webpack是一个模块打包器<br>  在它看来，所有的资源文件都会作为模块处理，它将根据模块的依赖关系进行静态分析，生成相应的静态资源<br>  <img src="http://webpack.github.io/assets/what-is-webpack.png" alt="Alt text"></li><li>箭头指向为其所依赖的模块：<code>a =&gt; b   a依赖b</code></li><li>核心概念：<pre><code>1. entry    `文件夹 src`</code></pre><ol start="2"><li>output <code>文件夹 dist</code></li><li>loader</li><li>plugins<br> 完成一些loader不能完成的功能，可在配置文件的<code>plugins</code>选项中指定</li><li>Chunk：coding split的产物，我们可以对一些代码打包成一个单独的chunk，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。</li></ol></li><li>配置文件(默认)：<code>webpack.config.js</code>是一个node模块，返回一个json格式的配置信息对象</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><code>npm init -y</code> <pre><code>`&quot;start&quot;: &quot;webpack --config webpack.config.js`</code></pre></li><li><code>cnpm i webpack --save-dev</code><br>  <code>cnpm i webpack-cli  --save-dev</code><br>  以及其它依赖</li><li>编译打包应用<ol><li>入口: <code>src/js/entry.js</code><pre><code>编写业务逻辑，文件中可通过`require`命令引入第三方模块</code></pre></li><li>主应用: <code>dist/index.html</code><pre><code>`&lt;script type=&quot;&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;`</code></pre></li><li>编译<code>webpack.config.js</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,  <span class="comment">//production &amp; development(压缩js) &amp; none</span></span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>​                4. <code>npm start</code></p><h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><blockquote><p>spa：单页web应用</p></blockquote><ul><li><p><code>webpack.config.js</code></p></li><li><p>输入输出</p><ol><li><p><code>entry</code>: 代表入口，webpack会找到该文件进行解析</p></li><li><p><code>output</code></p><pre><code>1. `path` 必须使用绝对路径 2. `filename` 输出文件名 3. `publicPath`知道如何寻找资源</code></pre><ul><li>多入口配置</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">pageA: <span class="string">'./src/pageA.js'</span>,</span><br><span class="line">pageB: <span class="string">'./src/pageB.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">path: path.join(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">filename: <span class="string">'[name].[hash:8].js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  <code>entry</code>配置一个对象，key值就是<code>chunk</code>： 代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</p><ol><li>filename<code>[name]</code>: 这个name指的就是chunk的名字，我们配置的key值<code>pageA</code> <code>pageB</code>，这样打包出来的文件名是不同的，</li><li><code>[hash]</code>，给输出文件一个hash值，避免缓存，<code>:8</code>是取前8位。</li><li><code>[ext]</code>扩展名</li></ol><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p><a href="https://www.webpackjs.com/loaders/" target="_blank" rel="noopener">loader</a></p><ul><li><p>webpack本身只能加载<code>js/json</code>模块，如果要加载其它类型的文件，就要使用相应的<code>loader</code>进行转换/加载进出口文件</p><pre><code>1. `test:` 正则表达式，匹配文件名      2. `use`: 一个数组，里面放需要执行的loader，**倒序**执行，**从右至左**。        3. `exclude`: 正则表达式，**取消匹配**node_modules里面的文件</code></pre></li></ul><blockquote><p>raw-loader  css-loader style-loader</p></blockquote><h4 id="css打包"><a href="#css打包" class="headerlink" title="css打包"></a>css打包</h4><p>通过在入口文件中<code>import &#39;./xx.css&#39;</code>或<code>require</code> 来使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="comment">//一定是style-loader写在前面</span></span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>css-loader</code>: 将 CSS 转化成 CommonJS 模块</p></li><li><p><code>style-loader</code> 将 JS 字符串生成为 style 节点，依赖于<code>css-loader</code></p></li><li><p><code>sass-loader</code> 与<code>node-sass</code>联合使用，用来引入<code>.scss</code>文件</p></li></ul><ul><li><p>通常，<strong>生产环境</strong>下比较推荐的做法是，使用 <a href="https://github.com/webpack-contrib/extract-text-webpack-plugin" target="_blank" rel="noopener">ExtractTextPlugin</a> 将样式表抽离成专门的单独文件。这样，样式表将不再依赖于 JavaScript：</p><ol><li>首先安装插件<code>npm install --save-dev extract-text-webpack-plugin@next</code>(必须是最新版，否则会报错)</li><li>配置webpack.config.js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                use: [<span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style.css'</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><ul><li><p><code>babel</code>:首先安装必要库 <code>npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env webpack</code></p><ul><li>babel-loader 用于让 webpack 知道如何运行 babel</li><li>babel-core 可以看做编译器，这个库知道如何解析代码</li><li>babel-preset-env 这个库可以根据环境的不同转换代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: [<span class="string">'babel-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让 preset 生效，你需要像下面这样定义你的 <code>.babelrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h5><ul><li><p>处理图片<code>npm i -d url-loader file-loader</code></p><p>​    - <code>url-loader</code>: 依赖于<code>file-loader</code>,把图片转换成base64嵌入html,如果超出一定阈值则交给``file-loader`</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            <span class="comment">// 限制 图片大小 10000B，小于限制会将图片转换为 base64格式</span></span><br><span class="line">            limit: <span class="number">10000</span>,</span><br><span class="line">            <span class="comment">// 超出限制，创建的文件格式</span></span><br><span class="line">            name: <span class="string">'images/[name].[hash:8].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p><a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">plugins</a></p><ul><li><p>自动生成<code>index.html</code>和<code>bundle.js</code>：<code>html-webpack-plugin</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()]</span><br></pre></td></tr></table></figure></li></ul><ul><li>在打包前自动清空dist目录：<code>clean-webpack-plugin</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="comment">//清空的目录是output.path</span></span><br><span class="line"><span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>将 CSS 文件打包为一个单独文件：<code>extract-text-webpack-plugin</code> </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                    <span class="comment">// 必须这样写，否则会报错</span></span><br><span class="line">                    fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                    use: [&#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                        options: &#123; </span><br><span class="line">                            modules: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 输出的文件路径</span></span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"css/style.css"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽取共同代码  ：webpack 自带的插件 <code>CommonsChunkPlugin</code>（未测试）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// [chunkhash]会自动根据文件是否更改而更换哈希</span></span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    <span class="comment">// vendor 的意义和之前相同</span></span><br><span class="line">    <span class="comment">// manifest文件是将每次打包都会更改的东西单独提取出来，保证没有更改的代码无需重新打包，这样可以加快打包速度</span></span><br><span class="line">      names: [<span class="string">'vendor'</span>, <span class="string">'manifest'</span>],</span><br><span class="line">      <span class="comment">// 配合 manifest 文件使用</span></span><br><span class="line">      minChunks: <span class="literal">Infinity</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实用属性"><a href="#实用属性" class="headerlink" title="实用属性"></a>实用属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//实用属性</span></span><br><span class="line"> resolve: &#123;</span><br><span class="line">     <span class="comment">// 文件扩展名，写明以后就不需要每个文件写后缀</span></span><br><span class="line">     extensions: [<span class="string">'.js'</span>, <span class="string">'.css'</span>, <span class="string">'.json'</span>],</span><br><span class="line">     <span class="comment">// 路径别名，比如这里可以使用 css 指向 static/css 路径</span></span><br><span class="line">     alias: &#123;</span><br><span class="line">       <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">       <span class="string">'css'</span>: resolve(<span class="string">'static/css'</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 生成 source-map，用于打断点，这里有好几个选项</span></span><br><span class="line">devtool: <span class="string">'#cheap-module-eval-source-map'</span>,</span><br></pre></td></tr></table></figure><h3 id="配置webpack服务器"><a href="#配置webpack服务器" class="headerlink" title="配置webpack服务器"></a>配置webpack服务器</h3><p><a href="https://www.webpackjs.com/configuration/dev-server/" target="_blank" rel="noopener">dev Server</a></p><blockquote><p> 文件实际上放在<strong>内存</strong>而不是磁盘中，所以读取速度很快</p></blockquote><ol><li><p><code>npm i webpack-dev-server -g</code></p></li><li><p>配置webpack服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">"dist"</span>),  <span class="comment">//为哪一个文件夹提供本地服务</span></span><br><span class="line">  compress: <span class="literal">true</span>,</span><br><span class="line">  inline: <span class="literal">true</span>,<span class="comment">//页面实时刷新</span></span><br><span class="line">  port: <span class="number">9000</span><span class="comment">//端口号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>webpack-dev-server</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//会看到这么一行：Ctrl + 鼠标左键 点击链接即可</span><br><span class="line">Project is running at http://localhost:9000/</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;webpack可以从npm下载第三方模块，并能够使用于浏览器/前端&lt;/li&gt;
&lt;li&gt;w
      
    
    </summary>
    
    
    
      <category term="Webpack" scheme="https://turing5467.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>mongodb入门</title>
    <link href="https://turing5467.github.io/2019/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    <id>https://turing5467.github.io/2019/10/13/数据库/mongodb/</id>
    <published>2019-10-12T16:00:00.000Z</published>
    <updated>2019-10-15T04:35:01.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>MongoDB是一个基于分布式文件存储的数据库，由<code>c++</code>语言编写,旨在为Web应用提供可扩展的高性能数据存储解决方案</li><li>MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是<strong>非关系数据库(NoSQL)</strong>中功能最丰富、最像关系数据库的<br>  数据库 =&gt; <strong>数据库</strong>：存放集合<br>  数据表 =&gt; <strong>集合</strong>：类似数组，可以存放文档<br>  表记录 =&gt; <strong>文档</strong>对象：数据库的最小单位 (结构无限制,可以包含/不包含任意key)</li><li>MongoDB不需要设计表结构, 可以任意往其中添加数据</li><li>安装 <code>mongod --version</code></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>步骤</li></ul><ol><li><p>安装<a href="https://www.mongodb.org/dl/win32/" target="_blank" rel="noopener">MongoDB</a></p></li><li><p><code>/bin</code>目录配置环境变量</p></li><li><p>在某盘根目录创建<code>data</code>文件夹 =&gt; 在<code>data</code>文件夹中创建<code>db</code>文件夹</p></li><li><p>打开cmd：输入<code>mongod</code> <strong>启动</strong>服务器(<code>net start mongodb</code>)<br> 该命令默认使用当前磁盘下的<code>/data/db</code>作为数据库存储目录(需手动创建，否则报错)<br> 若想修改, <code>mongod --dbpath  数据库目录</code><br> <code>--port</code>可用来指定端口号<br> <strong>关闭</strong>服务器： Ctrl + C 或关闭控制台</p></li><li><p><strong>连接</strong>mongodb数据库：</p><p> 打开另一个cmd：输入<code>mongo</code>(默认连接到<code>mongodb://127.0.0.1:27017</code>)</p><p> 或 使用compass连接</p><p> 退出连接 ：<code>exit</code></p></li></ol><ul><li>将Mongodb设置为系统服务，可以自动在后台启动<ol><li>在某盘下的<code>data</code>创建<code>log</code>文件夹</li><li>找到<code>mongodb</code>安装目录,创建<code>mongod.cfg</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: c:\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: c:\data\db</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="3"><li>以管理员身份打开cmd ，输入<code>sc.exe create MongoDB binPath=&quot;\&quot;D:\Program Files\mongodb\mongodb-4.0.12\bin\mongod.exe\&quot; --service --config=\&quot;D:\Program Files\mongodb\mongodb-4.0.12\mongod.cfg\&quot;&quot; DisplayName=&quot;MongoDB&quot; start=&quot;auto&quot;</code></li><li>在服务中启动<code>mongoDB</code>服务<pre><code>如果失败，则`sc delete MongoDB`，重新步骤</code></pre></li><li>连接数据库：切到<code>d:/</code> <code>mongo</code></li></ol><h3 id="mongodb基本命令"><a href="#mongodb基本命令" class="headerlink" title="mongodb基本命令"></a>mongodb基本命令</h3><p>注：真正操作不使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. show dbs 显示所有数据库(默认由admin和local两个系统数据库,不要动它们)</span><br><span class="line">2. db 查看当前操作数据库</span><br><span class="line">3. use dbname 切换到指定的数据库 (没有则会创建)</span><br><span class="line">4. show collections 显示当前数据库所有集合</span><br><span class="line"></span><br><span class="line">- 增删改查</span><br><span class="line">增. db.[集合名].insert([] | &#123;&#125;) 插入一个或多个文档对象</span><br><span class="line">insertMany([])insertOne(&#123;&#125;)</span><br><span class="line">查. db.[集合名]ts.find() 显示集合中的所有内容</span><br><span class="line">find(&#123;条件&#125;) 查询符合条件的文档，返回值为数组</span><br><span class="line">.count()/.length() 返回查询结果的数量</span><br><span class="line">第二个参数可指定想显示的字段，如&#123;name:1, _id: 0, sal:1&#125;</span><br><span class="line">findOne(&#123;条件&#125;)</span><br><span class="line">改</span><br><span class="line">db.[集合名].update(查询条件, 新对象) 默认修改一个 </span><br><span class="line">修改多个: 第三个参数 options &#123; multi: true &#125;</span><br><span class="line">(默认会使用新对象完全替代旧对象(除id))</span><br><span class="line">如果要修改指定属性，需要使用&apos;修改操作符&apos;</span><br><span class="line">1. $set: 只修改指定属性，其他保持不变</span><br><span class="line">update(&#123;&#125;, &#123;</span><br><span class="line">$set: &#123;</span><br><span class="line">name: &quot;快乐的图小灵&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">2. $unset: 删除指定属性</span><br><span class="line">3. $inc xx属性 增加 指定数字</span><br><span class="line">updateOne() updateMany() replaceOne()</span><br><span class="line">删</span><br><span class="line">db.[集合名].remove() 删除符合条件的多个文档 (一个 =&gt; 第二个参数传true)</span><br><span class="line">remove(&#123;&#125;) 删除所有(效率差 =&gt; db.[集合名].drop() 删除集合 )</span><br><span class="line">deleteOne() </span><br><span class="line">deleteMany()</span><br><span class="line">删除集合 db.stu.drop()</span><br><span class="line">删除数据库 db.dropDatabase()</span><br></pre></td></tr></table></figure><ul><li>当我们向集合中插入文档时，如果没有指定<code>_id</code>属性，则会自动添加，作为文档的唯一标识(可通过<code>ObjectId()</code>手动生成)</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li><p>默认按照<code>_id</code>升序排列</p></li><li><p><code>xx.find().sort({排序属性: 排序规则})</code></p><pre><code>排序规则     1：升序</code></pre><p>  ​                        -1：降序<br>  可有多个属性,先按照在前的属性排序,在前的属性相同则按照在后的属性排序</p></li></ul><h3 id="在node中操作MongoDB"><a href="#在node中操作MongoDB" class="headerlink" title="在node中操作MongoDB"></a>在node中操作MongoDB</h3><h4 id="1-官方MongoDB包"><a href="#1-官方MongoDB包" class="headerlink" title="1-官方MongoDB包"></a>1-官方MongoDB包</h4><ul><li><a href="https://www.npmjs.com/package/mongodb" target="_blank" rel="noopener">mongodb教程</a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line"><span class="keyword">const</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://localhost:27017'</span>;</span><br><span class="line"><span class="keyword">const</span> dbName = <span class="string">'myproject'</span>;</span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, client</span>) </span>&#123;</span><br><span class="line">  assert.equal(<span class="literal">null</span>, err);</span><br><span class="line">  <span class="keyword">const</span> db = client.db(dbName); </span><br><span class="line"></span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入数据//更新//删除</span></span><br><span class="line"><span class="keyword">const</span> collection = db.collection(<span class="string">'documents'</span>);</span><br><span class="line">  <span class="comment">// Insert some documents</span></span><br><span class="line">  collection.insertMany([</span><br><span class="line">    &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">2</span>&#125;, &#123;<span class="attr">a</span> : <span class="number">3</span>&#125;</span><br><span class="line">  ], <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.result.n);</span><br><span class="line">    assert.equal(<span class="number">3</span>, result.ops.length);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Inserted 3 documents into the collection"</span>);</span><br><span class="line">    callback(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line">collection.find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">    assert.equal(err, <span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Found the following records"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(docs)</span><br><span class="line">    callback(docs);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="2-第三方-mongoose"><a href="#2-第三方-mongoose" class="headerlink" title="2-第三方 mongoose"></a>2-第三方 mongoose</h4><ul><li>官网 <a href="mongoosejs.com">mongoose</a></li><li>mongoose是一个可以让我们通过<code>node</code>来操作MongoDB的模块</li><li>是一个对象文档模型(ODM)库，对node原生的MongoDB库进行了进一步的优化封装，并提供了更多的功能</li></ul><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>可以为文档创建一个<strong>模式结构(schema)</strong></li><li>可以对模型中的对象/文档进行<strong>验证</strong></li><li>数据可以通过类型转换转化为对象模型</li><li>可以使用<strong>中间件</strong>来应用业务逻辑挂钩</li></ul><h5 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h5><ol><li><code>Schema</code>  定义约束了数据库中的<strong>文档结构</strong></li><li><code>Model</code> 集合中所有文档的表示，相当于MongoDB数据库中的<strong>集合</strong><code>collection</code> </li><li><code>Document</code> 表示集合中的<strong>具体文档</strong></li></ol><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ol><li>下载 <code>npm i mongoose --save</code></li><li>引入</li><li>连接数据库<br> <code>mongoose.connect(&#39;mongodb://ip地址/数据库名&#39;)</code> 返回一个状态待定（pending）的连接</li><li>监听连接开启/失败<br> <code>mongoose.connection.once(&#39;open&#39;, () =&gt; {})</code><br> <code>mongoose.connection.once(&#39;close&#39;, () =&gt; {})</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.创建schema对象</span></span><br><span class="line"><span class="keyword">let</span> schema = mongoose.Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="number">21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.通过Schema创建Model(即数据库中的集合)(首字母最好大写，因为是构造函数)</span></span><br><span class="line"><span class="comment">//mongoose.model(modalName, schema);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> StuModal = mongoose.model(</span><br><span class="line"><span class="string">'stu'</span>, </span><br><span class="line">schema, </span><br><span class="line"><span class="comment">//数据库中的集合名将会自动将第一个参数，首字母小写，并尾部添加s</span></span><br><span class="line"><span class="string">'stu'</span>   <span class="comment">//显式修改集合名</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.创建文档并插入数据库中</span></span><br><span class="line"><span class="comment">//StuModal.create(doc, (err)=&gt;&#123;&#125;)</span></span><br><span class="line">StuModal.create(&#123;</span><br><span class="line">    name: <span class="string">'turing'</span>,</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'插入成功'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>schemaType</code>选项</p><ol><li><code>type</code> 允许类型：<code>String Number Date Buffer Boolean Mixed(啥都可以放) ObjectId Array([])</code></li><li><code>default</code> 默认值</li><li><code>alias</code>别名(字符串)</li><li><code>required</code> 布尔值或函数 如果(返回)值为真，为此属性添加 <code>required</code> 验证器</li><li><code>ObjectIds</code> 要指定类型为 ObjectId，在声明中使用 <code>Schema.Types.ObjectId</code>。</li><li><code>unique</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ObjectId = mongoose.Schema.Types.ObjectId;</span><br><span class="line">var Car = new Schema(&#123; driver: ObjectId &#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>字符串类型专属</p><ol><li><code>enum</code> 字段值必须在这个枚举数组中</li><li><code>match</code></li><li><code>maxlength、minlength</code></li><li><code>lowercase、uppercase</code>保存之前所有字母都小/大写</li><li><code>trim</code>保存之前是否调用<code>trim()</code></li></ol></li><li><p>Number类型 / Date</p><ol><li><code>min max</code></li></ol></li></ul><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><blockquote><p>a connection equals a db</p></blockquote><ul><li><code>mongoose.connect(uri, options, callback)</code> 连接mongoDB，返回一个Promise<br>  options <pre><code>这些参数不传入底层MongoDB驱动：`dbName user pass autoIndex dbName`这些参数传入底层MongoDB驱动：        1. `autoReconnect` 连接丢失后是否自动重连        2. `ReconnectTries`：最大重连数        3. `ReconnectInterval`        4. `poolSize` 保持最大socket连接数</code></pre></li><li><code>createConnection(uri,options)</code> 返回一个映射到指定数据库的连接</li><li><code>dropDatabase()</code></li><li><code>createCollection(name, options?, callback?)</code></li><li><code>dropCollection(name, calllback?)</code></li></ul><h4 id="Model的一些方法"><a href="#Model的一些方法" class="headerlink" title="Model的一些方法"></a>Model的一些方法</h4><ul><li>通过mongoose.model(modelName, schema)创建的对象的方法</li></ul><ol><li><code>stuModel.create(doc(s), (err, docs) =&gt; {})</code> 创建一个或多个文档并添加到数据库中</li><li><code>find(conditions[, projections[, options[, callback]]])</code><br> <code>findById(id[, projections[, options[, callback]]])</code><br> <code>findOne([conditions[, projections[, options[, callback]]]])</code><pre><code>`conditions` 查询条件`projections` 查询字段 字符串(不要则加前缀`-`)或对象(0/1)`options` 选项(skip(省略/跳过n个) limit(数量限制))`callback(err, doc(s))` 通过回调函数获取查询结果</code></pre> 返回值是一个<code>Document</code>对象，该对象是<code>Model</code>的实例对象</li><li><code>update(conditions, doc[, options],callback)</code><br> <code>updateOne</code> <code>updateMany</code> <code>replaceOne</code><pre><code>`doc`修改后的对象`options` 选项(`multi`)`callback(err)`</code></pre></li><li><code>remove(condition, callback)</code><br> <code>deleteOne</code> <code>deleteMany()</code></li><li><code>count(condition, callback)</code><pre><code>`callbac(err, count)`</code></pre><ol start="6"><li><code>where(name)</code> 返回一个<strong>Query对象</strong><pre><code>`where(&apos;age&apos;).gte(21).lte(65).exec(callback)`等同于 `find({ age: {$gte: 21},$lte: 65 }, callback)`其他规则![Alt text](./1570791811101.png)</code></pre></li></ol></li></ol><ul><li>document(Model的实例) 通过Model查询到的结果</li></ul><ol><li><code>new StuModel({name:&#39;tr&#39;})</code>创建一个<code>Document</code>对象</li><li><code>doc.save([options, ]callback)</code> 将<code>doc</code>保存至数据库</li><li><code>doc.update(update, options, callback)</code> 修改<code>doc</code><pre><code>== `doc.age = 18; doc.save()`</code></pre></li><li><code>remove(callback)</code> 在数据库中删除<code>doc</code>对象 </li><li><code>get(name)</code> 获取文档的某属性值(可以直接<code>.</code>)<br>  <code>set</code> 设置文档的某属性值(可以直接<code>.</code>)</li><li><code>id</code>   <code>_id</code> 获取<code>_id</code>属性</li><li><code>toJSON()</code></li><li><code>toObject()</code></li></ol><h4 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h4><ul><li>验证定义于 <code>SchemaType</code></li><li>验证是一个<strong>中间件</strong>。它默认作为 <code>pre(&#39;save&#39;)</code> 钩子注册在 <code>schema</code> 上</li><li>可以使用 <code>doc.validate(callback)</code> 或 <code>doc.validateSync()</code> 手动验证</li></ul><h3 id="node连接mysql"><a href="#node连接mysql" class="headerlink" title="node连接mysql"></a>node连接mysql</h3><ol><li><p><code>createCnnection()</code></p></li><li><p><code>connect</code></p></li><li><p><code>query()</code></p></li><li><p><code>end()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var mysql      = require(&apos;mysql&apos;);</span><br><span class="line">var connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : &apos;localhost&apos;,</span><br><span class="line">  user     : &apos;me&apos;,</span><br><span class="line">  password : &apos;secret&apos;,</span><br><span class="line">  database : &apos;my_db&apos;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  console.log(&apos;The solution is: &apos;, results[0].solution);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure></li><li><p><code>createPool()</code></p></li><li><p><code>getConnection()</code></p></li><li><p><code>query()</code></p></li><li><p><code>release()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//连接池</span><br><span class="line">var mysql = require(&apos;mysql&apos;);</span><br><span class="line">var pool  = mysql.createPool(&#123;</span><br><span class="line">  connectionLimit : 10,</span><br><span class="line">  host            : &apos;example.org&apos;,</span><br><span class="line">  user            : &apos;bob&apos;,</span><br><span class="line">  password        : &apos;secret&apos;,</span><br><span class="line">  database        : &apos;my_db&apos;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> pool.getConnection((err, conn)=&gt;&#123;</span><br><span class="line">pool.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  conn.release();</span><br><span class="line">  console.log(&apos;The solution is: &apos;, results[0].solution);</span><br><span class="line">&#125;);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;MongoDB是一个基于分布式文件存储的数据库，由&lt;code&gt;c++&lt;/code&gt;语言编
      
    
    </summary>
    
    
    
      <category term="mongodb" scheme="https://turing5467.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Express框架</title>
    <link href="https://turing5467.github.io/2019/10/10/node/Express/"/>
    <id>https://turing5467.github.io/2019/10/10/node/Express/</id>
    <published>2019-10-09T16:00:00.000Z</published>
    <updated>2019-10-25T03:05:10.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><ul><li><strong>Express</strong> 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用,和丰富的 HTTP 工具。</li><li>核心概念：<strong>路由</strong>、<strong>中间件</strong>、<strong>模板引擎</strong></li><li>API <a href="https://www.runoob.com/w3cnote/express-4-x-api.html" target="_blank" rel="noopener">express</a><blockquote><p>可通过在命令行输入<code>curl localhost:3000</code>来测试路由<br>真实开发发请求使用 <code>axios</code>库</p></blockquote></li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li><p>三个重要の匹配路由方法</p><ol><li><p><code>app.use()</code> 不限定请求方式，路径模糊匹配</p></li><li><p><code>app.Method()</code> 只能是特定请求，路径严格匹配</p></li><li><p><code>app.all()</code> 不限定请求方式，但是路径要求严格匹配</p><p>这3个方法参数都可以是<code>path, callback [, callback ...]</code></p></li></ol><ul><li><p>路由分类</p><ul><li><p>字符串类型</p></li><li><p>字符串模式类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># * 匹配任意字符</span><br><span class="line"># ? 匹配一个或0个</span><br><span class="line"># + 匹配1个及以上</span><br><span class="line"># () 表示一串字符</span><br></pre></td></tr></table></figure></li><li><p>正则表达式类型</p></li><li><p>参数类型<code>/path/:uid</code> 可通过<code>req.params</code>获取</p></li></ul></li></ul><blockquote><p> 当一个路径有多个匹配规则时，使用<code>app.use()</code>，否则使用相应的<code>app.Method()</code></p></blockquote></li><li><p>路由拆分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/list'</span>, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/detail'</span>, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/user'</span>, router);</span><br></pre></td></tr></table></figure></li><li><p>静态资源文件托管</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"><span class="comment">//浏览器中便可通过127.0.0.1：3000/a.css访问/public/a.css</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'static'</span>,express.static(<span class="string">'public'</span>));</span><br><span class="line"><span class="comment">//浏览器中便可通过127.0.0.1：3000/static/a.css 访问 /public/a.css</span></span><br></pre></td></tr></table></figure></li><li><p>跨域配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放在匹配路由的最前面</span></span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type,Content-Length, Authorization, Accept,X-Requested-With"</span>);</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Methods"</span>,<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">    res.header(<span class="string">"X-Powered-By"</span>,<span class="string">' 3.2.1'</span>)</span><br><span class="line">    <span class="keyword">if</span>(req.method==<span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">      res.send(<span class="number">200</span>);<span class="comment">/*让options请求快速返回*/</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h3 id="快速搭建-express"><a href="#快速搭建-express" class="headerlink" title="快速搭建 express"></a>快速搭建 express</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装express脚手架</span></span><br><span class="line">npm install -g express-generator@4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">express 项目目录 &amp;&amp; <span class="built_in">cd</span> 项目目录</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启服务</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Express&quot;&gt;&lt;a href=&quot;#Express&quot; class=&quot;headerlink&quot; title=&quot;Express&quot;&gt;&lt;/a&gt;Express&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Express&lt;/strong&gt; 是一个简洁而灵活的 node.js W
      
    
    </summary>
    
    
    
      <category term="Express" scheme="https://turing5467.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Node中的event loop</title>
    <link href="https://turing5467.github.io/2019/10/09/node/Nodejs%E7%9A%84eventLoop/"/>
    <id>https://turing5467.github.io/2019/10/09/node/Nodejs的eventLoop/</id>
    <published>2019-10-08T16:00:00.000Z</published>
    <updated>2019-10-15T08:19:39.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Event Loop</code>即事件循环，是指浏览器或<code>Node</code>的一种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</li><li></li></ul><h3 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h3><p>执行机制参考这一篇文章，这里不再赘述<a href="https://www.npmjs.com/package/npmjs.org" target="_blank" rel="noopener">执行机制</a></p><p>两张核心图</p><p>​    <img src="https://user-gold-cdn.xitu.io/2019/1/18/1685f037d48da0de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 67%;"></p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1570799625780" style="zoom: 50%;"><ol><li>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。<ul><li>常见的 macro-task：<code>setTimeout</code>、<code>setInterval</code>、<code>script</code>、 <code>I/O</code> 操作、<code>UI 渲染</code>等。</li><li>常见的 micro-task:  <code>promise.then</code>、<code>MutationObserver</code>(html5新特性) 等。</li></ul></li></ol><h3 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h3><ul><li><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的<code>libuv</code></p></li><li><p>libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p></li><li><p>运行机制</p><ol><li>V8引擎解析js脚本</li><li>解析后的代码，调用Node API</li><li><code>libuv</code>库负责Node API 的执行。它将不同的任务分配给不同的线程，形成一个<strong>Event Loop</strong>（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ol></li><li><p>六个阶段</p><blockquote><p>libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p></blockquote><ol><li><strong>timer</strong>: 执行<code>setTimeout</code>、<code>setInterval</code>的回调</li><li><strong>I/O callback</strong>：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li><strong>idel、prepare</strong>：仅node内部使用</li><li><strong>poll</strong>：获取新的I/O事件, 适当的条件下node将阻塞在这里</li><li><strong>check</strong>：<code>setImmediate</code>的回调</li><li><strong>close callback</strong>：执行socket的close事件回调</li></ol></li></ul><img src="https://user-gold-cdn.xitu.io/2019/1/12/16841bd9860c1ee9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"><p>从上图中，大致看出node中的事件循环的顺序：</p><p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p><ul><li><p>1-timer</p><blockquote><p>timers 阶段会执行<code>setTimeout</code> 和 <code>setInterval</code> 回调，并且是由 <strong>poll</strong> 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p></blockquote></li><li><p>2-poll</p><ul><li><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><ul><li><p>回到 <strong>timer</strong> 阶段执行回调</p></li><li><p>执行 I/O 回调<br>该阶段如果没有设定了 timer 的话，会发生以下两件事情</p><ul><li>如果 <strong>poll</strong> 队列不为空，会遍历回调队列并<strong>同步</strong>执行，直到队列为空或者达到系统限制</li><li>如果 <strong>poll</strong> 队列为空时，会有两件事发生<ul><li>如果有 <code>setImmediate</code> 回调需要执行，poll 阶段会停止并且进入到 <strong>check</strong> 阶段执行回调</li><li>如果没有 <code>setImmediate</code> 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p></li></ul></li></ul></li><li><p>3-check</p><ul><li><code>setImmediate</code>的回调</li></ul></li></ul><h3 id="Node中的宏任务与微任务"><a href="#Node中的宏任务与微任务" class="headerlink" title="Node中的宏任务与微任务"></a>Node中的宏任务与微任务</h3><ul><li>常见的 macro-task ：<code>setTiumeout</code>、<code>setInterval</code>、 <code>setImmediate</code>、<code>script</code>、 I/O 操作等。</li><li>常见的 micro-task：<code>process.nextTick</code> 、<code>promise.then()</code> 、<code>MutationObserver</code>等。</li></ul><blockquote><p>setImmediate 设计在poll<strong>阶段完成时执行</strong>，即<strong>check</strong>阶段；</p><p>setTimeout 设计在poll阶段为<strong>空闲</strong>时，且设定<strong><em>\</em>时间到达**</strong>后执行，但它在<strong>timer</strong>阶段执行</p></blockquote><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><ul><li>这个函数独立于 Event Loop 之外的，它有一个自己的队列</li><li>当<strong>每个阶段</strong>完成后，如果存在 <code>nextTick</code> 队列，就会执行队列中的<strong>所有</strong>回调函数，并且<strong>优先</strong>于其他<strong>microtask</strong> 执行。</li></ul><h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><ul><li><p>浏览器，<strong>每个宏任务</strong>执行完之后都会执行<strong>microtask</strong>队列中的所有函数。</p></li><li><p>Node.js中，<strong>每一个阶段</strong>执行完毕，就会去执行<strong>microtask</strong>队列的任务。</p><p>注：node11版本中，一个宏任务执行完毕，就立刻执行微任务队列，这就跟浏览器端运行一致</p></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li>参考文章：<a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">掘金</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Event Loop&lt;/code&gt;即事件循环，是指浏览器或&lt;code&gt;Node&lt;/code&gt;的一种解决&lt;code&gt;j
      
    
    </summary>
    
    
    
      <category term="Nodejs" scheme="https://turing5467.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs入门</title>
    <link href="https://turing5467.github.io/2019/10/08/node/Nodejs/"/>
    <id>https://turing5467.github.io/2019/10/08/node/Nodejs/</id>
    <published>2019-10-07T16:00:00.000Z</published>
    <updated>2019-10-15T07:15:43.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><blockquote><p>Node.js<code>是一个基于Chrome V8引擎的javascript运行环境，是服务器端的javascript解释器。</code>Node.js` 使用<strong>事件驱动</strong>， <strong>非阻塞I/O模型(异步)</strong>而得以轻量和高效，非常适合在<strong>分布式</strong>设备上运行<strong>数据密集型</strong>的实时应用。</p></blockquote><blockquote><p>Nodejs没有根目录的概念，因为它没有任何的Web容器<br>URL和真实物理文件，是没有关系的。URL是通过Node的顶层路由设计，呈递某一个静态文件的</p></blockquote><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><blockquote><p>npm是世界上最大的开源库生态系统</p><p>能够解决各种包依赖之间的关系</p></blockquote><ul><li>npm 由三个独立的部分组成：</li></ul><ol><li>npm官方网站（仓库源）<a href="https://www.npmjs.com/package/npmjs.org" target="_blank" rel="noopener">npmjs官网</a></li><li>注册表（registry）（<code>package.json</code>)</li><li>命令行工具 (<code>CLI</code>)</li></ol><h3 id="node与js的关系"><a href="#node与js的关系" class="headerlink" title="node与js的关系"></a>node与js的关系</h3><blockquote><p>JavaScript：ECMA + DOM + BOM</p><p>Node.js：ECMA  +  &lt;文件系统 模块 包 操作系统API 网络通信等功能&gt;</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>官方下载安装包链接： <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs官网</a><br> <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">详细教程</a></li><li>单独更新 npm: <code>npm install npm@latest -g</code>或<code>npm install npm@next -g</code></li><li><code>node -v</code> 或 <code>npm -v</code> 获取版本信息，可证明<code>node/npm</code>是否安装成功</li><li><code>npm version</code>获取详细信息</li></ul><h3 id="npm-基本命令"><a href="#npm-基本命令" class="headerlink" title="npm 基本命令"></a>npm 基本命令</h3><ol><li><p><code>npm init -y</code> 在项目中引导创建一个<code>package.json</code></p></li><li><p><code>npm i/install 模块名</code> 本地安装模块</p><p>​            如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，可以选择本地安装</p><p><code>npm i 模块名 -g</code> 全局安装（安装路径为之前设置的<code>prefix</code>字段）</p><p>​            如果要将包作为一个<strong>命令行</strong>工具，（比如 <code>webpack</code>、<code>typescript</code>）可以选择全局安装</p><blockquote><p><code>npm i -save 模块名</code> 将模块安装到项目目录下，并在package文件的<code>dependencies</code>节点写入依赖。</p><pre><code>**生产阶段**的依赖，上线后仍然需要,如`jQuery、axios`等</code></pre><p><code>npm i -save-dev 模块名</code> 将模块安装到项目目录下，并在package文件的<code>devDependencies</code>节点写入依赖。</p><pre><code>**开发阶段**的依赖,只在开发阶段起作用,如`webpack`</code></pre></blockquote></li><li><p><code>update</code> 更新</p></li><li><p><code>remove</code> 删除</p></li><li><p><code>search</code> 搜索</p></li><li><p><code>run</code> 运行<code>package.json</code>中的script字段的指定代码</p></li></ol><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><blockquote><p>在Node中，每个js文件都是一个模块</p><p>因此，没有全局作用域，只有模块作用域</p></blockquote><ul><li><p>在Node中，每个模块内部都有一个自己的<code>module</code>对象，该对象有一个成员叫做<code>exports</code></p></li><li><p>谁<code>require</code>了该模块，就会得到该模块的<code>module.exports</code>对象</p><p>即: 默认模块的最后有一句<code>return module.exports</code></p></li><li><p>为了方便导出,<code>exports</code>和<code>module.exports</code>默认指向同一个对象，但<code>exports</code>的指向可被修改，最终返回的是<code>module.exports</code></p></li><li><p>使用:<br>  导出多个成员 <code>exports.xx = xx</code>或 <code>mdule.exports = {}</code><br>  导出单个成员 <code>module.exports = xx;</code></p></li></ul><ul><li>除了<code>require</code>、<code>module</code>、<code>exports</code>，每个文件还有以下两个属性</li></ul><ol><li><code>__dirname</code> 动态获取当前文件所属目录的<strong>绝对路径</strong></li><li><code>__filename</code> 动态获取当前文件的<strong>绝对路径</strong></li></ol><blockquote><p><strong>文件</strong>路径中，<code>./</code>表示的是相对于执行node命令时所处的路径<br>因此在文件操作中，使用相对路径是不可靠的，于是，<code>__dirname</code>和<code>__filename</code>就派上用场，它们不受执行node命令位置的影响。通过<code>path.join(__dirname,&#39;a.txt&#39;)</code>能很好处理路径拼接<br>注：<strong>模块</strong>路径中的<code>./</code>始终相对于当前文件模块，与执行node命令的位置无关</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;headerlink&quot; title=&quot;Node.js&quot;&gt;&lt;/a&gt;Node.js&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Node.js&lt;code&gt;是一个基于Chrome V8引擎的javascr
      
    
    </summary>
    
    
    
      <category term="Nodejs" scheme="https://turing5467.github.io/tags/Nodejs/"/>
    
  </entry>
  
</feed>
