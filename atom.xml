<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>快乐的图小灵</title>
  
  <subtitle>用猛烈的孤独，开启你伟大的冒险</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://turing5467.github.io/"/>
  <updated>2020-06-24T04:34:11.205Z</updated>
  <id>https://turing5467.github.io/</id>
  
  <author>
    <name>turing5467</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React服务端渲染(SSR)(未完)</title>
    <link href="https://turing5467.github.io/2020/06/20/js%E6%A1%86%E6%9E%B6/react/React-SSR/"/>
    <id>https://turing5467.github.io/2020/06/20/js框架/react/React-SSR/</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2020-06-24T04:34:11.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><ul><li><p>为什么要服务端渲染？</p><p>在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在<strong>“白屏”等待</strong>。</p></li></ul><ol><li><p>首屏等待： </p><p>而<strong>服务端渲染</strong>所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以<strong>更快的看到渲染内容</strong> 。</p></li><li><p>SEO</p><p> SPA 模式对搜索引擎不够友好 </p></li></ol><ul><li><p>方案：</p><p> 第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 <code>SPA</code> 的效果和体验，还不影响<code>SEO</code> 效果，这就有点完美。 </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务端渲染&quot;&gt;&lt;a href=&quot;#服务端渲染&quot; class=&quot;headerlink&quot; title=&quot;服务端渲染&quot;&gt;&lt;/a&gt;服务端渲染&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么要服务端渲染？&lt;/p&gt;
&lt;p&gt;在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React-组件复用</title>
    <link href="https://turing5467.github.io/2020/06/14/js%E6%A1%86%E6%9E%B6/react/React-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/"/>
    <id>https://turing5467.github.io/2020/06/14/js框架/react/React-组件复用/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-14T13:26:17.108Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5cad39b3f265da03502b1c0a" target="_blank" rel="noopener">原文</a></p><h2 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h2><p>前端发展速度非常之快，页面和组件变得越来越复杂，如何更好的实现<code>状态逻辑复用</code>一直都是应用程序中重要的一部分，这直接关系着应用程序的质量以及维护的难易程度。</p><p>本文介绍了<code>React</code>采用的三种实现<code>状态逻辑复用</code>的技术，并分析了他们的实现原理、使用方法、实际应用以及如何选择使用他们。</p><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p> <code>Mixin</code>（混入）是一种通过扩展收集功能的方式，它本质上是<strong>将一个(或多个)对象的属性拷贝到另一个对象上</strong>面去 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LogMixin = &#123;</span><br><span class="line">  actionLog: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'action...'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  requestLog: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request...'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;  <span class="comment">/*..*/</span>  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Goods</span>(<span class="params"></span>) </span>&#123;  <span class="comment">/*..*/</span> &#125;</span><br><span class="line"></span><br><span class="line">_.extend(User.prototype, LogMixin);</span><br><span class="line">_.extend(Goods.prototype, LogMixin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">var</span> good = <span class="keyword">new</span> Goods();</span><br><span class="line">user.actionLog();</span><br><span class="line">good.requestLog();</span><br></pre></td></tr></table></figure><h4 id="React中应用Mixin"><a href="#React中应用Mixin" class="headerlink" title="React中应用Mixin"></a>React中应用Mixin</h4><p> <code>React</code>也提供了<code>Mixin</code>的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用<code>createClass</code>来创建<code>React</code>组件时才可以使用，因为在<code>React</code>组件的<code>es6</code>写法中它已经被废弃掉了。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LogMixin = &#123;</span><br><span class="line">  log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'log'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'out'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复用1</span></span><br><span class="line"><span class="keyword">var</span> User = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],   <span class="comment">//关键代码</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复用2</span></span><br><span class="line"><span class="keyword">var</span> Goods = React.createClass(&#123;</span><br><span class="line">  mixins: [LogMixin],</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>危害</p><ol><li><code>Mixin</code> 可能会相互<strong>依赖</strong>，相互<strong>耦合</strong>，不利于代码维护</li><li>不同的<code>Mixin</code>中的方法可能会<strong>相互冲突</strong></li><li><code>Mixin</code>非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li></ol></li><li><p><code>React</code>现在已经不再推荐使用<code>Mixin</code>来解决代码复用问题，因为<code>Mixin</code>带来的危害比他产生的价值还要巨大，并且<code>React</code>全面推荐使用<strong>高阶组件</strong>来替代它。 </p></li></ul><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><ul><li><p>Higher-Order-Component： 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 </p></li><li><p>实现方式</p><ol><li><p>属性代理： 函数返回一个我们自己定义的组件，然后在<code>render</code>中返回要包裹的组件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxyHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>可操作所有传入的<code>props</code></li><li>可操作组件的生命周期</li><li>可操作组件的<code>static</code>方法</li><li>获取<code>refs</code></li></ul></li><li><p>反向继承： 返回一个组件，继承原组件，在<code>render</code>中调用原组件的<code>render</code>。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可操作所有传入的<code>props</code></p></li><li><p>可操作组件的生命周期</p></li><li><p>可操作组件的<code>static</code>方法</p></li><li><p>获取<code>refs</code></p></li><li><p>可操作<code>state</code></p></li><li><p>可以渲染劫持</p></li></ul></li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testCPN.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">TestCPN</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        □被包裹组件□</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoc</span>(<span class="params">WrappedComponent</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">          <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"title"</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> function hoc2(WrappedComponent) &#123; </span></span><br><span class="line"><span class="xml">    return class extends WrappedComponent &#123;</span></span><br><span class="line"><span class="xml">        render() &#123;</span></span><br><span class="line">          return (&lt;div&gt;</span><br><span class="line">            &lt;div className="title"&gt;&#123;this.props.title&#125;&lt;/div&gt;</span><br><span class="line">            &#123;super.render()&#125;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default hoc(TestCPN)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APP.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &#123;<span class="comment">/*从这里传入属性*/</span>&#125;</span><br><span class="line">      &lt;TestCPN title=&#123;<span class="string">"tr"</span>&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>在<code>vue</code>中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而<code>React</code>中没有做这样的处理，在默认情况下，表单元素都是<code>非受控组件</code>。给表单元素绑定一个状态后，往往需要手动书写<code>onChange</code>方法来将其改写为<code>受控组件</code>，在表单元素非常多的情况下这些重复操作是非常痛苦的。</p><p>我们可以借助高阶组件来实现一个简单的双向绑定。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>高阶组件就是一个没有副作用的纯函数，各个高阶组件<strong>不会互相依赖耦合</strong></li><li>高阶组件也有可能造成冲突，但我们可以<strong>在遵守约定的情况下避免这些冲突</strong></li><li>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加<strong>不会为原组件增加负担</strong></li></ul><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul><li><code>HOC</code>需要在原组件上进行包裹或者嵌套，如果大量使用<code>HOC</code>，将会产生非常多的嵌套，这让调试变得非常困难。</li><li><code>HOC</code>可以劫持<code>props</code>，在不遵守约定的情况下也可能造成冲突。</li></ul><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><ul><li><code>Hooks</code>是<code>React v16.7.0-alpha</code>中加入的新特性。它可以让你在<code>class</code>以外使用<code>state</code>和其他<code>React</code>特性。 </li><li>可以同时解决<code>Mixin</code>和<code>HOC</code>带来的问题。 </li></ul><h3 id="RenderProps"><a href="#RenderProps" class="headerlink" title="RenderProps"></a>RenderProps</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cad39b3f265da03502b1c0a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;组件复用&quot;&gt;&lt;a href=&quot;#组件复用&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://turing5467.github.io/2020/06/12/js/%E7%AE%97%E6%B3%95/"/>
    <id>https://turing5467.github.io/2020/06/12/js/算法/</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2020-06-12T11:22:36.999Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="https://segmentfault.com/img/bVNIpc?w=554&h=337" alt="图片描述"> </p><h2 id="排序-升序"><a href="#排序-升序" class="headerlink" title="排序(升序)"></a>排序(升序)</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>原理：比较相邻的两个数，将值较大的数放右边，值较小的放左边</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化</li></ul><blockquote><p>冒泡排序总会执行(N-1)+(N-2)+(N-3)+..+2+1趟，但如果运行到当中某一趟时排序已经完成，那么后边的比较就都是多余的，为了避免这种情况：</p><p>​    我们增加一个flag，判断排序是否在中途就已经完成（即判断有无发生元素交换）.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// flag含义：如果某次循环中没有交换过元素，那么意味着排序已经完成</span></span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li>选取基准元素</li><li>比基准元素小的元素放到左边，大的放右边</li><li>在左右子数组中重复步骤一二，直到数组只剩下一个元素</li><li>向上逐级合并数组</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr          <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">const</span> pivot = arr.length / <span class="number">2</span> | <span class="number">0</span>        <span class="comment">//基准点</span></span><br><span class="line">    <span class="keyword">const</span> pivotValue = arr.splice(pivot, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> leftArr = []</span><br><span class="line">    <span class="keyword">const</span> rightArr = []</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        val &gt; pivotValue ? rightArr.push(val) : leftArr.push(val)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> [ ...quickSort(leftArr), pivotValue, ...quickSort(rightArr)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边这个快排只是让读者找找感觉，我们不能这样写快排，如果每次都开两个数组，会<strong>消耗很多内存空间</strong>，数据量大时可能造成<strong>内存溢出</strong>，我们要避免开新的内存空间，即原地完成排序</p><p>我们可以用元素交换来取代开新数组，在每一次分区的时候直接在原数组上交换元素，<strong>将小于基准数的元素挪到数组开头</strong>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个left和right代表分区后“新数组”的区间下标，因为这里没有新开数组，所以需要left/right来确认新数组的位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;          </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = left - <span class="number">1</span>                    <span class="comment">//pos“被置换的位置”，初始值-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;  </span><br><span class="line">            <span class="keyword">let</span> pivot = arr[right]            <span class="comment">//选取数组最后一位作为基准数，</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= pivot) &#123;             <span class="comment">//若小于等于基准数，pos++，并置换元素, 这里使用小于等于而不是小于, 其实是为了避免因为重复数据而进入死循环</span></span><br><span class="line">                pos++</span><br><span class="line">                <span class="keyword">let</span> temp = arr[pos]</span><br><span class="line">                arr[pos] = arr[i]</span><br><span class="line">                arr[i] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一趟排序完成后，pos位置即基准数的位置，以pos的位置分割数组</span></span><br><span class="line">        quickSort(arr, left, pos - <span class="number">1</span>)        </span><br><span class="line">        quickSort(arr, pos + <span class="number">1</span>, right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr      <span class="comment">//数组只包含1或0个元素时(即left&gt;=right)，递归终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">quickSort(arr, start, end)</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li><p>定义：在函数中调用自身函数</p></li><li><p>它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 </p></li><li><p>好处： 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大减少程序的代码量。 </p></li><li><p>缺点：</p><p>如果递归的次数特别多，那么调用栈将非常之大，最终可能超出调用栈的缓存大小而导致程序执行失败。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.trace()</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><ul><li>尾递归是一种递归的写法，可以避免不断的将函数压栈最终导致堆栈溢出。</li><li>通过设置一个累加参数，并且每一次都将当前的值累加上去，然后递归调用。 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 调用栈不再需要多次对<code>factorial</code>进行压栈处理，因为每一个递归调用都不在<strong>依赖</strong>于上一个递归调用的值。因此，空间的复杂度为o(1)而不是0(n)。 </p><ul><li>注意：尾递归不一定会将你的代码执行速度提高；相反，可能会变慢。不过，尾递归可以让你使用<strong>更少的内存</strong>，使你的递归函数更加安全 (前提是你要开启<code>harmony</code>模式)。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;img src=&quot;https://segmentfault.com/img/bVNIpc?w=554&amp;h=337&quot; alt=&quot;图片描述&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;排序-升序&quot;&gt;&lt;a href=&quot;#排序-升序&quot; class=&quot;headerlink&quot; title=&quot;排序
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Web安全（CSRF与XSS）</title>
    <link href="https://turing5467.github.io/2020/06/12/%E5%85%B6%E4%BB%96/Web%E5%AE%89%E5%85%A8/"/>
    <id>https://turing5467.github.io/2020/06/12/其他/Web安全/</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2020-06-14T16:16:11.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul><li><p>CSRF：跨站请求伪造（Cross-Site request forgery）</p></li><li><p>原理：攻击者盗用了你的身份，以你的名义发送原本合法的请求，但是却完成了攻击者所期望的一个操作。</p><p>如：以你的名义发送邮件、购买商品等</p></li><li><p>步骤</p><ol><li>受害者登录A站点，并保留了登录凭证（Cookie）。</li><li>攻击者诱导受害者访问了站点B。</li><li>站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。</li><li>站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li><li>站点A以受害者的名义执行了站点B的请求。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/5/15/16abb8d5ab69386f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。</p><p>2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，并不会去获取cookie信息(cookie有同源策略)</p><p>3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击)</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ol><li><p>Token验证（主流）</p><blockquote><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。 </p><ul><li>服务端给用户生成一个token，加密后传递给用户 </li><li>用户在提交请求时，需要携带这个token </li><li>服务端验证token是否正确</li></ul></blockquote></li><li><p>Referer（页面来源）验证（ <strong>并不安全，Referer可以被更改</strong> ）</p></li><li><p>cookie的samesite属性（存在兼容性问题）</p></li><li><p>添加验证码（体验不好）</p></li></ol><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li><p>XSS：跨域脚本攻击（Cross-site scripting）</p></li><li><p>XSS是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p></li></ul><ul><li>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</li></ul><h4 id="反射性XSS"><a href="#反射性XSS" class="headerlink" title="反射性XSS"></a>反射性XSS</h4><ul><li><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。 </p></li><li><p>步骤</p><ol><li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li><li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol></li><li><p>防范：对URL的查询参数进行转义后再输出到页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/welcome'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//对查询参数进行编码，避免反射型 XSS攻击</span></span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(req.query.type)&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><ul><li>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。</li></ul><blockquote><p> 在使用 <code>innerHTML</code>、<code>outerHTML</code>、<code>appendChild</code>、<code>document.write()</code>等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p></blockquote><ul><li><p>步骤</p><ol><li>攻击者构造出特殊数据，其中包含恶意代码。</li><li>用户浏览器执行了恶意代码。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol></li><li><p>防范（核心：对输入内容进行转义）</p><ol><li><p>对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p></li><li><p>非<code>url</code>，我们可以这样进行编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;apos;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><ul><li><p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。 </p></li><li><p>存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。 </p></li><li><p>步骤</p><ol><li><p>攻击者将恶意代码提交到目标网站的数据库中。</p></li><li><p>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</p></li><li><p>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</p></li><li><p>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p></li></ol></li><li><p>防范</p><ol><li>前端数据传递给服务器之前，先<strong>转义/过滤</strong>(防范不了抓包修改数据的情况)</li><li>服务器接收到数据，在存储到数据库之前，进行转义/过滤</li><li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li></ol></li></ul><h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p>除了谨慎的转义，我们还需要一些手段来防范XSS攻击</p><ol><li><p>Content Security Policy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端响应头?</span></span><br><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前端</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Security-Policy"</span> content=<span class="string">"form-action 'self';"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>对输入内容长度进行限制</p></li><li><p>输入内容限制</p></li><li><p>其他</p><ol><li>cookie的httpOnly</li><li>验证码</li></ol></li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>XSS是向页面注入脚本运行</p><p>CSRF是利用漏洞执行原网页接口，且必须用户登录网站</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web安全&quot;&gt;&lt;a href=&quot;#Web安全&quot; class=&quot;headerlink&quot; title=&quot;Web安全&quot;&gt;&lt;/a&gt;Web安全&lt;/h2&gt;&lt;h3 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://turing5467.github.io/2020/06/11/%E9%9D%A2%E8%AF%95/128/"/>
    <id>https://turing5467.github.io/2020/06/11/面试/128/</id>
    <published>2020-06-11T04:01:22.872Z</published>
    <updated>2020-06-11T04:56:04.818Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eb55ceb6fb9a0436748297d" target="_blank" rel="noopener">原文</a></p><h3 id="1-DIV-CSS布局的好处"><a href="#1-DIV-CSS布局的好处" class="headerlink" title="1. DIV+CSS布局的好处"></a>1. DIV+CSS布局的好处</h3><ol><li>代码精简，且结构与样式分离，易于维护</li><li>代码量减少了，减少了大量的带宽，页面加载更快，提升用户的体验</li><li>对SEO更加友好，且H5又新增了许多语义化标签更是如此</li><li>允许更多炫酷的页面效果，丰富了页面</li><li>符合W3C标准，保证网站不会因为网络应用的升级而被淘汰</li></ol><p>缺点: 不同浏览器对web标准默认值不同，所以更容易出现对浏览器的兼容性问题。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener"><code>Promise</code></a> 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的<code>then</code>方法和<code>catch、finally</code>方法会返回一个新的<code>Promise</code>所以可以允许我们链式调用，解决了传统的回调地狱问题。 </p><h3 id="Promise-all中如果有一个抛出异常了会如何处理"><a href="#Promise-all中如果有一个抛出异常了会如何处理" class="headerlink" title="Promise.all中如果有一个抛出异常了会如何处理"></a>Promise.all中如果有一个抛出异常了会如何处理</h3><p><code>all和race</code>传入的数组中如果有会抛出异常的异步任务，那么只有<strong>最先抛出的错误</strong>会被捕获，并且是被<code>then</code>的第二个参数或者后面的<code>catch</code>捕获；但并<strong>不会影响</strong>数组中其它的异步任务的执行。</p><h3 id="创建自定义事件的3种"><a href="#创建自定义事件的3种" class="headerlink" title="创建自定义事件的3种"></a>创建自定义事件的3种</h3><ol><li><p><code>Event</code></p></li><li><p><code>CustomEvent</code>可以传递参数</p></li><li><p><code>document.createEvent(type)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件名为'build'.</span></span><br><span class="line">event.initEvent(<span class="string">'build'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e.target matches elem</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发对象可以是任何元素或其他事件目标</span></span><br><span class="line">elem.dispatchEvent(event);</span><br></pre></td></tr></table></figure></li></ol><h3 id="所有的事件都有冒泡吗"><a href="#所有的事件都有冒泡吗" class="headerlink" title="所有的事件都有冒泡吗"></a>所有的事件都有冒泡吗</h3><p><img src="C:%5CUsers%5CAdministrator%5CDesktop%5Ctr%5CimgURL%5C%E5%86%92%E6%B3%A1.jpg" alt></p><h3 id="一句话描述一下this"><a href="#一句话描述一下this" class="headerlink" title="一句话描述一下this"></a>一句话描述一下this</h3><p>指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用</p><h3 id="CommonJS和ES6模块的区别"><a href="#CommonJS和ES6模块的区别" class="headerlink" title="CommonJS和ES6模块的区别"></a><a href="https://juejin.im/post/5eaacd175188256d4345ea3a" target="_blank" rel="noopener">CommonJS和ES6模块的区别</a></h3><ul><li>CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</li><li>CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li><li>CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li><li>且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li></ul><p>关于第一个差异，是因为CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><blockquote><p>模块的异步加载可以使用AMD或CMD规范</p></blockquote><h3 id="webpack中如何处理图片"><a href="#webpack中如何处理图片" class="headerlink" title="webpack中如何处理图片"></a>webpack中如何处理图片</h3><p>在<code>webpack</code>中有两种处理图片的<code>loader</code>：</p><ul><li><code>file-loader</code>：解决<code>CSS</code>等中引入图片的路径问题；(解决通过<code>url</code>,<code>import/require()</code>等引入图片的问题)</li><li><code>url-loader</code>：当图片小于设置的<code>limit</code>参数值时，<code>url-loader</code>将图片进行<code>base64</code>编码(当项目中有很多图片，通过<code>url-loader</code>进行<code>base64</code>编码后会减少<code>http</code>请求数量，提高性能)，大于limit参数值，则使用<code>file-loader</code>拷贝图片并输出到编译目录中；</li></ul><p>（详细使用可以查看这里：<a href="https://github.com/LinDaiDai/niubility-coding-js/blob/master/前端工程化/webpack/霖呆呆的webpack之路-loader篇.md#file-loader" target="_blank" rel="noopener">霖呆呆的webpack之路-loader篇</a>）</p><h3 id="在移动端中怎样初始化根元素的字体大小"><a href="#在移动端中怎样初始化根元素的字体大小" class="headerlink" title="在移动端中怎样初始化根元素的字体大小"></a>在移动端中怎样初始化根元素的字体大小</h3><p>一个简易版的初始化根元素字体大小。</p><p>页面开头处引入下面这段代码，用于动态计算<code>font-size</code>：(假设你需要的<code>1rem = 20px</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onWindowResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取html的宽度(窗口的宽度)</span></span><br><span class="line">    html.style.fontSize = html.getBoundingClientRect().width / <span class="number">20</span> + <span class="string">'px'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, onWindowResize);</span><br><span class="line">  onWindowResize();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一般还需要配合一个<code>meta</code>头：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="animation有一个steps-功能符知道吗？"><a href="#animation有一个steps-功能符知道吗？" class="headerlink" title="animation有一个steps()功能符知道吗？"></a>animation有一个steps()功能符知道吗？</h3><p>一句话介绍：<code>steps()</code>功能符可以<strong>让动画不连续。</strong></p><p>地位和作用：和贝塞尔曲线(<code>cubic-bezier()</code>修饰符)一样，都可以作为<code>animation</code>的第三个属性值。</p><p>和贝塞尔曲线的区别：贝塞尔曲线像是滑梯且有4个关键字(参数)，而<code>steps</code>像是楼梯坡道且只有<code>number</code>和<code>position</code>两个关键字。</p><p>语法：<code>steps(number, position)</code></p><ul><li><p>number: 数值，表示把动画分成了多少段</p></li><li><p>position: 表示动画是从时间段的开头连续还是末尾连续。支持<code>start</code>和<code>and</code></p><p>两个关键字，含义分别如下： </p><ul><li><code>start</code>：表示直接开始。</li><li><code>end</code>：表示戛然而止。是默认值。</li></ul></li></ul><p>具体可以看这里：<a href="https://www.zhangxinxu.com/wordpress/2018/06/css3-animation-steps-step-start-end/" target="_blank" rel="noopener">www.zhangxinxu.com/wordpress/2…</a></p><h3 id="在项目中如何把http的请求换成https"><a href="#在项目中如何把http的请求换成https" class="headerlink" title="在项目中如何把http的请求换成https"></a>在项目中如何把http的请求换成https</h3><p>由于我在项目中是会对<code>axios</code>做一层封装，所以每次请求的域名也是写在配置文件中，有一个<code>baseURL</code>字段专门用于存储它，所以只要改这个字段就可以达到替换所有请求<code>http</code>为<code>https</code>了。</p><p>当然后面我也有了解到：</p><p>利用<code>meta</code>标签把<code>http</code>请求换为<code>https</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span> =<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"upgrade-insecure-requests"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eb55ceb6fb9a0436748297d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-DIV-CSS布局的好处&quot;&gt;&lt;a href=&quot;#1-D
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React-Hooks</title>
    <link href="https://turing5467.github.io/2020/06/09/js%E6%A1%86%E6%9E%B6/react/React-Hooks/"/>
    <id>https://turing5467.github.io/2020/06/09/js框架/react/React-Hooks/</id>
    <published>2020-06-08T16:00:00.000Z</published>
    <updated>2020-06-19T05:37:28.910Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d" target="_blank" rel="noopener">引用文章1</a></p><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><ul><li>Hooks 是 React 16.8 新增的特性，它可以让你在<strong>不编写 class</strong> 的情况下<strong>使用 state 以及其他的 React 特性(如生命周期)</strong> </li></ul><h3 id="Hooks解决的问题"><a href="#Hooks解决的问题" class="headerlink" title="Hooks解决的问题"></a>Hooks解决的问题</h3><h4 id="1-类组件的的不足"><a href="#1-类组件的的不足" class="headerlink" title="1.类组件的的不足"></a>1.类组件的的不足</h4><ul><li><p><strong>状态逻辑难复用</strong></p><p>在组件之间复用状态逻辑很难，可能要用到 <strong>render props</strong> （<strong>渲染属性</strong>）或者 <strong>HOC</strong>（<strong>高阶组件</strong>），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），<strong>导致层级冗余</strong> </p></li><li><p><strong>趋向复杂难以维护</strong></p><ul><li>在生命周期函数中混杂不相干的逻辑（如：在 <code>componentDidMount</code> 中注册事件以及其他的逻辑，在 <code>componentWillUnmount</code> 中卸载事件，这样分散不集中的写法，很容易写出 bug ）</li><li>组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件</li></ul></li><li><p><strong>this指向问题</strong></p><ul><li>父组件给子组件传递函数时，必须绑定 this </li><li>react 中的组件四种绑定 this 方法的区别 （ 前提：子组件内部做了性能优化）<ul><li><strong>构造函数中绑定 this</strong>：那么每次父组件刷新的时候，如果传递给子组件其他的 <code>props 值不变</code>，那么子组件就不会刷新；</li><li><strong>在 render() 函数里面绑定 this</strong>：因为 <strong>bind 函数会返回一个新的函数</strong>，所以每次父组件刷新时，<code>都会重新生成</code>一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新</li><li><strong>使用箭头函数</strong>：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件<code>每次都会刷新</code></li><li><strong>使用类的静态属性：原理和第一种方法差不多，比第一种更简洁</strong></li></ul></li></ul></li></ul><h4 id="2-Hooks优势"><a href="#2-Hooks优势" class="headerlink" title="2.Hooks优势"></a>2.Hooks优势</h4><ul><li>能优化类组件的三大问题 </li><li>能在无需修改组件结构的情况下<strong>复用状态逻辑</strong>：使用自定义 Hooks </li><li>能将组件中相互关联的部分拆分成更小的函数（如订阅、请求数据） ：<code>useEffect</code></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614215115698.png" alt="image-20200614215115698"></p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul><li>多次调用<code>useState</code>，渲染时调用顺序不变</li><li>重复渲染时保留<code>state</code></li><li>参数为初始<code>state</code></li><li>返回值为一个数组<ol><li>第一项为返回的<code>state</code></li><li>第二项为更新<code>state</code>的函数，不会合并新旧<code>state</code>，而是直接替换</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里可以任意命名，因为返回的是数组，数组解构</span></span><br><span class="line"><span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="每次渲染都是独立的闭包"><a href="#每次渲染都是独立的闭包" class="headerlink" title="每次渲染都是独立的闭包"></a>每次渲染都是独立的闭包</h4><ul><li>每一次渲染都有它自己的 Props 和 State</li><li>每一次渲染都有它自己的事件处理函数</li><li>当点击更新状态的时候，函数组件都会重新被调用，那么每次渲染都是独立的，取到的值不会受后面操作的影响。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">TestCPN</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">alertNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// alert 只能获取到点击按钮时的那个状态</span></span><br><span class="line">        alert(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;alertNumber&#125;&gt;alertNumber&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击alertNumber =&gt;  (即使中间点击过+号)  =&gt; 弹出的值就是一开始的0</p><h4 id="函数式更新"><a href="#函数式更新" class="headerlink" title="函数式更新"></a>函数式更新</h4><ul><li>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将回调函数传递给 setState的参数。该回调函数将接收先前的 state，并返回一个更新后的值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 这样每次执行时都会去获取一遍 state，而不是使用点击触发时的那个 state</span></span><br><span class="line">            setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">           &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">           &lt;button onClick=&#123;()=&gt;setNumber(number+1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">           &lt;button onClick=&#123;lazy&#125;&gt;lazy&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击lazy  =&gt; (期间点击+号) =&gt; 3秒后的number为多次点击+号后的结果</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ul><li><p>effect(副作用)：指那些没有发生在数据向视图转换过程中的逻辑，如<code>ajax</code>请求，访问原生<code>dom</code>元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志。</p></li><li><p>副作用可分为两类：需要清除的、不需要清楚的</p></li><li><p><code>useEffect</code>就是一个effect Hook，给函数组件增加了操作副作用的能力。</p></li><li><p>它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API 。</p><p>与 <code>componentDidMount</code> 或 <code>didUpdate</code> 不同， <code>useEffect</code> 不会阻塞浏览器更新屏幕，这让你的应用看起来<strong>响应更快</strong>。 </p></li><li><p><code>useEffect</code><strong>接收一个函数</strong>，该函数会<strong>在组件渲染后才执行</strong>，该函数有要求：要么<strong>返回一个能清除副作用的函数</strong>，要么就<strong>不返回任何内容</strong></p></li></ul><h4 id="清除副作用"><a href="#清除副作用" class="headerlink" title="清除副作用"></a>清除副作用</h4><ul><li>可以通过给<code>useEffect</code>返回一个函数来指定如何清除副作用， 为防止内存泄漏，清除函数会在在组件卸载前执行</li><li>如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useEffect, useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> [text,setText] = useState(<span class="string">''</span>);</span><br><span class="line">    <span class="comment">// 相当于componentDidMount 和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'开启一个新的定时器'</span>)</span><br><span class="line">        <span class="keyword">let</span> $timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用</span></span><br><span class="line">        <span class="comment">// useEffect 在执行副作用函数之前，会先调用上一次返回的函数</span></span><br><span class="line">        <span class="comment">// 清除副作用: 返回一个清除副作用的函数</span></span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'destroy effect'</span>);</span><br><span class="line">            clearInterval($timer);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;input value=&#123;text&#125; onChange=&#123;(event)=&gt;setText(event.target.value)&#125;/&gt;</span><br><span class="line">          &lt;p&gt;&#123;number&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button&gt;+&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 通过使用 Hook，你可以把组件内<strong>相关的副作用</strong>组织在一起（例如创建订阅及取消订阅），而不要把它们拆分到不同的生命周期函数里。 </p></blockquote><h4 id="跳过effect进行性能优化"><a href="#跳过effect进行性能优化" class="headerlink" title="跳过effect进行性能优化"></a>跳过effect进行性能优化</h4><ul><li>依赖项数组控制着useEffect的执行</li><li>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用：传递数组作为 <code>useEffect</code>的第二个可选参数即可 </li><li>如果想执行<strong>只运行一次的 effect</strong>（仅在组件挂载和卸载时执行），可以传递一个空数组<code>[]</code>作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 </li></ul><h4 id="使用多个Effect实现关注点分离"><a href="#使用多个Effect实现关注点分离" class="headerlink" title="使用多个Effect实现关注点分离"></a>使用多个Effect实现关注点分离</h4><ul><li>解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。 </li><li>例如 ：设置 <code>document.title</code> 的逻辑被分割到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 中，订阅逻辑又被分割到 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 中的，而<code>componentDidMount</code>中同时包含了两个不同功能的代码。这样会使<strong>生命周期函数变得混乱</strong></li><li><strong>Hook 允许我们按照代码的用途分离他们</strong> </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//设置document.title逻辑</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">          setIsOnline(status.isOnline);</span><br><span class="line">      &#125;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟ComponentDidUpdate"><a href="#模拟ComponentDidUpdate" class="headerlink" title="模拟ComponentDidUpdate"></a>模拟ComponentDidUpdate</h4><p> <code>componentDidUpdate</code>就相当于除去第一次调用的<code>useEffect</code>，我们可以借助<code>useRef</code>生成一个标识，来记录是否为第一次执行： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDidUpdate</span>(<span class="params">callback, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> init = useRef(<span class="literal">true</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (init.current) &#123;</span><br><span class="line">      init.current = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟ComponentDidMount"><a href="#模拟ComponentDidMount" class="headerlink" title="模拟ComponentDidMount"></a>模拟ComponentDidMount</h4><p><code>componentDidMount</code>等价于<code>useEffect</code>的回调仅在页面初始化完成后执行一次，当<code>useEffect</code>的第二个参数传入一个空数组时可以实现这个效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function useDidMount(callback) &#123;</span><br><span class="line">  useEffect(callback, []);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>官方不推荐上面这种写法，因为这有可能导致一些错误。</p></blockquote><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><p> <img src="https://user-gold-cdn.xitu.io/2019/11/1/16e25d2b5844206c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p><ul><li><p><code>useEffect</code>在全部渲染完毕后才会执行</p></li><li><p><code>useLayoutEffect</code>会在 浏览器 <code>layout</code>之后，<code>painting</code>之前执行</p></li><li><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect</p></li><li><p>可以使用它来读取 DOM 布局并<strong>同步触发重渲染</strong></p></li><li><p>在浏览器执行绘制之前 <code>useLayoutEffect</code>内部的更新计划将被<strong>同步</strong>刷新</p></li><li><p><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useLayoutEffect,useEffect, useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">LayoutEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [color, setColor] = useState(<span class="string">'red'</span>);</span><br><span class="line">    useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        alert(color);</span><br><span class="line">    &#125;);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'color'</span>, color);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div id=<span class="string">"myDiv"</span> style=&#123;&#123; <span class="attr">background</span>: color &#125;&#125;&gt;颜色&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setColor('red')&#125;&gt;红&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setColor(<span class="string">'yellow'</span>)&#125;&gt;黄&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setColor('blue')&#125;&gt;蓝&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span>*</span><br><span class="line">alert(<span class="string">'red'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'red'</span>)</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h4 id="惰性初始化state"><a href="#惰性初始化state" class="headerlink" title="惰性初始化state"></a>惰性初始化state</h4><ul><li><code>initialState</code>参数只会在组件的<strong>初始化渲染</strong>中起作用，后续渲染时会被忽略</li><li>如果初始 state 需要通过复杂计算获得，则可以<strong>传入一个函数</strong>，在函数中计算并返回初始的 state，此函数只在<strong>初始渲染</strong>时被调用</li></ul><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><ul><li><p>接收一个 <code>context</code>对象（<code>React.createContext</code> 的返回值）并返回该 <code>context</code></p></li><li><p>当前的 <code>context</code>值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code>决定</p></li><li><p>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染</p></li><li><p><code>useContext(MyContext)</code> 相当于 class 组件中的  <code>&lt;MyContext.Consumer&gt;</code></p></li><li><p><code>useContext(MyContext)</code> 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用  来为下层组件提供 context</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button style=&#123;&#123; <span class="attr">background</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Toolbar /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><ul><li><code>useReducer</code>和 redux 中的 reducer 很像</li><li><code>useState</code>内部就是靠 <code>useReducer</code>来实现的</li><li><code>useState</code>的替代方案，它接收一个形如 <code>(state, action) =&gt; newState</code>的 reducer，并返回当前的 <code>state</code>以及与其配套的 <code>dispatch</code>方法</li><li>在某些场景下，<code>useReducer</code>会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第一种传参方式：reducer, initialState</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值：initialState</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//第二种传参方式：(reducer, initFnParam, initFn)</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">&#123;<span class="comment">/* payload为额外参数，传入reducer.action */</span>&#125;</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="useMemo-amp-amp-useCallBack"><a href="#useMemo-amp-amp-useCallBack" class="headerlink" title="useMemo &amp;&amp; useCallBack"></a>useMemo &amp;&amp; useCallBack</h3><ul><li>默认情况，只要父组件状态变了（不管子组件依不依赖该状态），子组件也会重新渲染</li><li>优化<ol><li>类组件：可以使用<code>PureComponent</code></li><li>函数组件：使用<code>React.memo</code>， 将函数组件传递给 <code>memo</code> 之后，就会返回一个新的组件，新组件的功能：<strong>如果接受到的属性不变，则不重新渲染函数</strong>； </li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,memo, useMemo,useCallback&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCounter</span>(<span class="params">&#123;onClick,data&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'SubCounter render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;button onClick=&#123;onClick&#125;&gt;&#123;data.number&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/返回新组件：接收属性不变，则不重新渲染函数</span></span><br><span class="line"><span class="regexp">SubCounter = memo(SubCounter);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export  default  function Counter4()&#123;</span></span><br><span class="line"><span class="regexp">    console.log('Counter4 render');</span></span><br><span class="line"><span class="regexp">    const [name,setName]= useState('计数器');</span></span><br><span class="line"><span class="regexp">    const [number,setNumber] = useState(0);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/组件更新时，变量和函数每次都会重新创建，那么子组件接受到的属性每次都会认为是新的</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/因此需要使用useMemo：缓存&lt;变量&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/注意：必须传递第二个参数：依赖项数组，否则还是会重新渲染</span></span><br><span class="line"><span class="regexp">    const data =useMemo(() =&gt;(&#123;number&#125;), [number]);</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/useCallback: 缓存&lt;函数&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/注意：必须传递第二个参数：依赖项数组，否则还是会重新渲染</span></span><br><span class="line"><span class="regexp">    const addClick = useCallback(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">        setNumber(number+1);</span></span><br><span class="line"><span class="regexp">    &#125;, [number]);</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;input type="text" value=&#123;name&#125; onChange=&#123;(e)=&gt;setName(e.target.value)&#125;/</span>&gt;</span><br><span class="line">            &lt;SubCounter data=&#123;data&#125; onClick=&#123;addClick&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 你也可以通过给<code>React.memo</code>的第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。 </p></blockquote><blockquote><p>useCallback的依赖项如果时<code>空数组</code>只会在挂载阶段执行；</p><p>如果依赖项是一个<code>变化的值</code>，那么在依赖项变化的时候执行；</p><p>如果<code>不传</code>第二个参数，那么每次都会执行 </p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li><strong>类组件</strong>使用 <code>React.createRef</code>，<strong>函数组件</strong>使用 <code>useRef</code><ol><li>useRef 返回的 ref 对象在组件的<strong>整个生命周期内保持不变</strong>，也就是说每次重新渲染函数组件时，返回的ref 对象都是同一个</li><li>使用 <code>React.createRef</code>，每次重新渲染组件都会重新创建 ref</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现类似实例变量的东西"><a href="#实现类似实例变量的东西" class="headerlink" title="实现类似实例变量的东西"></a>实现类似实例变量的东西</h4><p> <code>useRef()</code> Hook 不仅可以用于 DOM refs。</p><p>「ref」 对象是一个 <code>current</code> 属性可变且可以容纳任意值的通用容器，类似于一个 class 的实例属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> intervalRef = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    intervalRef.current = timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearInterval(intervalRef.current);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何测量DOM节点"><a href="#如何测量DOM节点" class="headerlink" title="如何测量DOM节点"></a>如何测量DOM节点</h4><p> 获取 DOM 节点的位置或是大小的基本方式是使用 <a href="https://react.docschina.org/docs/refs-and-the-dom.html#callback-refs" target="_blank" rel="noopener">callback ref</a>。每当 ref 被附加到一个另一个节点，React 就会调用 callback。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MeasureExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [height, setHeight] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> measuredRef = useCallback(<span class="function"><span class="params">node</span> =&gt;</span> &#123;    </span><br><span class="line">      <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;     </span><br><span class="line">          setHeight(node.getBoundingClientRect().height);    </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 ref=&#123;measuredRef&#125;&gt;Hello, world&lt;<span class="regexp">/h1&gt;      </span></span><br><span class="line"><span class="regexp">  &lt;h2&gt;The above header is &#123;Math.round(height)&#125;px tall&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>  我们没有选择使用 <code>useRef</code>，因为当 ref 是一个对象时它并不会把当前 ref 的值的 <em>变化</em> 通知到我们。  使用 callback ref 可以确保 即便子组件延迟显示被测量的节点(比如为了响应一次点击)，我们依然能够在父组件接收到相关的信息，以便更新测量结果。 </p><p> 注意到我们传递了 <code>[]</code> 作为 <code>useCallback</code> 的依赖列表。这确保了 ref callback 不会在再次渲染时改变，因此 React 不会在非必要的时候调用它。 </p><h4 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h4><ul><li><strong>因为函数组件没有实例，所以函数组件无法像类组件一样可以接收 ref 属性</strong> ：<code>&lt;Child ref={xxx} /&gt;</code>是不行的</li><li>forwardRef 可以在父组件中操作<strong>子组件</strong>的 ref 对象</li><li>forwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props,ref</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> ref=&#123;ref&#125;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1（相较普通ref多的一步）</span></span><br><span class="line">Child = React.forwardRef(Child);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>); </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();<span class="comment">//&#123;current:''&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    inputRef.current.value = <span class="string">'focus'</span>;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      <span class="comment">/* 3 */</span></span><br><span class="line">        &lt;Child ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;setNumber(&#123;<span class="attr">number</span>:number+<span class="number">1</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><ul><li><code>useImperativeHandle</code>可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useRef,forwardRef,useImperativeHandle&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props, ref</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> focusRef = useRef();</span><br><span class="line">    <span class="keyword">let</span> inputRef = useRef();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父组件将要传进来的ref</span></span><br><span class="line">    useImperativeHandle(ref,()=&gt;&#123;</span><br><span class="line">      <span class="comment">// 这个函数会返回一个对象，作为父组件 current 属性的值</span></span><br><span class="line">      <span class="comment">// 通过这种方式，父组件可以使用操作子组件中的多个 ref</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            focusRef,</span><br><span class="line">            inputRef,</span><br><span class="line">            name:<span class="string">'计数器'</span>,</span><br><span class="line">            focus()&#123;</span><br><span class="line">                focusRef.current.focus();</span><br><span class="line">            &#125;,</span><br><span class="line">            changeText(text)&#123;</span><br><span class="line">                inputRef.current.value = text;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;input ref=&#123;focusRef&#125;/&gt;</span><br><span class="line">            &lt;input ref=&#123;inputRef&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Child = forwardRef(Child);</span></span><br><span class="line"><span class="regexp">export default function Parent()&#123;</span></span><br><span class="line"><span class="regexp">  const parentRef = useRef();/</span><span class="regexp">/&#123;current:''&#125;</span></span><br><span class="line"><span class="regexp">  function getFocus()&#123;</span></span><br><span class="line"><span class="regexp">    parentRef.current.focus();</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效，不注释会报错</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ parentRef.current.addNumber(666);</span></span><br><span class="line"><span class="regexp">    parentRef.current.changeText('&lt;script&gt;alert(1)&lt;/</span>script&gt;<span class="string">');</span></span><br><span class="line"><span class="string">    console.log(parentRef.current.name);//计数器</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">      &lt;&gt;</span></span><br><span class="line"><span class="string">        &lt;Child ref=&#123;parentRef&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h3><p>自定义 Hook 更像是一种约定，而不是一种功能。</p><p>如果函数的名字以 <code>use</code> 开头，并且<strong>调用了其他的 Hook</strong>，则就称其为一个<strong>自定义 Hook</strong></p><p>有时候我们会想要在组件之间<strong>重用一些状态逻辑</strong>，之前要么用 render props ，要么用高阶组件，要么使用 redux。自定义 Hook 可以让你在不增加组件的情况下达到同样的目的</p><blockquote><p> 每个组件调用同一个 hook，只是复用 hook 的状态逻辑，并<strong>不会共用一个状态</strong> 。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNumber</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setNumber(<span class="function"><span class="params">number</span>=&gt;</span>number+<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;,[]);</span><br><span class="line">  <span class="keyword">return</span> [number,setNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>只能在<strong>函数最外层</strong>调用 Hook 。不要在循环，条件或嵌套函数中调用Hook。 </p><p><code>Hook</code>通过数组实现的，每次<code>useState</code> 都会改变下标，<code>React</code>需要利用调用顺序来正确更新相应的状态，如果<code>useState</code> 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。 </p></li><li><p>只能在 <strong>React 的函数组件</strong>中调用 Hook。 （自定义Hook除外）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;引用文章1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;React-Hooks&quot;&gt;&lt;a href=&quot;#Rea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试题收集</title>
    <link href="https://turing5467.github.io/2020/06/07/%E9%9D%A2%E8%AF%95/5467/"/>
    <id>https://turing5467.github.io/2020/06/07/面试/5467/</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-06-22T10:11:44.290Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/qiu-deqing/FE-interview#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">1</a></p><h3 id="前端需要注意哪些-SEO"><a href="#前端需要注意哪些-SEO" class="headerlink" title="前端需要注意哪些 SEO"></a>前端需要注意哪些 SEO</h3><ol><li>合理的 title、description、keywords：搜索对着三项的权重逐个减小，<ul><li><code>title</code>值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；</li><li><code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；</li><li><code>keywords</code>列举出重要关键词即可</li></ul></li><li><strong>语义化</strong>的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li><li>少用 <code>iframe</code>：搜索引擎不会抓取 iframe 中的内容</li><li>非装饰性图片必须加 alt</li><li><strong>提高网站速度</strong>：网站速度是搜索引擎排序的一个重要指标</li></ol><h3 id="什么是-web-语义化-有什么好处"><a href="#什么是-web-语义化-有什么好处" class="headerlink" title="什么是 web 语义化,有什么好处"></a>什么是 web 语义化,有什么好处</h3><p>web 语义化是指通过 HTML 标记表示页面包含的信息，包含了 HTML 标签的语义化和 css 命名的语义化。 </p><p>HTML 标签的语义化：通过使用包含语义的标签（如 h1-h6）恰当地表示文档结构 </p><p>css 命名的语义化：为 html 标签添加有意义的 class，id 补充未表达的语义，如<a href="http://en.wikipedia.org/wiki/Microformats" target="_blank" rel="noopener">Microformat</a>通过添加符合规则的 class 描述信息 为什么需要语义化：</p><ul><li>去掉样式后页面呈现清晰的结构</li><li>无障碍阅读：盲人使用读屏器更好地阅读</li><li><strong>搜索引擎</strong>更好地理解页面，有利于收录</li><li>便团队项目的<strong>可持续运作及维护</strong></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1&guce_referrer=aHR0cHM6Ly9naXRodWIuY29tL3FpdS1kZXFpbmcvRkUtaW50ZXJ2aWV3&guce_referrer_sig=AQAAAGCBP4o39rOh6MQI2wJq1jnXE-fn4Y-QMWSTUxOygtHtjvtuqMQKvj-xBmfOVL-VkBlowdS8TuND8_KVv-KgiJoeZ_SSrgdv-O_vLk18Lypkbg-PnaKOwPOjXwh_XUJUHRK9qAVqTKQsBzdw4DwkcdtZ9pZcLq5jy9dbPCgyRvZ7" target="_blank" rel="noopener">雅虎性能优化</a></p><ul><li>content 方面<ol><li>减少 HTTP 请求：合并文件、CSS 精灵、inline Image</li><li>减少 DNS 查询：DNS 查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS 缓存、将资源分布到恰当数量的主机名，平衡并行下载和 DNS 查询</li><li>非必须组件延迟加载</li><li>减少 DOM 元素数量</li><li>避免空 src 的 img 标签</li></ol></li><li>Server 方面<ol><li>使用 CDN</li><li>添加 Expires 或者 Cache-Control 响应头</li><li>对组件使用 Gzip 压缩</li><li>配置 ETag</li></ol></li><li>Cookie 方面<ol><li>减小 cookie 大小</li></ol></li><li>css 方面<ol><li>将样式表放到页面顶部</li><li>不使用 CSS 表达式</li><li>使用<code>&lt;link&gt;</code>不使用@import</li><li>不使用 IE 的 Filter</li></ol></li><li>Javascript 方面<ol><li>将脚本放到页面底部</li><li>将 javascript 和 css 从外部引入</li><li>压缩 javascript 和 css</li><li>删除不需要的脚本</li><li>减少 DOM 访问</li></ol></li><li>图片方面<ol><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化 css 精灵</li><li>不要在 HTML 中拉伸图片</li><li>保证 favicon.ico 小并且可缓存</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/qiu-deqing/FE-interview#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Immutable</title>
    <link href="https://turing5467.github.io/2020/06/05/js/%E5%BA%93/Immutable/"/>
    <id>https://turing5467.github.io/2020/06/05/js/库/Immutable/</id>
    <published>2020-06-04T16:00:00.000Z</published>
    <updated>2020-06-05T13:03:01.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h2><p> 通过<code>Immutable</code>创建的<code>Immutable Data</code>一旦被创建，就不能再更改。对<code>Immutable</code>对象进行修改、添加或删除操作，都会返回一个新的<code>Immutable</code>对象。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Immutable&quot;&gt;&lt;a href=&quot;#Immutable&quot; class=&quot;headerlink&quot; title=&quot;Immutable&quot;&gt;&lt;/a&gt;Immutable&lt;/h2&gt;&lt;p&gt; 通过&lt;code&gt;Immutable&lt;/code&gt;创建的&lt;code&gt;Immutabl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端面试视频笔记</title>
    <link href="https://turing5467.github.io/2020/06/03/%E9%9D%A2%E8%AF%95/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://turing5467.github.io/2020/06/03/面试/视频笔记/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-06-14T16:22:46.084Z</updated>
    
    <content type="html"><![CDATA[<p>1</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603091751928.png" alt="image-20200603091751928"></p><p>2 3</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603091849574.png" alt="image-20200603091849574"></p><p>4</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603092023557.png" alt="image-20200603092023557"></p><h3 id="什么是面试"><a href="#什么是面试" class="headerlink" title="什么是面试"></a>什么是面试</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603092544423.png" alt="image-20200603092544423"></p><h3 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h3><ul><li><p>职业描述（JD）分析</p><p>通过分析决定该职位是否为我想要的/我能胜任的，之后，对所需要的技术做准备</p><p>根据JD对简历进行相应的修改</p></li><li><p>业务分析或实战模拟</p><p>去公司的网站看使用了什么技术 ，如Vue、Webpack、存储技术</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603101707355.png" alt="image-20200603101707355"></p><p>第一行：处理兼容性</p><p>第二行：使用双核浏览器时，优先使用哪个内核</p><p>三、四行：DNS预解析，可以做性能优化</p></li><li><p>技术栈准备</p><p>jQuery、Vue、React、node（源码、原理（看文章））</p><p>Less、Sass、Gulp、webpack、grunt、npm、browserify</p></li></ul><ul><li><p>自我介绍</p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200603103925701.png" alt="image-20200603103925701" style="zoom:67%;"><ol><li>把握面试的沟通方向（面试官会根据你说的来提问）</li><li>豁达、自信的适度发挥（声音清晰，自信）    </li></ol></li><li><p>实例</p><ol><li><p>适时讨疑问：</p><p>当面试官问到了一些 你还不会的问题，不要回答：我不知道…</p><p>而是，这个问题我要回去思考一下（面试官可以指导一下吗，给我点建议之类）</p></li><li><p>节奏要适宜 ，切记小聪明</p></li><li><p>方向要对，过程要细：</p><p>如性能优化，有哪几个方向，如何实现…</p></li><li><p>胆子要大，心态要和：</p><p>遇见难题不要怕，要多想，答错也比什么都不想强</p><p>勇于承担责任，敢于挑战未知，不要轻易放弃</p><p>：<em>面试官可不可以给我一点提示呀</em></p></li></ol></li></ul><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h4><ul><li>语义化掌握到位</li><li>页面布局理解深刻</li><li>CSS基础扎实</li><li>思维灵活且积极上进（会用grid布局…）</li><li>代码书写规范</li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603151616502.png" alt="image-20200603151616502"></p><h4 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h4><p>1.基本概念：标准模型 + IE模型</p><ul><li><p>标准模型：    BoxWidth = contentWidth</p></li><li><p>IE模型：BoxWidth = contentWidth + padding + border</p></li></ul><p>2.如何设置这两种模型：<code>box-sizing: content/border-box;</code></p><p>3.JS如何获取盒模型对应的宽高：</p><ol><li><code>dom.style.width</code>：只能获取内联属性，没有则返回空串</li><li><code>dom.currentStyle.width</code>：获取css中的属性，只有IE支持</li><li><code>window.getComputedStyle(dom).width</code>：获取的是content-box的宽度（带单位），所有浏览器支持</li><li><code>dom.getBoundingClientRect().width</code>：获取的是border-box的宽度同上（不带单位）</li></ol><p>4.根据盒模型解释边距重叠：</p><ol><li>父子</li><li>兄弟</li></ol><p>BFC（边距重叠解决方案）：</p><ul><li>BFC：块级格式化上下文</li><li>两栏布局时，左边浮动</li><li>清除浮动</li></ul><h4 id="DOM事件类"><a href="#DOM事件类" class="headerlink" title="DOM事件类"></a>DOM事件类</h4><p>1.DOM事件级别：</p><ul><li>DOM0：<code>ele.onclick = function(){}</code></li><li>DOM2：<code>ele.addEventListener(&#39;click&#39;, fucntion(){}, false)</code>false表示在冒泡阶段触发，true表示在捕获阶段触发</li><li>DOM3：<code>ele.addEventListener(&#39;keyup&#39;, function(){}, false)</code>添加了很多事件类型</li></ul><p>2.DOM事件模型：捕获、冒泡</p><p>3.DOM事件流：捕获-&gt;目标-&gt;冒泡</p><p>​    事件通过捕获到达目标元素 =&gt; 目标阶段</p><p>​    事件从目标元素冒泡到window对象 =&gt; 冒泡</p><p>4.事件捕获具体流程：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603201243266.png" alt="image-20200603201243266"></p><p>5.Event对象的常见应用：</p><ol><li><code>e.preventDefault()</code></li><li><code>e.stopPropogation()</code></li><li><code>e.stopImmediatePropagation()</code> 阻止事件冒泡,同时将该元素の同类型事件也阻止</li><li><code>e.target/srcElement</code>触发当前事件的元素</li><li><code>e.currentTarget</code>绑定当前事件的元素</li></ol><p>6.自定义事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法向回调函数添加数据</span></span><br><span class="line"><span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">'jump'</span>)</span><br><span class="line">ele.addEventListener(<span class="string">'jump'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'jump'</span>); </span><br><span class="line">&#125;)</span><br><span class="line">ele.dispatchEvent(eve);  <span class="comment">//参数不能写字符串</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//customEvent: 可以向回调函数添加数据</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">"build"</span>, &#123;</span><br><span class="line">    <span class="comment">//参数写在这里</span></span><br><span class="line">    detail: &#123;</span><br><span class="line">        name: <span class="string">'turing'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bubbles: <span class="literal">true</span>,</span><br><span class="line">    cancelable: <span class="literal">false</span> <span class="comment">//是否取消默认事件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ele.addEventListener(<span class="string">"build"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我叫"</span> + e.detail.name)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">ele.dispatchEvent(event); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure><h4 id="HTTP协议类"><a href="#HTTP协议类" class="headerlink" title="HTTP协议类"></a>HTTP协议类</h4><p>1.主要特点</p><p>​        简单快速  灵活   </p><ul><li><strong>无连接</strong>：连接一次就会断开</li><li><strong>无状态</strong>：无法区分不同连接</li></ul><p>2.报文的组成部分</p><p>3.HTTP方法</p><ul><li>GET：获取资源</li><li>POST：传输资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获得报文首部</li></ul><p>4.GET和POST的区别</p><p>5.HTTP状态码</p><p>6.什么是持久连接</p><p>7.什么是管线化</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>1.创建对象的几种方式</p><p>2.原型、构造函数、实例、原型链</p><p>3.instanceof</p><p>4.new运算符</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>继承的几种方式和优缺点</p><h4 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h4><p>1.什么是同源策略及限制</p><p>2.前后端如何通信</p><ul><li>Ajax</li><li>WebSocket：不受同源策略限制</li><li>CORS：都支持</li></ul><p>3.如何创建Ajax</p><ul><li>XHR对象的工作流程</li><li>兼容性处理</li><li>事件的触发条件</li><li>事件的触发顺序</li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103713775.png" alt="image-20200604103713775"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103233402.png" alt="image-20200604103233402"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103435122.png" alt="image-20200604103435122"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604103400308.png" alt="image-20200604103400308"></p><p>4.跨域通信的几种方式</p><ul><li>jsonp</li><li>Hash（原理：Hash的改变不会刷新页面，?xx=xx会）</li><li>postMessage（H5）</li><li>Websocket</li><li>CORS（原理：改变Ajax请求头中的origin）</li><li>nginx</li></ul><h4 id="安全类"><a href="#安全类" class="headerlink" title="安全类"></a><a href="https://juejin.im/post/5cd6ad7a51882568d3670a8e" target="_blank" rel="noopener">安全类</a></h4><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li><p><a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">排序</a>：快速、选择、希尔、冒泡</p><p> <img src="https://segmentfault.com/img/bVNIpc?w=554&h=337/view" alt="preview"> </p></li><li><p><a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">堆栈、队列、链表</a></p></li><li><p><a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">递归</a></p></li><li><p>波兰式和逆波兰式：<a href="https://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">理论</a>、<a href="https://github.com/Tairraos/rpn.js/blob/master/rpn.js" target="_blank" rel="noopener">源码</a></p></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><h4 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h4><p>1.<a href="https://blog.csdn.net/sunhl951/article/details/79763727" target="_blank" rel="noopener">什么是DOCTYPE及作用</a></p><p>2.浏览器渲染过程</p><p>3.重排Reflow、重绘Repaint</p><p>4.布局Layout</p><h4 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h4><p>1.理解JS单线程的概念</p><p>2.理解任务队列</p><p>3.理解Event Loop</p><h4 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h4><ul><li>提升页面性能的方法有哪些<ol><li>资源压缩合并，减少HTTP请求</li><li>非核心代码异步加载 </li><li>利用浏览器缓存 =&gt; 缓存的分类 =&gt; 缓存的原理</li><li>使用CDN(内容分发网络)：使网络快速到达服务端然后下载下来</li><li>预解析DNS<ul><li><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code>强制打开a标签的DNS预解析（大部分默认on，https默认off）</li><li><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//hostname_to_prefetch.com&quot;&gt;</code></li></ul></li></ol></li></ul><ul><li><p>异步加载：①动态加载脚本 ② defer  ③async</p></li><li><p>缓存</p><ol><li><p>强缓存（不询问直接缓存）</p><ul><li><p><code>Expires:Thu,21 Jan 2020 23:59:59 GMT</code>绝对时间</p></li><li><p><code>Cache-Control: max-age=3600(s)</code>相对时间，优先级更高</p><p><img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp" alt="img"> </p></li></ul></li></ol></li></ul><ol start="2"><li><p>协商缓存（询问服务器资源能否使用后再决定缓不缓存）</p><ul><li><p><code>Last-Modified</code> 、<code>If-Modified-Since</code>：将<code>Last-Moodified</code>值发送给服务端，询问资源是否已经过期，过期则返回新资源</p><p>  缺点：修改时间变化，而内容没变时，也会返回新资源</p><ul><li><code>Etag</code>、<code>If-None-Match</code>： 当且仅当服务器上没有任何资源的 <code>ETag</code>属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 <code>200</code> 。 </li></ul></li></ul></li></ol><h4 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a><a href="https://www.cnblogs.com/gaoning/p/7928497.html" target="_blank" rel="noopener">错误监控</a></h4><ul><li><p>错误分类</p><ol><li>即时运行错误：代码错误</li><li>资源加载错误</li></ol></li><li><p>错误的捕获方式</p><ol><li><p>即时运行错误的捕获方式：</p><ul><li><code>try...catch</code></li><li><code>window.onerror</code></li></ul></li><li><p>资源加载错误的捕获</p><ul><li><p><code>ele.onerror</code>：ele指的是img、script需要加载资源的标签，且这种事件<strong>无法冒泡</strong>，无法通过window.onerror捕获</p></li><li><p><code>performance.getEntries(filterOption)</code>获取已成功加载的资源的<code>PerformanceEntry</code>对象数组</p></li><li><p>Error事件<strong>捕获</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>, e)</span><br><span class="line">&#125;, <span class="literal">true</span>) <span class="comment">//事件捕获</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604172559631.png" alt="image-20200604172559631"></p></li></ul><ul><li><p>上报错误的基本原理</p><ol><li><p>Ajax通信的方式上报</p></li><li><p>利用Image对象上报</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src = <span class="string">'http://baidu.com/sdfsd?r=fdsfds'</span></span><br></pre></td></tr></table></figure><p>通过Network可以看到请求已经发出了</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604172941479.png" alt="image-20200604172941479"></p></li></ol></li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><h4 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604174051451.png" alt="image-20200604174051451"></p><h4 id="团队协作能力"><a href="#团队协作能力" class="headerlink" title="团队协作能力"></a>团队协作能力</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604175054428.png" alt="image-20200604175054428"></p><h4 id="事务推动能力"><a href="#事务推动能力" class="headerlink" title="事务推动能力"></a>事务推动能力</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604175304851.png" alt="image-20200604175304851"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604175423737.png" alt="image-20200604175423737"></p><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><ol><li>乐观积极</li><li>主动沟通</li><li>逻辑顺畅</li><li>上进有责任心</li><li>有主张、做事果断</li></ol><h4 id="职业竞争力"><a href="#职业竞争力" class="headerlink" title="职业竞争力"></a>职业竞争力</h4><ol><li><p>业务能力</p></li><li><p>思考能力</p><p> 对同一件事可以从不同角度去思考，找到最优解</p></li><li><p>学习能力</p><p>不断学习新的业务和技术，沉淀、总结</p></li><li><p>无上限的付出</p><p>对于无法解决的问题可以熬夜、加班</p></li></ol><h4 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604180149862.png" alt="image-20200604180149862"></p><p>5、学会赞美（公司、HR ）</p><h4 id="还有什么想要问我的吗？"><a href="#还有什么想要问我的吗？" class="headerlink" title="还有什么想要问我的吗？"></a>还有什么想要问我的吗？</h4><ul><li>团队人员分布情况</li><li>技术栈</li><li>我进去主要是负责哪块内容</li><li>年终奖/季度奖</li><li>调薪的频率以及幅度</li><li>加班多不多</li></ul><h3 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604182437767.png" alt="image-20200604182437767"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604182705610.png" alt="image-20200604182705610"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604183055883.png" alt="image-20200604183055883"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200604183454802.png" alt="image-20200604183454802"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200603091751928.png&quot; alt=&quot;image
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浏览器的缓存机制</title>
    <link href="https://turing5467.github.io/2020/06/01/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98/"/>
    <id>https://turing5467.github.io/2020/06/01/js/性能优化/缓存/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-06-17T03:24:56.708Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">原文</a></p><h2 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h2><p>缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以<strong>缩短网页请求资源的距离</strong>，减少延迟，并且由于缓存文件可以重复利用，还可以<strong>减少带宽</strong>，<strong>降低网络负荷</strong>。</p><p>对于一个数据请求来说，可以分为发起<strong>网络请求</strong>、<strong>后端处理</strong>、<strong>浏览器响应</strong>三个步骤。</p><p>浏览器缓存可以帮助我们在第一和第三步骤中优化性能。</p><p>比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p> 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 </p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>Service Worker 是<strong>运行在浏览器背后的独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <code>HTTPS</code>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p><strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong>。</p><p>Service Worker 实现缓存功能一般分为三个步骤：</p><ol><li>注册 Service Worker，</li><li>监听到 install 事件以后就可以缓存需要的文件，</li><li>下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li></ol><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>Memory Cache 也就是<strong>内存</strong>中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 <strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</strong>。</p><blockquote><p>Q：<strong>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</strong><br>A：这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 </p></blockquote><p>内存缓存中有一块重要的缓存资源是preloader相关指令（例如<code>&lt;link rel=&quot;prefetch&quot; &gt;</code>）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p> Disk Cache 也就是存储在<strong>硬盘</strong>中的缓存，读取<strong>速度慢</strong>点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在<strong>容量和存储时效性</strong>上。 </p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会<strong>根据 HTTP Header 中的字段判断</strong>哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读<code>Jake Archibald</code>的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p><ul><li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><h3 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h3><ul><li><p>浏览器与服务器通信的方式为<strong>应答模式</strong>，即是：浏览器发起HTTP请求 – 服务器响应该请求 </p></li><li><p>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong>。 </p><p><img src="https://upload-images.jianshu.io/upload_images/3174701-de3d6e025582103a?imageMogr2/auto-orient/strip%7CimageView2/2/w/670/format/webp" alt="img"> </p></li></ul><p>由上图我们可以知道：</p><ul><li>浏览器每次<strong>发起</strong>请求，都会先在浏览器缓存中<strong>查找</strong>该请求的结果以及缓存标识</li><li>浏览器每次<strong>拿到</strong>返回的请求结果都会将该结果和缓存标识<strong>存入</strong>浏览器缓存中</li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><ul><li>强缓存：不会向服务器发送请求，直接从缓存中读取资源.</li><li>在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示<code>from disk cache</code>或<code>from memory cache</code>。</li><li>强缓存可以通过设置两种 HTTP Header 实现：<code>Expires</code>和 <code>Cache-Control</code>。</li></ul><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><ul><li><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。 </p></li><li><p>Expires是Web服务器<strong>响应头</strong>字段，在响应http请求时<strong>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求</strong>。 </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><p> 这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是<strong>服务器的时间和浏览器的时间可能并不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。 </p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><ul><li><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当<code>Cache-Control:max-age=300</code>时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p></li><li><p>值（可以组合）</p><p> <img src="https://upload-images.jianshu.io/upload_images/3174701-8ff981603cdfded0?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp" alt="img"> </p></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li>协议版本：1.0  &amp;&amp;  1.1</li><li>优先级： Cache-Control更高</li></ul><p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容。</p><p><strong>那我们如何获知服务器端内容是否已经发生了更新呢</strong>？此时我们需要用到<strong>协商缓存策略</strong>。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p> 协商缓存就是<strong>强缓存失效</strong>后，浏览器携带<strong>缓存标识</strong>向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： </p><ol><li>协商缓存生效：返回304和Not Modified</li><li>协商缓存失效：返回200和请求结果</li></ol><h4 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h4><ul><li>浏览器第一次给服务器发送请求，服务器会在响应头中加上<code>Last-Modified</code></li><li>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，字段值为之前接收到的<code>Last-Modified</code>值</li><li>服务器拿到该值，会与该资源的最后修改时间对比<ol><li>如果没有变化，返回304和空的响应体</li><li>值小于最后修改时间，返回200和新的资源文件</li></ol></li></ul><ul><li>弊端<ol><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改  ，服务端不能命中缓存导致发送相同的资源 </li><li>能够感知的单位时间为<code>s</code>，若在一秒内改变多次，无法体现出修改，仍然返回修改之前的资源</li></ol></li></ul><h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h4><ul><li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识，只要资源有变化，Etag就会重新生成。 </li></ul><ul><li>浏览器第一次给服务器发送请求，服务器会在响应头中加上<code>ETag</code></li><li>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-None-Match</code>字段，字段值为之前接收到的<code>ETag</code>值</li><li>服务器拿到该值，会与该资源的最新<code>ETag</code>对比<ol><li>如果没有变化，返回304和空的响应体</li><li>值小于最后修改时间，返回200和新的资源文件</li></ol></li></ul><h4 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h4><ul><li><p>精确度：ETag &gt; Last-Modified</p></li><li><p>性能：Etag &lt;  Last-Modified</p><p>Last-Modified只记录一个时间点，而ETag根据文件具体内容生成Hash值。</p></li><li><p>优先级：ETag &gt; Last-Modified</p></li></ul><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>强制缓存优先于协商缓存进行，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存。</p><h3 id="实际场景应用"><a href="#实际场景应用" class="headerlink" title="实际场景应用"></a>实际场景应用</h3><h4 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h4><p>对于频繁变动的资源，首先需要使用<code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者<code>Last-Modified</code> 来验证资源是否有效。</p><p>这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><h4 id="不常变化的资源"><a href="#不常变化的资源" class="headerlink" title="不常变化的资源"></a>不常变化的资源</h4><p> 通常在处理这类资源时，给它们的 <code>Cache-Control</code> 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。 </p><h3 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h3><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ul><li>打开网页，地址栏输入地址： 查找 <code>disk cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)。其次才是 <code>disk cache</code>。</li><li>强制刷新 (Ctrl + F5)：<strong>浏览器不使用缓存</strong>，因此发送的请求头部均带有 <code>Cache-control: no-cache</code>(为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/54cc04190252&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;浏览器的缓存机制&quot;&gt;&lt;a href=&quot;#浏览器的缓存机制&quot; class=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React Native(未完)</title>
    <link href="https://turing5467.github.io/2020/05/21/js%E6%A1%86%E6%9E%B6/react/React_Native/"/>
    <id>https://turing5467.github.io/2020/05/21/js框架/react/React_Native/</id>
    <published>2020-05-20T16:00:00.000Z</published>
    <updated>2020-06-24T04:33:18.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>目前比较成熟的跨平台方案</p><ol><li><strong>React Native</strong>， Vue + Weex</li><li>AppCan：</li><li>Flutter：基于dart语言，学习成本较大</li></ol></li><li><p>React Native已经完成了对多端的支持，实现了真正意义上的面向配置开发：开发人员可以只使用JavaScript也能编写原生移动，结合React语法构建组件，实现Android，IOS两端代码的复用，并发布上线。</p></li><li><p>本质上还是用Objective-C或Java编写的，只是用JS对其进行了封装</p><p>所以它产出的是一个真正的移动应用，在使用感受上和用OC或Java几乎无法区分</p></li></ul><h4 id="开发平台选择"><a href="#开发平台选择" class="headerlink" title="开发平台选择"></a>开发平台选择</h4><ol><li>MacOS系统：支持Android和IOS</li><li>Windows和Linux：目前只支持Android</li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><p>跨平台开发</p></li><li><p>追求极致的用户体验：<strong>热更新</strong>和<strong>热部署</strong></p></li><li><p>learn one，write everywhere</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200521130850845.png" alt="image-20200521130850845"></p></li></ol><h4 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h4><ul><li>良好的JS 功底，最好还需要懂一些IOS和Android原生开发，才能够很好驾驭<strong>中大型</strong>移动端跨平台项目<ul><li>功能适中，交互一般，不需要特别多的系统原生支持</li><li>对于部分复杂的应用，可以考虑原生+React Native混合开发</li></ul></li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="noopener">官网教程</a></p><h4 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h4><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><ul><li>必须安装的以来有：Node（&gt;= 12）、Python（2.x）、JDK（1.8）和Android Studio</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用nrm工具切换淘宝源</span></span><br><span class="line">npx nrm use taobao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果之后需要切换回官方源可使用</span></span><br><span class="line">npx nrm use npm</span><br></pre></td></tr></table></figure><ul><li><a href="http://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line"><span class="comment"># 安装完 yarn 之后就可以用 yarn 代替 npm 了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Native&quot;&gt;&lt;a href=&quot;#React-Native&quot; class=&quot;headerlink&quot; title=&quot;React Native&quot;&gt;&lt;/a&gt;React Native&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://turing5467.github.io/2020/05/15/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://turing5467.github.io/2020/05/15/js/性能优化/防抖节流/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-05-17T08:09:01.933Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5c87b54ce51d455f7943dddb#chapter-three" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c87b54ce51d455f7943dddb#chapter-three&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>web-socket</title>
    <link href="https://turing5467.github.io/2020/05/15/node/web-socket/"/>
    <id>https://turing5467.github.io/2020/05/15/node/web-socket/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-05-26T08:16:53.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li>HTTP：超文本传输协议，是互联网上应用最为广泛的一种网络协议。用于从WWW服务器传输超文本到本地浏览器的传送协议</li></ul><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><ol><li>建立连接（三次握手）</li><li>发送请求（Request）</li><li>响应请求（Response）</li><li>断开连接（四次挥手）</li></ol><h3 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工通信（full-duple）——允许服务器主动发送信息给客户端。</p><p>websocket是一种持久协议，http是非持久协议</p><blockquote><p>全双工通信： 又称为双向同时<em>通信</em>，即<em>通信</em>的双方可以同时发送和接收信息的信息交互方式。 </p></blockquote><p>早期没有websocket时，通过<strong>ajax轮询</strong>，由于http请求时，服务器无法给浏览器主动发送数据，因此需要浏览器定时给服务器发送数据，然后服务器再把新的数据响应给浏览器。</p><p>这种模式的缺点是浪费性能和资源。</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516132911947.png" alt="image-20200516132911947"></p><blockquote><p>HTTP请求：每次发送请求都要建立连接，请求结束要关闭连接。</p><p>​    无状态。每次请求都是独立的。</p><p>WebSocket请求：建立连接（借助HTTP）后便可以同时发送和接收数据</p></blockquote><h3 id="WebSocket请求头"><a href="#WebSocket请求头" class="headerlink" title="WebSocket请求头"></a>WebSocket请求头</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200515205438552.png" alt="image-20200515205438552"></p><h3 id="WebSocket对象"><a href="#WebSocket对象" class="headerlink" title="WebSocket对象"></a>WebSocket对象</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket-MDN</a></p><p>WebSocket对象提供了一组API，用于创建和管理WebSocket连接，以及通过连接发送和接受数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造函数：</span></span><br><span class="line"><span class="comment">new WebSocket(url, [protocals])</span></span><br><span class="line"><span class="comment">url: 表示要连接的URL，以ws://开头，如'ws://echo.websocket.org'</span></span><br><span class="line"><span class="comment">protocal: 可以是单一的协议或多个协议字符串组成的数组</span></span><br><span class="line"><span class="comment">方法：</span></span><br><span class="line"><span class="comment">1. send(data)  通过WebSocket连接向服务器发送数据</span></span><br><span class="line"><span class="comment">2. close([code], [reason]) 关闭连接或停止正在进行的连接请求。</span></span><br><span class="line"><span class="comment">code：关闭连接的状态号</span></span><br><span class="line"><span class="comment">reason：连接被关闭的原因</span></span><br><span class="line"><span class="comment">    属性</span></span><br><span class="line"><span class="comment">    1. onclose：[连接关闭]事件监听器，接收一个CloseEvent对象</span></span><br><span class="line"><span class="comment">    2. onerror：[通信错误]事件监听器，接收一个error event对象</span></span><br><span class="line"><span class="comment">    3. onmessage：[客户端接收服务端数据]事件监听器，接收一个MessageEvent对象</span></span><br><span class="line"><span class="comment">    4. onopen：[建立连接]事件监听器，接收一个Event对象</span></span><br><span class="line"><span class="comment">    5. readyState：连接状态 </span></span><br><span class="line"><span class="comment">    0还未连接 1 连接开启并准备好通信</span></span><br><span class="line"><span class="comment">    2连接正在关闭  3连接已关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>通过控制台 =&gt; Network =&gt; WS 可以查看WebSocket连接信息</p></blockquote><h4 id="MessageEvent"><a href="#MessageEvent" class="headerlink" title="MessageEvent"></a>MessageEvent</h4><ul><li><code>event.data</code>为服务器接收到信息后返回的数据</li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516135426382.png" alt="image-20200516135426382"></p><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516135551659.png" alt="image-20200516135551659"></p><h4 id="CloseEvent"><a href="#CloseEvent" class="headerlink" title="CloseEvent"></a>CloseEvent</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516135613777.png" alt="image-20200516135613777"></p><h3 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h3><ol><li>ws：小而美</li><li>socket.io：大而全，封装了多种协议的websocket库</li><li>websocket</li></ol><h2 id="ws"><a href="#ws" class="headerlink" title="ws"></a>ws</h2><ol><li><p>纯WebSocket实现，不支持降级轮询，适用移动端开发</p></li><li><p>api简单易懂，client没有限制，可以用原生的</p></li><li><p>心跳检测，断线重连，多机多进程自由定制</p></li></ol><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"> </span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//每个连接对应的ws都不同</span></span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    wss.clients.forEach(<span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">        client.send(msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="简易聊天室"><a href="#简易聊天室" class="headerlink" title="简易聊天室"></a>简易聊天室</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516150529480.png" alt="image-20200516150529480"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端部分代码</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    box.innerHTML += res.data + <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">    input_msg.value = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//每次连接都会创建一个新的ws对象</span></span><br><span class="line">    count++;</span><br><span class="line">    ws.name = <span class="string">'用户'</span>+count; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//广播：用户xx加入了聊天室</span></span><br><span class="line">    wss.clients.forEach(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">            <span class="comment">//注意是ws.name而不是client.name</span></span><br><span class="line">            client.send(<span class="string">`<span class="subst">$&#123;ws.name&#125;</span>加入聊天室`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//广播：用户xx发送了xx消息</span></span><br><span class="line">    wss.clients.forEach(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">            client.send(<span class="string">`<span class="subst">$&#123;ws.name&#125;</span>：<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ws.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; </span><br><span class="line">      <span class="comment">//广播：用户xx离开了聊天室</span></span><br><span class="line">      wss.clients.forEach(<span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">            client.send(<span class="string">`<span class="subst">$&#123;ws.name&#125;</span>退出了聊天室`</span>);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="socket-io"><a href="#socket-io" class="headerlink" title="socket.io"></a><a href="https://socket.io/docs/" target="_blank" rel="noopener">socket.io</a></h2><ul><li>可以在浏览器和服务器之间实现实时，双向和基于事件的通信。</li><li>即可在服务端，又可在客户端使用</li><li>不是基于WebSocket实现的，只是偶尔使用</li><li>可以发送对象，而不单单是字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="comment">//注册自定义事件</span></span><br><span class="line">    socket.on(<span class="string">'xx'</span>, (params) =&gt; &#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//触发自定义事件(也可在客户端触发)</span></span><br><span class="line">    socket.emit(<span class="string">'xx'</span>, params)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="简易聊天室-1"><a href="#简易聊天室-1" class="headerlink" title="简易聊天室"></a>简易聊天室</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//客户端</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ws = io(<span class="string">'http://localhost:8080'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    ws.on(<span class="string">'message'</span>, (data) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        box.innerHTML += data.msg + <span class="string">'&lt;br&gt;'</span>;</span></span><br><span class="line"><span class="javascript">        input_msg.value = <span class="string">''</span>;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> msg = input_msg.value;</span></span><br><span class="line">        ws.send(msg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  count++;</span><br><span class="line">  socket.name = <span class="string">'用户'</span>+count; </span><br><span class="line">    </span><br><span class="line">  io.sockets.emit(<span class="string">'message'</span>, &#123;<span class="string">'msg'</span>: <span class="string">`<span class="subst">$&#123;socket.name&#125;</span>加入聊天室 --<span class="subst">$&#123;getTime()&#125;</span>`</span>&#125;)</span><br><span class="line">    </span><br><span class="line">  socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">      </span><br><span class="line">    io.sockets.emit(<span class="string">'message'</span>,&#123;<span class="string">'msg'</span>: <span class="string">`<span class="subst">$&#123;socket.name&#125;</span>：<span class="subst">$&#123;msg&#125;</span>  <span class="subst">$&#123;getTime()&#125;</span>`</span>&#125;)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    io.sockets.emit(<span class="string">'message'</span>, &#123;<span class="string">'msg'</span>: <span class="string">`<span class="subst">$&#123;socket.name&#125;</span>离开聊天室 --<span class="subst">$&#123;getTime()&#125;</span>`</span>&#125;)</span><br><span class="line">    count--;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTime</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().toTimeString().slice(<span class="number">0</span>,<span class="number">8</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket&quot;&gt;&lt;/a&gt;WebSocket&lt;/h2&gt;&lt;h3 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端性能优化--懒加载</title>
    <link href="https://turing5467.github.io/2020/05/14/js/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://turing5467.github.io/2020/05/14/js/性能优化/懒加载/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2020-06-24T04:28:07.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><ul><li>优点：提高前端性能，图片按需加载，减轻服务器负担，<strong>提高页面加载速度</strong>，减少带宽</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>图片加载是由src值引起的，当对src赋值时浏览器会请求图片资源。</p><p>基于这个，我们可以利用html5的属性<code>data-xxx</code>来保存图片的路径</p><p>当我们需要加载图片的时候才将data-xxx的值赋予src，就能实现图片的按需加载，也就是懒加载了。</p><h3 id="jquery中的懒加载"><a href="#jquery中的懒加载" class="headerlink" title="jquery中的懒加载"></a>jquery中的懒加载</h3><ul><li><p>最基础的懒加载：获取全部数据，但只有图片做到了懒加载</p><p>适用于PC端图片处理</p></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514194236585.png" alt="image-20200514194236585"></p><ul><li><p>分页 + 懒加载：每次获取n条数据，同时数据中的图片进行懒加载处理。</p><p>适用于移动端图片处理</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514204127386.png" alt="image-20200514204127386"></p></li></ul><h3 id="Vue中实现懒加载"><a href="#Vue中实现懒加载" class="headerlink" title="Vue中实现懒加载"></a>Vue中实现懒加载</h3><ol><li><p>安装插件：<code>npm i vue-lazyload --save-dev</code></p></li><li><p>引入并使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">'vue-lazyload'</span>;</span><br><span class="line"><span class="comment">//Vue.use(VueLazyload);或</span></span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: <span class="number">1.3</span>,</span><br><span class="line">  error: <span class="string">'dist/error.png'</span>,</span><br><span class="line">  loading: <span class="string">'dist/loading.gif'</span>,</span><br><span class="line">  attempt: <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>属性</li></ul><p><img src="https://ae01.alicdn.com/kf/Ued40af5be8d24f09977887975d337886K.png" alt></p></li><li><p>修改图片显示方式 （将 :src 属性直接改为v-lazy） </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"'/static/img/' + item.productImage"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p> <code>&lt;img&gt;</code>必须加上<code>key</code>，并且<code>key</code>是要唯一的，不然可能造成图片不刷新的问题 </p></blockquote><h3 id="react中实现懒加载"><a href="#react中实现懒加载" class="headerlink" title="react中实现懒加载"></a>react中实现懒加载</h3><ol><li><p>安装<a href="https://www.npmjs.com/package/react-lazyload" target="_blank" rel="noopener">react-lazy-load</a>： <code>npm install --save react-lazyload</code></p></li><li><p>引入并使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import LazyLoad from &apos;react-lazyload&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;LazyLoad height=&#123;200&#125; overflow=&#123;true&#125; once&gt;</span><br><span class="line">    &lt;img src=&quot;tiger.jpg&quot; /&gt;</span><br><span class="line">&lt;/LazyLoad&gt;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>height：单个图片试图高度</li><li>offset：距离多少进行预加载</li><li>once：一旦加载了该组件，就不再检测滚动/调整大小事件。（可提高性能，对图片和单一组件有用）</li><li>overflow： If lazy loading components inside a overflow container, set this to <code>true</code>. Also make sure a <code>position</code> property other than <code>static</code> has been set to your overflow container. </li><li>scroll（默认：true）：是否响应scroll事件</li><li>resize（默认：false）：是否响应resize事件</li><li>debounce、throttle：提供数值，表示要等待多少毫秒</li></ul></li></ol><ul><li><p>如果希望所有组件默认延迟加载，可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lazyload &#125; from &apos;react-lazyload&apos;;</span><br><span class="line"> </span><br><span class="line">@lazyload(&#123;</span><br><span class="line">  height: 200,</span><br><span class="line">  once: true,</span><br><span class="line">  offset: 100</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;this component is lazyloaded by default!&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="微信小程序图片懒加载"><a href="#微信小程序图片懒加载" class="headerlink" title="微信小程序图片懒加载"></a>微信小程序图片懒加载</h3><ul><li><p>原理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.getBoundingClientRect().top &lt;= <span class="built_in">document</span>.documentElement.clientHeight </span><br><span class="line">    ? 显示 </span><br><span class="line">: 默认</span><br></pre></td></tr></table></figure><blockquote><p> 小程序里面有个<code>onPageScroll</code>函数，是用来监听页面的滚动的。<br>还有个<code>getSystemInfo</code>函数，可以获取获取系统信息，里面包含屏幕的高度。 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:<span class="keyword">for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">'item item-&#123;&#123;index&#125;&#125;&gt;</span></span><br><span class="line"><span class="string">    &lt;image src="&#123;&#123;item.show ? item.src : item.def&#125;&#125;"&gt;&lt;/image&gt;</span></span><br><span class="line"><span class="string">&lt;/view&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//-----------------------------</span></span><br><span class="line"><span class="string">Page(&#123;</span></span><br><span class="line"><span class="string">    //...</span></span><br><span class="line"><span class="string">    lazyload() &#123;</span></span><br><span class="line"><span class="string">    const this_ = this;</span></span><br><span class="line"><span class="string">    let heroList = this.data.heroList;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    console.log(this_._observer)</span></span><br><span class="line"><span class="string">    this_._observer &amp;&amp; this_._observer.disconnect()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    let observer = wx.createIntersectionObserver(this, &#123;</span></span><br><span class="line"><span class="string">      // 阈值设置少，避免触发过于频繁导致性能问题</span></span><br><span class="line"><span class="string">      thresholds: [1],</span></span><br><span class="line"><span class="string">      // 监听多个对象</span></span><br><span class="line"><span class="string">      observeAll: true</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    observer.relativeToViewport(&#123;</span></span><br><span class="line"><span class="string">      bottom: 0</span></span><br><span class="line"><span class="string">    &#125;).observe('</span>.hero-image<span class="string">', (ret) =&gt; &#123;</span></span><br><span class="line"><span class="string">      console.log(ret)</span></span><br><span class="line"><span class="string">      if (ret.intersectionRatio &gt; 0) &#123;</span></span><br><span class="line"><span class="string">        let index = ret.dataset.index</span></span><br><span class="line"><span class="string">        heroList[index].show = true;</span></span><br><span class="line"><span class="string">        this_.setData(&#123; heroList &#125;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    this_._observer = observer;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure></li></ul><p>  <a href="https://github.com/Ortonzhang/simple-code/blob/master/javascript/lazyload-miniprogram/pages/index/index.js" target="_blank" rel="noopener">完整代码</a></p><p>   <a href="https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;懒加载&quot;&gt;&lt;a href=&quot;#懒加载&quot; class=&quot;headerlink&quot; title=&quot;懒加载&quot;&gt;&lt;/a&gt;懒加载&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;优点：提高前端性能，图片按需加载，减轻服务器负担，&lt;strong&gt;提高页面加载速度&lt;/strong&gt;，减少带宽&lt;/li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试题--React</title>
    <link href="https://turing5467.github.io/2020/04/19/%E9%9D%A2%E8%AF%95/React/"/>
    <id>https://turing5467.github.io/2020/04/19/面试/React/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2020-06-24T11:16:01.785Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Advanced-Interview-Question/front-end-interview/blob/master/docs/guide/react.md" target="_blank" rel="noopener">原文链接</a></p><h4 id="1-什么是React"><a href="#1-什么是React" class="headerlink" title="1.什么是React"></a>1.什么是React</h4><p> <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 是一个<strong>开源前端 JavaScript 库</strong>，用于构建用户界面，尤其是单页面应用。它用于处理网页和移动应用程序的视图层。</p><blockquote><p>单页面应用(single-page application)，是一个应用程序，它可以加载单个 HTML 页面，以及运行应用程序所需的所有必要资源（例如 JavaScript 和 CSS）。与页面或后续页面的任何交互，都不再需要往返 server 加载资源，即页面不会重新加载。</p></blockquote><h4 id="2-主要特点"><a href="#2-主要特点" class="headerlink" title="2. 主要特点"></a>2. 主要特点</h4><ol><li>使用虚拟DOM，考虑到真实DOM操作成本高</li><li>支持服务端渲染</li><li>单向数据流或数据绑定</li><li>使用可复用/可组合的UI组件开发视图</li></ol><blockquote><p>服务端渲染：用户发出请求时，在服务端生成一个我们希望看到的网页内容的HTML字符串，返回给客户端</p></blockquote><h4 id="3-什么是JSX"><a href="#3-什么是JSX" class="headerlink" title="3.什么是JSX"></a>3.什么是JSX</h4><p> JSX 是 ECMAScript 一个类似 XML 的语法扩展。基本上，它只是为 <code>React.createElement()</code> 函数提供语法糖，从而让在我们在 JavaScript 中，使用类 HTML 模板的语法，进行页面描述。 </p><h4 id="4-函数组件与类组件"><a href="#4-函数组件与类组件" class="headerlink" title="4.函数组件与类组件"></a>4.函数组件与类组件</h4><ul><li>函数组件：创建组件最简单的方式，接受props对象作为第一个参数<ol><li>不具有生命周期</li><li>无法使用<code>state</code></li></ol></li><li>类组件<ol><li>如果需要使用到<code>state</code>，则只能使用类组件来定义</li><li>具有生命周期</li></ol></li></ul><h4 id="5-Pure-Component"><a href="#5-Pure-Component" class="headerlink" title="5.Pure Component"></a>5.Pure Component</h4><ul><li>出现背景：在React .Component的生命周期中，有一个<code>shouldComponentUpdate</code>方法，默认返回值是true。这意味着就算没有改变组件的props或者state，也会导致组件的重绘，这极大的降低了React的渲染效率。</li><li>PureComponent：创建了默认的<code>shouldComponentUpdate</code>行为。这个默认的shouldComponentUpdate行为会一一比较props和state中所有的属性，只有当一项发生改变时，才会进行重绘。</li></ul><h4 id="6-state和props"><a href="#6-state和props" class="headerlink" title="6.state和props"></a>6.state和props</h4><ul><li>state 和 props 都是普通的 JavaScript 对象，但他们在组件方面的功能不同。Props 以类似于函数参数的方式传递给组件，而状态则类似于在函数内声明变量并对它进行管理。 </li></ul><h4 id="7-React合成事件"><a href="#7-React合成事件" class="headerlink" title="7.React合成事件"></a>7.React合成事件</h4><ul><li>React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用<strong>事件冒泡</strong>的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行。 <ol><li>当用户在为<code>onClick</code>添加函数时，React并没有将Click事件绑定在DOM上面。 </li><li>而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层<code>SyntheticEvent</code>（负责所有事件合成） </li><li>当事件触发的时候，使用统一的分发函数<code>dispatchEvent</code>执行指定函数。 </li></ol></li></ul><h4 id="8-在元素数组中使用key的好处"><a href="#8-在元素数组中使用key的好处" class="headerlink" title="8.在元素数组中使用key的好处"></a>8.在元素数组中使用key的好处</h4><ul><li><p><code>key</code> 是一个特殊的字符串属性，你在创建元素数组时需要包含它。<em>Keys</em> 帮助 React 识别哪些项已更改、添加或删除。 </p></li><li><p>好处：在diff算法执行时更快找到对应的节点，<strong>提升diff速度</strong></p><blockquote><p> 由于列表项的顺序可能发生改变，因此并不推荐使用 <em>indexes</em> 作为 <em>keys</em>。这可能会对性能产生负面影响，并可能导致组件状态出现问题。 </p></blockquote></li></ul><h4 id="9-如何创建ref"><a href="#9-如何创建ref" class="headerlink" title="9. 如何创建ref"></a>9. 如何创建ref</h4><ul><li><em>ref</em> 用于返回对元素的引用。但在大多数情况下，应该避免使用它们。当你需要直接访问 DOM 元素或组件的实例时，它们可能非常有用。 </li></ul><ol><li><p><code>React.createRef()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  myRef = React.creatRef()</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ref回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;node =&gt; this.node = node&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="10-虚拟DOM"><a href="#10-虚拟DOM" class="headerlink" title="10.虚拟DOM"></a>10.虚拟DOM</h4><ul><li><p>在react、vue等技术出现之前，要改变页面内容只能通过<strong>遍历查询</strong>DOM树的方式找到需要修改的DOM然后修改样式行为，相当耗费资源。</p></li><li><p>虚拟DOM：建立一个与虚拟DOM树对应的虚拟DOM对象，以对象嵌套的方式来表示DOM树，那么每次DOM的更改就只需要查找js对象的属性变化，性能开销小</p></li><li><p>如何工作</p><ol><li>每当任何底层数据发生更改时，整个 <strong>UI</strong> 都将以 Virtual DOM 的形式<strong>重新渲染</strong>。</li><li>然后<strong>计算</strong>先前 Virtual DOM 对象和新的 Virtual DOM 对象之间的<strong>差异</strong>。</li><li>一旦计算完成，<strong>真实 DOM</strong> 将只更新实际<strong>更改</strong>的内容</li></ol></li></ul><blockquote><p> 改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。 </p></blockquote><h4 id="11-受控组件-amp-非受控组件"><a href="#11-受控组件-amp-非受控组件" class="headerlink" title="11.受控组件&amp;非受控组件"></a>11.受控组件&amp;非受控组件</h4><ul><li><p>受控组件： 在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，即每个状态更改都有一个相关联的处理程序。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//例如，我们使用下面的 handleChange 函数将输入框的值转换成大写</span><br><span class="line">handleChange(event) &#123;</span><br><span class="line">  this.setState(&#123;value: event.target.value.toUpperCase()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非受控组件： 在内部存储其自身状态的组件，当需要时，可以使用<code>ref</code>查询 DOM 并查找其当前值。 </p></li><li><p>在大多数情况下，建议使用<strong>受控组件</strong>来实现表单。 </p></li></ul><h4 id="12-生命周期"><a href="#12-生命周期" class="headerlink" title="12.生命周期"></a>12.生命周期</h4><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191104194337150.png" alt="image-20191104194337150"></p><p>React 16之后有三个生命周期被废弃(但并未删除)</p><ul><li><code>componentWillMount</code><ul><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li></ul></li></ul><p>官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们<br>目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p><h5 id="1-挂载阶段"><a href="#1-挂载阶段" class="headerlink" title="1.挂载阶段"></a>1.挂载阶段</h5><ul><li><code>constructor</code>: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this</li></ul><ul><li><code>getDerivedStateFromProps(nextProps, prevState)</code>:这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用</li><li><code>render</code>：纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</li><li><code>componentDidMount</code>： 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在<code>componentWillUnmount</code>中取消订阅</li></ul><h5 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2.更新阶段:"></a>2.更新阶段:</h5><ul><li><code>getDerivedStateFromProps</code>: 此方法在更新个挂载阶段都可能会调用</li></ul><ul><li><code>shouldComponentUpdate(nextProps, nextState)</code>:：返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来<strong>优化React程序性能</strong></li><li><code>render</code>: 更新阶段也会触发此生命周期</li><li>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState),这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用</li><li><code>componentDidUpdate(prevProps, prevState, snapshot)</code>：参数表示之前的props，state和snapshot。第三个参数是<code>getSnapshotBeforeUpdate</code>返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 <code>getSnapshotBeforeUpdate</code>，然后在 <code>componentDidUpdate</code>中统一触发回调或更新状态。</li></ul><h5 id="3-卸载阶段"><a href="#3-卸载阶段" class="headerlink" title="3.卸载阶段:"></a>3.卸载阶段:</h5><ul><li><code>componentWillUnmount</code>: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作</li></ul><h4 id="13-无-有状态组件"><a href="#13-无-有状态组件" class="headerlink" title="13.无/有状态组件"></a>13.无/有状态组件</h4><ul><li><p>无状态组件： 行为独立于其状态 ，可以通过函数来创建无状态组件</p><p>好处：易于编写，理解和测试，可以完全避免this关键字</p></li><li><p>有状态组件：组件的行为依赖于state，只能通过类来创建有状态组件。</p></li></ul><h4 id="14-Context"><a href="#14-Context" class="headerlink" title="14.Context"></a>14.Context</h4><ul><li><em>Context</em> 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递<code>props</code>。 </li></ul><h4 id="15-Context与React-redux的区别"><a href="#15-Context与React-redux的区别" class="headerlink" title="15.Context与React-redux的区别"></a>15.Context与React-redux的区别</h4><ul><li>如果项目体量较小，只是需要一个<code>公共的store存储state</code>，而不讲究使用action来管理state，那context完全可以胜任。反之，则是redux的优点。 </li><li>Context缺点<ol><li>Provider 和 Consumer 必须来自同一次 React.createContext 调用 </li><li>因为没有action，state都是被直接修改，数据<strong>安全性</strong>不及redux。 </li><li>不能使用redux的中间件，比如thunk/saga，在一些异步的情况需要自己来处理。 </li></ol></li></ul><h4 id="16-Fragments"><a href="#16-Fragments" class="headerlink" title="16.Fragments"></a>16.Fragments</h4><ul><li><p>背景： <code>render</code> 函数的返回必须有一个根节点，否则报错 </p></li><li><p>Fragments：用于组件返回多个元素而无需根元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>好处</p><ol><li>通过不创建额外的 DOM 节点，Fragments 更快并且使用<strong>更少的内存</strong>。</li><li>一些 CSS 机制如<em>Flexbox</em>和<em>CSS Grid</em>具有特殊的父子关系，如果在中间添加 div 将使得很难保持所需的结构。 </li></ol></li></ul><h4 id="17-React的优点"><a href="#17-React的优点" class="headerlink" title="17.React的优点"></a>17.React的优点</h4><ol><li>使用虚拟DOM提高程序性能</li><li>JSX使代码易于读写</li><li>支持服务端和客户端渲染</li><li>易于与框架集成，因为他只是一个视图层</li><li>使用Jest等工具轻松编写单元与集成测试</li></ol><h4 id="18-React局限性"><a href="#18-React局限性" class="headerlink" title="18.React局限性"></a>18.React局限性</h4><ol><li>React只是一个视图库，而不是一个完整的框架</li><li></li></ol><h4 id="19-如何手动触发点击事件"><a href="#19-如何手动触发点击事件" class="headerlink" title="19.如何手动触发点击事件"></a>19.如何手动触发点击事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在render方法创建一个ref</span></span><br><span class="line">&lt;input ref=&#123;input =&gt; <span class="keyword">this</span>.inputElement = input&#125; /&gt;</span><br><span class="line"><span class="comment">//2.在事件处理器中触发点击事件</span></span><br><span class="line"><span class="keyword">this</span>.inputElement.clickj()</span><br></pre></td></tr></table></figure><h4 id="20-最流行的动画软件包"><a href="#20-最流行的动画软件包" class="headerlink" title="20.最流行的动画软件包"></a>20.最流行的动画软件包</h4><ul><li><em>React Transition Group</em> 和 <em>React Motion</em> 是React生态系统中流行的动画包。 </li></ul><h4 id="21-如何实现默认页面或404页面"><a href="#21-如何实现默认页面或404页面" class="headerlink" title="21.如何实现默认页面或404页面"></a>21.如何实现默认页面或404页面</h4><p><code>Switch</code>呈现匹配的第一个子<code>Route</code>。 没有路径的<code>Route</code>总是匹配。所以你只需要简单地删除 path 属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFound&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h4 id="22-登录后自动重定向"><a href="#22-登录后自动重定向" class="headerlink" title="22.登录后自动重定向"></a>22.登录后自动重定向</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default class LoginComponent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.isLoggedIn === true) &#123;</span><br><span class="line">      return &lt;Redirect to=&quot;/your/redirect/page&quot; /&gt;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return &lt;div&gt;&#123;&apos;Login Please&apos;&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23-redux中展示组件和容器组件"><a href="#23-redux中展示组件和容器组件" class="headerlink" title="23.redux中展示组件和容器组件"></a>23.redux中展示组件和容器组件</h4><p><strong>展示组件</strong>是一个类或功能组件，用于描述应用程序的展示部分。</p><p><strong>容器组件</strong>是连接到 Redux Store的组件的非正式术语。容器组件<em>订阅</em> Redux 状态更新和<em>dispatch</em>操作，它们通常不呈现 DOM 元素；他们将渲染委托给展示性的子组件。</p><h4 id="24-React-Native"><a href="#24-React-Native" class="headerlink" title="24.React Native"></a>24.React Native</h4><ul><li><strong>React Native</strong>是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 </li></ul><h4 id="25-在React中如何使用Font-Awesome图表"><a href="#25-在React中如何使用Font-Awesome图表" class="headerlink" title="25.在React中如何使用Font Awesome图表"></a>25.在React中如何使用Font Awesome图表</h4><ol><li>安装：<code>npm i -s font-awesome</code></li><li>在index.js中导入：<code>import &#39;font-awesome/css/font-awesome.min.css&#39;</code></li><li>应用：<code>&lt;i className={&#39;fa fa-spinner&#39;} /&gt;</code></li></ol><h4 id="26-React-lazy函数"><a href="#26-React-lazy函数" class="headerlink" title="26.React lazy函数"></a>26.React lazy函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;));</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line"> return (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &lt;OtherComponent /&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="27-React与Vue"><a href="#27-React与Vue" class="headerlink" title="27.React与Vue"></a><a href="https://juejin.im/post/5c0a92f2e51d455b3d3dc181" target="_blank" rel="noopener">27.React与Vue</a></h4><ul><li><p>相似之处</p><ol><li>虚拟DOM： 改变真实的DOM状态远比改变虚拟DOM(一个JS对象)的花销要大得多。 </li><li>响应式和组件化</li><li>构建工具</li></ol></li><li><p>不同点</p><ol><li><p>模板 &amp; JSX</p><ul><li><p>Vue鼓励你去写近似常规HTML的模板。只是多了一些属性。 </p></li><li><p>React/JSX使用JavaScript而不是模板来开发，赋予了开发者许多编程能力。 </p></li></ul></li><li><p>状态管理 &amp; 对象属性</p><ul><li>Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。 </li><li>在React中你需要使用<code>setState()</code>方法去更新状态。 </li></ul></li><li><p>HTML &amp; CSS</p><ul><li>Vue通过.vue文件把html、css、js组合到一起，用各自的处理方式</li><li>在React中，一切都是JS</li></ul></li><li><p>diff、patch、update</p><ul><li>Vue：vue的响应式使用的是<code>Object.defineProperty</code>api，并且由于在getter中实现了<strong>依赖收集</strong>，所以不会像react一样去<strong>比较整颗组件树</strong>，而是更加细粒度的去更新状态有变化的组件，同时<code>defineProperty</code>也不存在引用的问题。</li></ul></li></ol><ul><li>React： 状态发生改变后，会比较以此组件为根的整颗组件树 ，开销较大。 解决方案是<code>shouldComponentUpdate</code>，以此函数的返回结果来判断是否需要执行后面的diff、patch与update。  实际的开发过程中我们常常会用<code>pureComponent</code>（浅比较）来帮助我们做这一层逻辑判断 </li></ul><ol start="5"><li><p><strong>数据绑定</strong>：都是<strong>单向数据流</strong>（父-&gt;子），至于Vue中的v-model不过是逻辑复用的一种方式</p></li><li><p><strong>逻辑复用</strong>：把通用的一些逻辑复用到需要这些逻辑的组件中</p><ul><li>Vue：使用指令或 mixin(容易污染，也不容易debug) </li><li>React（ 高阶组件其实更多的是选择传入什么，而renderProps则是暴漏什么 ）<ul><li>renderProps： 在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术 </li><li>高阶组件：传入一个组件并返回一个新组件</li></ul></li></ul></li><li><p>使用场景</p><ul><li>Vue应用的渲染系统更快且体积更小</li><li>React适用于构建大型应用项目，同时适用于Web端和原生APP:</li></ul></li></ol></li></ul><h4 id="28-React与Angular"><a href="#28-React与Angular" class="headerlink" title="28.React与Angular"></a>28.React与Angular</h4><table><thead><tr><th>React</th><th>Angular</th></tr></thead><tbody><tr><td>React 是一个库，只有View层</td><td>Angular是一个框架，具有完整的 MVC 功能</td></tr><tr><td>React 可以处理服务器端的渲染</td><td>AngularJS 仅在客户端呈现，但 Angular 2 及更高版本可以在服务器端渲染</td></tr><tr><td>React 在 JS 中使用看起来像 HTML 的 JSX，这可能令人困惑</td><td>Angular 遵循 HTML 的模板方法，这使得代码更短且易于理解</td></tr><tr><td>React Native 是一种 React 类型，它用于构建移动应用程序，它更快，更稳定</td><td>Ionic，Angular 的移动 app 相对原生 app 来说不太稳定和慢</td></tr><tr><td>在 Reac t中，数据只以单一方向传递，因此调试很容易</td><td>在 Angular 中，数据以两种方式传递，即它在子节点和父节点之间具有双向数据绑定，因此调试通常很困难</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Advanced-Interview-Question/front-end-interview/blob/master/docs/guide/react.md&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dart笔记(未完)</title>
    <link href="https://turing5467.github.io/2020/04/18/%E5%B7%A5%E7%A8%8B%E5%8C%96/Dart%20Flutter/"/>
    <id>https://turing5467.github.io/2020/04/18/工程化/Dart Flutter/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2020-06-24T04:25:11.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dart-未完"><a href="#Dart-未完" class="headerlink" title="Dart(未完)"></a>Dart(未完)</h2><ul><li>Dart是由谷歌开发的计算机编程语言，它可被用于web、服务器、移动应用和物联网等领域的开发</li><li>windows安装链接： <a href="https://gekorm.com/dart-windows/" target="_blank" rel="noopener">https://gekorm.com/dart-windows/</a> （需要翻墙，不然会连接报错）</li><li>mac安装链接： <a href="https://dart.dev/get-dart#install" target="_blank" rel="noopener">https://dart.dev/get-dart#install</a> </li><li>检查Dart安装是否成功：dart –version</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li>IDEA、WebStorm、Atom、VSCode</li><li>如何在VSCode中配置Dart<ol><li>安装dart插件</li><li>安装code runner插件</li></ol></li></ul><h3 id="dart示例文件"><a href="#dart示例文件" class="headerlink" title="dart示例文件"></a>dart示例文件</h3><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>所有语句都必须写在入口方法<code>main</code>中，<code>void main</code>表示<code>main</code>方法没有返回值</li><li>每个语句后都必须加上<code>;</code></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>dart是一个强大的脚本类语言，可以不预先定义变量类型，会自动进行类型推断</p><ol><li>通过<code>var</code>定义变量</li><li>通过类型来声明变量，如String、int</li></ol></li><li><p>命名规则</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200418204449386.png" alt="image-20200418204449386"></p></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>null</p></li><li><p>Number：</p><ol><li>int</li><li>double</li></ol></li><li><p>String：<code>&#39;&#39;</code>或<code>&quot;&quot;</code>只支持单行字符串，多行字符串使用<code>&#39;&#39;&#39;str&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;str&quot;&quot;&quot;</code></p><ul><li>字符串拼接：<code>&quot;$str1 $str2&quot;</code>或<code>str1 + str2</code></li></ul></li><li><p>bool</p></li><li><p>List</p></li><li><p>Set</p></li><li><p>Maps：</p><ol><li><code>var person = { &quot;name&quot;: &quot;turing&quot; }</code></li><li><code>var p = new Map(); p[&#39;name&#39;] = &#39;turing&#39;</code></li></ol><ul><li>访问：<code>person[&#39;name&#39;]</code></li></ul></li></ul><blockquote><p>通过<code>is</code>关键词判断数据类型，如<code>str is String</code></p></blockquote><ul><li>类型转换<ol><li>Number -&gt; String : <code>totring()</code></li><li>String -&gt; Number： <code>int.parse()</code>或 <code>double.parse()</code></li><li><code>str.isEmpty</code>判断字符串是否为空</li></ol></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>算数：<code>+ - * /  ~/(取整) %</code></p></li><li><p>关系：<code>== != &gt; &lt; &lt;= &gt;=</code>：<code>123 != &#39;123&#39;</code>(不会对类型进行自动转换)</p></li><li><p>逻辑：<code>! &amp;&amp; ||</code>返回值之能是bool值，不同于js</p></li><li><p>赋值：</p><ol><li>基础：<code>= ??=(为空则赋值)</code></li><li>复合：<code>+= -+ *= /= %= ^/=</code></li></ol></li><li><p><code>if else [else if] switch case for循环 do{}while() while(){} break continue</code></p></li><li><p>?：左边不为空则执行右边，如<code>p?.printInfo()</code></p></li><li><p>三目：?x:xx</p></li><li><p><code>??</code>左边为空则将右边值赋予变量</p></li><li><p><code>++ --</code>同js</p></li><li><p><code>..</code>级联操作</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1..name=<span class="string">'turing'</span></span><br><span class="line">  ..age=<span class="number">23</span></span><br><span class="line">  ..printInfo();</span><br></pre></td></tr></table></figure></li></ul><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'12.2'</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">int</span>.parse(a);</span><br><span class="line">    <span class="built_in">print</span>(b);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果： 0</span></span><br></pre></td></tr></table></figure><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">print</span>(li[<span class="number">1</span>]); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l2= <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line">l2.add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(l2)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> l3 = l1.reversed.toList(); <span class="comment">// toList其他类型转换为list</span></span><br><span class="line"><span class="built_in">print</span>(l1.reversed); <span class="comment">//(3,2,1)不是字符串类型也不是List</span></span><br><span class="line"><span class="built_in">print</span>(l3); <span class="comment">//[3,2,1]</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//属性： length、isEmpty、isNotEmpty、reversed</span></span><br><span class="line"><span class="comment">//方法: </span></span><br><span class="line"><span class="comment">/*add(ele) 增加一份数据</span></span><br><span class="line"><span class="comment">addAll(List)   拼接数组</span></span><br><span class="line"><span class="comment">indexOf(ele)查找指定元素的索引，找不到则返回-1</span></span><br><span class="line"><span class="comment">remove(ele)删除指定元素</span></span><br><span class="line"><span class="comment">removeAt(index)  删除指定索引的元素</span></span><br><span class="line"><span class="comment">fillRange(start, end ,ele) 将start - end-1范围内的元素都替换为ele</span></span><br><span class="line"><span class="comment">insert(start, ele)</span></span><br><span class="line"><span class="comment">insertAll(start, list)</span></span><br><span class="line"><span class="comment">join(str) 将数据连接成字符串(反之为split)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">forEach( (value)&#123;&#125; )  //循环遍历</span></span><br><span class="line"><span class="comment">map( (value)&#123;&#125; )  //List映射,但是返回值不是list类型</span></span><br><span class="line"><span class="comment">where( (value)&#123; return value&gt;5 &#125; )//返回值不是list类型</span></span><br><span class="line"><span class="comment">any( 同上 )//存在一个符合条件的值就返回true</span></span><br><span class="line"><span class="comment">every( 同上 )//每个值都符合条件的值才返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li>对List进行去重</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span> s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s1.add(<span class="string">'y'</span>);</span><br><span class="line">s1.add(<span class="string">'b'</span>);</span><br><span class="line">s1.add(<span class="string">'s'</span>);</span><br><span class="line"><span class="comment">//s1.addAll([1,2,2]) //可用来去重</span></span><br><span class="line"><span class="built_in">print</span>(s1);</span><br><span class="line"><span class="comment">//forEach</span></span><br></pre></td></tr></table></figure><h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><ul><li>类似于json对象，键值必须加引号</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span> map = &#123;<span class="string">"name"</span>: <span class="string">"turing"</span>, <span class="string">"age"</span>: <span class="number">21</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(map.keys);    <span class="comment">//(name, age)</span></span><br><span class="line"><span class="built_in">print</span>(map.keys.toList());    <span class="comment">//[name, age]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性：keys、values、isEmpty、isNotEmpty</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法：</span></span><br><span class="line"><span class="comment">addAll(Map)</span></span><br><span class="line"><span class="comment">remove(key)</span></span><br><span class="line"><span class="comment">containsValue(value)</span></span><br><span class="line"><span class="comment">forEach( (key, value)&#123; /**/</span> &#125; )</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">格式</span><br><span class="line">    [返回类型/<span class="keyword">void</span>] 方法名称 ([类型 参数名], ...) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可放main方法里外</span></span><br><span class="line"><span class="comment">//可选参数 可有多个 但需加上[]</span></span><br><span class="line"><span class="built_in">int</span> add(<span class="built_in">int</span> a, [<span class="built_in">int</span> b, <span class="built_in">int</span> c]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(b!=<span class="keyword">null</span> &amp;&amp; c!= <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> sum = add(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认参数：=</span></span><br><span class="line"><span class="comment">//命名参数：&#123;&#125;</span></span><br><span class="line"><span class="built_in">int</span> add(<span class="built_in">int</span> a, &#123;<span class="built_in">int</span> b&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sum = add(<span class="number">1</span>, b:<span class="number">2</span>);</span><br><span class="line"><span class="built_in">print</span>(sum);</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200428230434194.png" alt="image-20200428230434194"></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类名首字母必须大写</span></span><br><span class="line"><span class="comment">//构造函数同类名</span></span><br><span class="line"><span class="comment">//私有属性/方法前面加_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;<span class="comment">//不可省</span></span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数简写</span></span><br><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">  <span class="comment">//命名构造函数(可写多个)</span></span><br><span class="line">  Person.now() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'我是命名构造函数'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> getInfo() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>,I'm <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p1  = <span class="keyword">new</span> Person(<span class="string">'turing'</span>, <span class="number">23</span>);</span><br><span class="line">  p1.getInfo(); <span class="comment">//my name is turing,I'm 23 years old</span></span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person.now();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>get/set修饰符：类似计算属性</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  Rect(<span class="keyword">this</span>.height, <span class="keyword">this</span>.width);</span><br><span class="line">  <span class="keyword">get</span> area&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> setHeight(<span class="built_in">num</span> height)&#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> Rect(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">print</span>(p1.area);</span><br><span class="line">  <span class="comment">//set使用</span></span><br><span class="line">  p1.setHeight = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">print</span>(p1.area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化实例变量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  Rect():height=<span class="number">2</span>,width=<span class="number">10</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">this</span>.height * <span class="keyword">this</span>.width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p1  = <span class="keyword">new</span> Rect(); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态：static</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="built_in">num</span> height;</span><br><span class="line">    <span class="built_in">num</span> width;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">String</span> text = <span class="string">'Hello World'</span>;</span><br><span class="line">    Rect(<span class="keyword">this</span>.height, <span class="keyword">this</span>.width);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> show()&#123;</span><br><span class="line">      <span class="built_in">print</span>(text); <span class="comment">// 非静态方法可以访问静态成员以及非静态成员</span></span><br><span class="line">      <span class="comment">// print(this.height);   静态方法无法访问非静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> show_1() &#123;</span><br><span class="line">      show();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>任何类都是Object类型</p></blockquote><ul><li><p>继承：extends</p><ol><li>子类会继承父类里可见的属性和方法，但不会继承构造函数</li><li>子类能复写父类的方法 getter和seter</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line">  Animal(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 恰饭'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="built_in">String</span> sex;</span><br><span class="line">  Cat(<span class="built_in">String</span> name, <span class="built_in">int</span> age, <span class="built_in">String</span> sex) : <span class="keyword">super</span>(name, age)&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span>   <span class="comment">//建议加上这句</span></span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'miao~~'</span>);</span><br><span class="line">    <span class="keyword">super</span>.eat();   <span class="comment">//子类调用父类的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Cat mimi = <span class="keyword">new</span> Cat(<span class="string">'mimi'</span>,<span class="number">1</span>, <span class="string">'female'</span>);</span><br><span class="line">  mimi.eat();<span class="comment">//miao~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类(abstract)：子类可以继承抽象类，也可以实现抽象类接口</p><ol><li>抽象方法（没有方法体的方法）不能用abstract声明，</li><li>子类继承抽象类必须实现其中的抽象方法</li><li>子类实现抽象接口必须实现接口里的所有属性与方法</li><li>抽象类不能被实例化，只有继承他的子类可以</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  eat();   <span class="comment">//抽象方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'miao'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Cat mimi = <span class="keyword">new</span> Cat();</span><br><span class="line">  mimi.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多态：将子类类型的指针赋值给父类类型的指针，同一函数调用会有不同的执行效果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  eat();   <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'miao'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'cat run'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'wang~'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'dog run'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Animal mimi = <span class="keyword">new</span> Cat();</span><br><span class="line">  mimi.eat();</span><br><span class="line">  mimi.run();  <span class="comment">//报错，父类指针无法访问子类特有的run方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DB</span></span>&#123;<span class="comment">//接口：就是约定、规范</span></span><br><span class="line">    add(<span class="built_in">String</span> data);</span><br><span class="line">    delete();</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoDB</span> <span class="keyword">implements</span> <span class="title">DB</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> add(data)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'添加数据：<span class="subst">$data</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> delete() &#123;&#125;</span><br><span class="line">  <span class="keyword">void</span> update() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  MongoDB db = <span class="keyword">new</span> MongoDB();</span><br><span class="line">  db.add(<span class="string">'Helo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>extends 可以复用抽象类里的方法，implements里只能有抽象方法</p></blockquote><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><ul><li>作为mixns的类不能继承其他类</li><li>作为mixns的类不能有构造函数</li><li>mixins绝不是继承，也不是接口，而是一种全新的特性</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> printA() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'A--'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> printB() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'B--'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">with</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;<span class="comment">//可同时extends其他类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  c.printA();</span><br><span class="line">  c.printB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当mixins的类中有同一名称的方法时，写在后面的会覆盖前面的</li><li>当继承的类和mixins的类有同一名称的方法时，mixins中的方法优先级更高</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对传入值与返回值进行校验</span></span><br><span class="line">T getData&lt;T&gt;(T data) &#123;</span><br><span class="line">  <span class="built_in">print</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  getData&lt;<span class="built_in">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line">  getData&lt;<span class="built_in">String</span>&gt;(<span class="string">'Hello world'</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//表示list只能添加String类型</span></span><br><span class="line">  <span class="built_in">List</span> list = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类的写法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DB</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  add(T data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoDB</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">DB</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  add(T data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  MongoDB m = <span class="keyword">new</span> MongoDB&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  m.add(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dart库"><a href="#Dart库" class="headerlink" title="Dart库"></a>Dart库</h2><ol><li><p>自定义库</p></li><li><p>系统内置库 <code>import &#39;dart:math&#39;</code> <code>import &#39;dart:io&#39;</code></p></li><li><p>Pub包管理系统中的库</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200501150504733.png" alt="image-20200501150504733"></p></li></ol><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>Flutter是谷歌基于Dart语言开发的一款跨平台的移动APP开发框架。（咸鱼）</p><p>性能相比RN、Ionic要好一些，但是社区较不完善</p><h3 id="Window搭建Flutter环境"><a href="#Window搭建Flutter环境" class="headerlink" title="Window搭建Flutter环境"></a>Window搭建Flutter环境</h3><p><a href="https://jspang.com/detailed?id=41#toc222" target="_blank" rel="noopener">jspang文章</a></p><ol><li><p>安装JDK：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">jdk</a></p></li><li><p>安装Flutter SDK</p><ul><li><p>方法1 <a href="https://flutter.dev/docs/development/tools/sdk/releases" target="_blank" rel="noopener">https://flutter.dev/docs/development/tools/sdk/releases</a> beta版本</p></li><li><p>方法二：</p><ol><li>设置用户环境变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><ol start="2"><li>git clone <a href="https://github.com/flutter/flutter.git" target="_blank" rel="noopener">https://github.com/flutter/flutter.git</a> </li></ol></li><li><p>配置环境变量：<code>Path += flutter安装目录下的bin目录</code></p></li><li><p>flutter doctor检查依赖是否全部安装</p></li></ul></li><li><ul><li><p>安装Android Studio： <a href="https://developer.android.google.cn/studio/" target="_blank" rel="noopener">https://developer.android.google.cn/studio/</a> </p><ul><li><p>安装flutter插件：configure/pugins/</p></li><li><p>重启，flutter doctor，有几个感叹号，逐个解决</p></li></ul></li><li><p>VScode(还是需要安装AndroidStudio，但不需要启动)</p><ul><li><p>安装flutter插件</p></li><li><p>qwe</p><ul><li>编写一个<code>EmulatorRun.bat</code>,内容如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//emulator.exe的路径(有两个，选择emulator文件夹下的)</span><br><span class="line">path -netdelay none -netspeed full -avd [虚拟机名字(空格改为_)]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><ol start="4"><li><p>创建项目：create a new flutter project =&gt; flutter application =&gt; 命名</p><ul><li>VSCode中：flutter create 项目名</li></ul></li><li><p>虚拟机：tools =&gt; AVD Manager =&gt; create Visual Device =&gt; Nexus 5X =&gt; 启动</p></li><li><p>如果是VScode，还需要执行<code>flutter run</code></p></li></ol><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--android安卓资源目录</span><br><span class="line">--build运行时生成的编译目录</span><br><span class="line">--ios苹果资源目录</span><br><span class="line">--lib自己编写的代码及资源</span><br><span class="line">main.dart//flutter的入口文件</span><br><span class="line">pubspec.yaml配置文件，一般寻访一些第三方库的依赖</span><br></pre></td></tr></table></figure><h4 id="main-dart"><a href="#main-dart" class="headerlink" title="main.dart"></a>main.dart</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义组件</span></span><br><span class="line"><span class="comment">//StatelessWidget是一个抽象类，里面有一个抽象方法build,该方法返回一个Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Text(</span><br><span class="line">        <span class="string">'Hello, world!'</span>,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">                style: TextStyle(</span><br><span class="line">                fontSize: <span class="number">24.0</span>,</span><br><span class="line">                    color: Colors.yellow,</span><br><span class="line">                    <span class="comment">//color: Color.fromRGBO(244, 233, 222 ,0.5)</span></span><br><span class="line">                )</span><br><span class="line">      ),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Flutter中所有和数字相关的东西都是<strong>double</strong>类型</p></blockquote><h4 id="MaterialApp"><a href="#MaterialApp" class="headerlink" title="MaterialApp"></a>MaterialApp</h4><ul><li>MaterialApp是一个方便的Widget，它封装了应用程序实现Material Design所需要的Widget，一般作为<strong>顶层Widget</strong>使用。</li><li>常用属性<ul><li><code>home</code>:主页</li><li><code>title</code>: 标题</li><li><code>color</code>：颜色</li><li><code>theme</code>：主题</li><li><code>routes</code>：路由</li></ul></li></ul><h4 id="Scaffold"><a href="#Scaffold" class="headerlink" title="Scaffold"></a>Scaffold</h4><ul><li>Scaffold是Material Design布局结构的基本实现，此类提供了用于显示drawer、snackbar和底部sheet的Api</li><li>主要属性<ul><li>appBar：显示在页面顶部的AppBar</li><li>body：显示的主要内容Widget</li><li>drawer：抽屉菜单控件</li></ul></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504135729256.png" alt="image-20200504135729256"></p><h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><ul><li>textAlign：center、left、right、justify</li><li>textDirection：ltr、rtl</li><li>overflow：文本溢出处理：clip裁剪、fade渐隐、ellipsis省略号</li><li>textScaleFactor:字体显示倍率</li><li>maxLines：</li><li>style</li><li>TextStyle参数<ul><li>fontStyle、fontSize、color、fontWeight、letterSpacing、wordSpacing</li><li>decoration、decorationColor、decorationStyle</li></ul></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502144655280.png" alt="image-20200502144655280"></p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502151335853.png" alt="image-20200502151335853"></p><ul><li>width、height</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">10.0</span>);</span><br><span class="line">padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(左,上,右,下);</span><br><span class="line"><span class="comment">//margin同</span></span><br></pre></td></tr></table></figure><ul><li><p>alignment：<code>Alignment.bottomLeft</code></p></li><li><p>transform</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix4.rotationX/Y/Z(radius)</span><br><span class="line">    skew/skewX/skewY</span><br><span class="line">    solve/solve2/solve3</span><br><span class="line">    translation/translationValues(x,y,z)</span><br><span class="line">    tryConvert</span><br><span class="line">    diagonal3Values(x, y, z)缩放</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>decoration：背景样式（背景色与color冲突，只能写一个）</p><ul><li>color、gradient</li><li>border =&gt; color、width</li><li>borderRadius边框圆角<code>BorderRadius.all(Radius.circular(8.0))</code></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502152545438.png" alt="image-20200502152545438"></p></li></ul><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><ul><li><p>Image.asset()：<strong>本地</strong>图片</p><ol><li><p>在img文件夹下创建2.0x和3.0x文件夹</p></li><li><p>在每个文件夹下存放对应分辨率下加载的图片</p></li><li><p>在<code>pubspec.yaml</code>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  assets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">img/a.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">img/2.0x/a.jpg</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">img/3.0x/a.jpg</span></span><br></pre></td></tr></table></figure></li><li><p><code>Image.asset(&#39;img/a.jpg&#39;)</code></p></li></ol></li><li><p>Image.network()：<strong>远程</strong>图片</p><ul><li>alignment</li><li>color、colorBlendMode</li><li>fit：fill、contain、cover</li></ul></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Image.network(</span><br><span class="line"><span class="string">'imggeURL'</span>,</span><br><span class="line">    fit: BoxFit.fit,</span><br><span class="line">    color: Colors.green,</span><br><span class="line">    colorBlendMode: BlendMode.darken,</span><br><span class="line">    repeat: ImageRepeat.repeatX</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="圆形图片"><a href="#圆形图片" class="headerlink" title="圆形图片"></a>圆形图片</h4><ul><li>方法1（推荐）：</li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504200108147.png" alt="image-20200504200108147"></p><ul><li><p>方法2：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504200210868.png" alt="image-20200504200210868"></p></li></ul><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><ol><li>垂直列表</li><li>水平列表</li><li>动态列表</li><li>矩阵式列表</li></ol><ul><li>ListView参数<ol><li>children：<code>&lt;Widget&gt;[任意组件,可以是不同类型的]</code></li><li>scrollDirection：Axis.horizontal/vertical</li><li>padding：EdgeInsetsGeometry</li><li>resolve：组件是否反向排序</li></ol></li></ul><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502190837731.png" alt="image-20200502190837731"></p><ul><li>ListTile参数<ol><li>leading、trailing：前、后缀(可以是图标、图片等)</li><li>title、subtitle</li></ol></li></ul><h4 id="动态列表"><a href="#动态列表" class="headerlink" title="动态列表"></a>动态列表</h4><ol><li><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504204458126.png" alt="image-20200504204458126"></p></li><li><p>ListView.builder(itemCount, itemBuilder)</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504205103392.png" alt="image-20200504205103392"></p></li></ol><h4 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h4><ol><li><p>GridView.count()</p><ul><li><p>常用属性</p><ul><li><p>scrollDirection</p></li><li><p>crossAxisCount：一行Widget数量</p></li><li><p>crossAxisSpacing：水平子Widget间距</p></li><li><p>mainAxisSpacing：垂直子Widget间距</p></li><li><p>padding 、 resolve</p></li><li><p>crossAspectRatio</p></li></ul></li></ul></li><li><p>GridView.builder()</p><ul><li><p>gridDelegate</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GridView.builder(BuildContext context) &#123;</span><br><span class="line">    gridDelegate.SilverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">    <span class="comment">//上述属性</span></span><br><span class="line">        crossAxisCount: <span class="number">2</span></span><br><span class="line">    ),</span><br><span class="line">    itemCount: listData.length,</span><br><span class="line">    itemBuilder: <span class="keyword">this</span>._getListData,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dart-未完&quot;&gt;&lt;a href=&quot;#Dart-未完&quot; class=&quot;headerlink&quot; title=&quot;Dart(未完)&quot;&gt;&lt;/a&gt;Dart(未完)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Dart是由谷歌开发的计算机编程语言，它可被用于web、服务器、移动应用和物联网等领
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>react bug 记录</title>
    <link href="https://turing5467.github.io/2020/03/09/js%E6%A1%86%E6%9E%B6/react/bug/"/>
    <id>https://turing5467.github.io/2020/03/09/js框架/react/bug/</id>
    <published>2020-03-08T16:00:00.000Z</published>
    <updated>2020-03-20T08:10:18.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="react-bug-记录"><a href="#react-bug-记录" class="headerlink" title="react bug 记录"></a>react bug 记录</h3><h4 id="1-请求"><a href="#1-请求" class="headerlink" title="1.请求"></a>1.请求</h4><p>通过请求获取数组并渲染时，先在构造函数中<code>this.state = { xx: [] }</code>，注意不可以是<code>null</code>。</p><h4 id="2-输入框值"><a href="#2-输入框值" class="headerlink" title="2.输入框值"></a>2.输入框值</h4><p>必须指定onChange事件，否则输入框的值无法修改</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200320160949038.png" alt="image-20200320160949038"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200320161001895.png" alt="image-20200320161001895"></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200320161016805.png" alt="image-20200320161016805"></p><h4 id="3-redux数组push"><a href="#3-redux数组push" class="headerlink" title="3.redux数组push"></a>3.redux数组push</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    ...state,</span><br><span class="line">    searchHistory: state.searchHistory.push(action.item)</span><br><span class="line">    <span class="comment">//❌！！ 因为push函数改变原数组，返回值为新的length值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    ...state,</span><br><span class="line">    searchHistory: [...state.searchHistory, action.item]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">state.searchHistory.push(action.item)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    ...state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;react-bug-记录&quot;&gt;&lt;a href=&quot;#react-bug-记录&quot; class=&quot;headerlink&quot; title=&quot;react bug 记录&quot;&gt;&lt;/a&gt;react bug 记录&lt;/h3&gt;&lt;h4 id=&quot;1-请求&quot;&gt;&lt;a href=&quot;#1-请求&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>混合开发</title>
    <link href="https://turing5467.github.io/2020/02/04/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>https://turing5467.github.io/2020/02/04/工程化/混合开发/</id>
    <published>2020-02-03T16:00:00.000Z</published>
    <updated>2020-02-04T06:41:39.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础步骤"><a href="#基础步骤" class="headerlink" title="基础步骤"></a>基础步骤</h3><ol><li><p>安装Hbuilder-APP开发版本<a href="https://www.dcloud.io/hbuilderx.html" target="_blank" rel="noopener">链接</a></p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200204132006067.png" alt="image-20200204132006067"></p></li><li><p>文件 -&gt; 新建 -&gt; 项目 -&gt; uni-app</p></li></ol><blockquote><p> <code>uni-app</code> 是一个使用 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。 </p></blockquote><ol start="3"><li>运行<a href="https://uniapp.dcloud.io/quickstart" target="_blank" rel="noopener">链接</a></li></ol><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌─components            uni-app组件目录</span><br><span class="line">│  └─comp-a.vue         可复用的a组件</span><br><span class="line"></span><br><span class="line">├─pages                 存放业务页面文件</span><br><span class="line">│  ├─index</span><br><span class="line">│  │  └─index.vue       index页面</span><br><span class="line">│  └─list</span><br><span class="line">│     └─list.vue        list页面</span><br><span class="line"></span><br><span class="line">├─static                存放应用引用静态资源的目录</span><br><span class="line"></span><br><span class="line">├─main.js               Vue初始化入口文件</span><br><span class="line">├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期</span><br><span class="line">├─manifest.json         配置应用名称、appid、logo、版本等打包信息</span><br><span class="line">└─pages.json            配置页面路由、导航条、选项卡等页面类信息</span><br></pre></td></tr></table></figure><ul><li><p>wxcomponents：存放小程序组件的目录，<a href="https://uniapp.dcloud.io/frame?id=小程序组件支持" target="_blank" rel="noopener">详见</a> </p></li><li><p>hybrid：存放本地网页的目录，<a href="https://uniapp.dcloud.io/component/web-view" target="_blank" rel="noopener">详见</a> </p></li><li><p>platforms ：存放各平台专用页面的目录，<a href="https://uniapp.dcloud.io/platform?id=整体目录条件编译" target="_blank" rel="noopener">详见</a> </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础步骤&quot;&gt;&lt;a href=&quot;#基础步骤&quot; class=&quot;headerlink&quot; title=&quot;基础步骤&quot;&gt;&lt;/a&gt;基础步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装Hbuilder-APP开发版本&lt;a href=&quot;https://www.dcloud.io/hbui
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试题--HTTP</title>
    <link href="https://turing5467.github.io/2020/01/17/%E9%9D%A2%E8%AF%95/HTTP/"/>
    <id>https://turing5467.github.io/2020/01/17/面试/HTTP/</id>
    <published>2020-01-16T16:00:00.000Z</published>
    <updated>2020-06-17T10:02:30.456Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://github.com/Advanced-Interview-Question/front-end-interview/blob/dev/docs/guide/http.md" target="_blank" rel="noopener">github</a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li>超文本传输协议，是互联网上应用最为广泛的一种网络协议。用于从WWW服务器传输超文本到本地浏览器的传送协议</li></ul><h4 id="1-HTTP有哪些方法？"><a href="#1-HTTP有哪些方法？" class="headerlink" title="1.HTTP有哪些方法？"></a>1.HTTP有哪些方法？</h4><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法</p><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</p><ul><li>GET: 通常用于请求服务器发送某些资源</li><li>HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. <ul><li>一个使用场景：在下载一个大文件前先获取其大小再决定是否要下载，节约带宽资源</li></ul></li><li>POST: 发送数据给服务器</li><li>OPTIONS: 用于获取目的资源所支持的通信选项</li><li>PUT: 用于<strong>新增</strong>资源或者使用请求中的有效负载<strong>替换</strong>目标资源的表现形式</li><li>DELETE: 用于<strong>删除</strong>指定的资源</li><li>PATCH: 用于对资源进行<strong>部分修改</strong></li><li>CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li><li>TRACE: 回显服务器收到的请求，主要用于<strong>测试或诊断</strong></li></ul><h4 id="2-GET和POST有什么区别"><a href="#2-GET和POST有什么区别" class="headerlink" title="2.GET和POST有什么区别"></a>2.GET和POST有什么区别</h4><p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9050b9d08a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><ul><li>数据传输：GET请求参数放在URL上，POST请求参数放在请求体里</li><li>请求长度：GET请求有限制，POST请求可以非常大</li><li>安全性：POST请求相较于GET请求<strong>安全</strong>一点点，因为GET请求的参数在URL上，且有历史记录</li><li>缓存：GET请求能<strong>缓存</strong>，POST不能</li><li>数据类型：GET只允许 ASCII 字符，而POST无限制 </li></ul></blockquote><p>其实HTTP协议并没有要求GET/POST请求参数必须放在URL上或请求体里，也没有规定GET请求的长度，目前对URL的长度限制，是各家浏览器设置的限制。GET和POST的根本区别在于：<strong>GET请求是幂等性的，而POST请求不是</strong> </p><blockquote><p>幂等性： 对某一资源进行一次或多次请求都具有相同的副作用。</p><p>例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。 </p></blockquote><p> 由于GET请求是幂等的，在网络不好的环境中，GET请求可能会重复尝试，造成重复操作数据的风险，因此，GET请求用于无副作用的操作(如搜索)，新增/删除等操作适合用POST </p><h4 id="3-PUT和POST都是给服务器发送新增资源，有什么区别"><a href="#3-PUT和POST都是给服务器发送新增资源，有什么区别" class="headerlink" title="3.PUT和POST都是给服务器发送新增资源，有什么区别"></a>3.PUT和POST都是给服务器发送新增资源，有什么区别</h4><p> PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。 </p><p>举个例子，我们在开发一个博客系统，当我们要创建一篇文章的时候往往用<code>POST https://www.jianshu.com/articles</code>，这个请求的语义是，在articles的资源集合下创建一篇新的文章，如果我们多次提交这个请求会创建多个文章，这是非幂等的。</p><p>而<code>PUT https://www.jianshu.com/articles/820357430</code>的语义是更新对应文章下的资源（比如修改作者名称等）</p><h4 id="4-PUT和PATCH都是给服务器发送修改资源，有什么区别？"><a href="#4-PUT和PATCH都是给服务器发送修改资源，有什么区别？" class="headerlink" title="4.PUT和PATCH都是给服务器发送修改资源，有什么区别？"></a>4.PUT和PATCH都是给服务器发送修改资源，有什么区别？</h4><p> PUT和PATCH都是更新资源，而PATCH用来对已知资源进行<strong>局部更新</strong>。 </p><p>比如我们有一篇文章的地址<code>https://www.jianshu.com/articles/820357430</code>,这篇文章的可以表示为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">article = &#123;</span><br><span class="line">    author: &apos;dxy&apos;,</span><br><span class="line">    creationDate: &apos;2019-6-12&apos;,</span><br><span class="line">    content: &apos;我写文章像蔡徐坤&apos;,</span><br><span class="line">    id: 820357430</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们要修改文章的作者时，我们可以直接发送<code>PUT https://www.jianshu.com/articles/820357430</code>，这个时候的数据应该是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    author:&apos;蔡徐坤&apos;,</span><br><span class="line">    creationDate: &apos;2019-6-12&apos;,</span><br><span class="line">    content: &apos;我写文章像蔡徐坤&apos;,</span><br><span class="line">    id: 820357430</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种直接覆盖资源的修改方式应该用put，但是你觉得每次都带有这么多无用的信息，那么可以发送<code>PATCH https://www.jianshu.com/articles/820357430</code>，这个时候只需要:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    author:&apos;蔡徐坤&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-HTTP的请求报文由哪几部分组成"><a href="#5-HTTP的请求报文由哪几部分组成" class="headerlink" title="5.HTTP的请求报文由哪几部分组成"></a>5.HTTP的请求报文由哪几部分组成</h4><p> 一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成 </p><p><img src="C:%5CUsers%5CAdministrator%5CDesktop%5Ctr%5CimgURL%5C%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200519111919.jpg" alt></p><p> 响应报文和请求报文结构类似，不再赘述 </p><h4 id="6-HTTP常见请求-响应头及其含义"><a href="#6-HTTP常见请求-响应头及其含义" class="headerlink" title="6.HTTP常见请求/响应头及其含义"></a>6.HTTP常见请求/响应头及其含义</h4><ul><li><p>通用头（请求头和响应头都有）</p><table><thead><tr><th>字段</th><th align="left">作用</th><th>值</th></tr></thead><tbody><tr><td>Cache-Control</td><td align="left">控制缓存</td><td><code>public</code>：表示响应可以被任何对象缓存(包括客户端/代理服务器) <br><code>private</code>(默认值)：响应只能被单个客户缓存,不能被代理服务器缓存 <br><code>no-cache</code>：缓存要经过服务器验证，在浏览器使用缓存前，会对比ETag，若没变则返回304，使用缓存<br> <code>no-store</code>：禁止任何缓存</td></tr><tr><td>Connection</td><td align="left">是否需要持久连接(HTTP 1.1默认持久连接)</td><td>keep-alive / close</td></tr><tr><td>Transfer-Encoding</td><td align="left">报文主体的传输编码格式</td><td>chunked(分块) / identity(未压缩和修改) / gzip(LZ77压缩) / compress(LZW压缩,弃用) / deflate(zlib结构压缩)</td></tr></tbody></table></li><li><p>请求头</p><table><thead><tr><th>字段</th><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>Accept</td><td>告知（服务器）客户端可以处理的内容类型</td><td>text/html、image/*等</td></tr><tr><td>If-Modified-Since</td><td>将<code>Last-Modified</code>的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304</td><td>示例：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</td></tr><tr><td>If-Unmodified-Since</td><td>将<code>Last-Modified</code>的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传。通俗点说<code>If-Unmodified-Since</code>是文件没有修改时下载，<code>If-Modified-Since</code>是文件修改时下载</td><td>示例：If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT</td></tr><tr><td>If-None-Match</td><td>将<code>ETag</code>的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304</td><td>示例：If-None-Match: “bfc13a6472992d82d”</td></tr><tr><td>If-Match</td><td>将<code>ETag</code>的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传</td><td>示例：If-Match: “bfc129c88ca92d82d”</td></tr><tr><td>Range</td><td>告知服务器返回文件的哪一部分, 用于断点续传</td><td>示例：Range: bytes=200-1000, 2000-6576, 19000-</td></tr><tr><td>Host</td><td>指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号</td><td>示例：Host:<a href="http://www.baidu.com[12]" target="_blank" rel="noopener">www.baidu.com[12]</a></td></tr><tr><td>User-Agent</td><td>告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本</td><td><code>User-Agent: Mozilla/&lt;version&gt; (&lt;system-information&gt;) &lt;platform&gt; (&lt;platform-details&gt;) &lt;extensions&gt;</code></td></tr></tbody></table></li><li><p>响应头</p><table><thead><tr><th>字段</th><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>Location</td><td>需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义</td><td>Location: <code>&lt;url&gt;</code></td></tr><tr><td>ETag</td><td>资源的特定版本的标识符，如果内容没有改变，Web服务器不需要发送完整的响应</td><td>ETag: “<code>&lt;etag_value&gt;</code>“</td></tr><tr><td>Server</td><td>处理请求的源头服务器所用到的软件相关信息</td><td>Server: <code>&lt;product&gt;</code></td></tr></tbody></table></li><li><p>实体头（针对请求报文和响应报文的实体部分使用首部） </p><table><thead><tr><th>字段</th><th>作用</th><th>语法</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持http请求的方法</td><td>Allow: <code>&lt;http-methods&gt;</code>，示例：Allow: GET, POST, HEAD</td></tr><tr><td>Last-Modified</td><td>资源最后的修改时间，用作一个验证器来判断接收到的或者存储的资源是否彼此一致，精度不如ETag</td><td>示例：Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT</td></tr><tr><td>Expires</td><td>响应过期时间</td><td>Expires:<code>&lt;http-date&gt;</code>，示例：Expires: Wed, 21 Oct 2020 07:28:00 GMT</td></tr></tbody></table></li></ul><h4 id="7-HTTP状态码"><a href="#7-HTTP状态码" class="headerlink" title="7.HTTP状态码"></a>7.HTTP状态码</h4><p>2XX 成功</p><ul><li><strong>200 OK</strong>，表示从客户端发来的请求在服务器端被正确处理 ✨</li><li>201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立</li><li>202 Accepted 请求已接受，但是还没执行，不保证完成请求</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>206 Partial Content，进行范围请求 ✨</li></ul><p>3XX 重定向</p><ul><li><strong>301 moved permanently</strong>，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL ✨</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源</li><li><strong>304 not modified</strong>，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义相同</li></ul><p>4XX 客户端错误</p><ul><li><strong>400 bad request</strong>，请求报文存在语法错误 ✨</li><li><strong>401 unauthorized</strong>，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨</li><li><strong>403 forbidden</strong>，表示对请求资源的访问被服务器拒绝 ✨</li><li><strong>404 not found</strong>，表示在服务器上没有找到请求的资源 ✨</li><li>408 Request timeout, 客户端请求超时</li><li>409 Confict, 请求的资源可能引起冲突</li></ul><p>5XX 服务器错误</p><ul><li><code>500 internal sever error</code>，表示服务器端在执行请求时发生了错误 ✨</li><li><code>501 Not Implemented</code> 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法</li><li><code>502 Bad Gateway</code>：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 </li><li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li><li>505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本</li></ul><h4 id="8-同样是重定向307，303，302的区别？"><a href="#8-同样是重定向307，303，302的区别？" class="headerlink" title="8.同样是重定向307，303，302的区别？"></a>8.同样是重定向307，303，302的区别？</h4><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码又出来了两个303和307。</p><p>303明确表示客户端应当采用get方法获取资源，他会把POST请求变为GET请求进行重定向。 307会遵照浏览器标准，不会从post变为get。</p><h4 id="9-HTTP的keep-alive是干什么的？"><a href="#9-HTTP的keep-alive是干什么的？" class="headerlink" title="9.HTTP的keep-alive是干什么的？"></a>9.HTTP的keep-alive是干什么的？</h4><p>在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。</p><p>在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入<code>Connection: keep-alive</code>来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。</p><p>keep-alive的优点：</p><ul><li>较少的CPU和内存的使用（由于同时打开的连接的减少了）</li><li>允许请求和应答的HTTP管线化</li><li>降低拥塞控制 （TCP连接减少了）</li><li>减少了后续请求的延迟（无需再进行握手）</li><li>报告错误无需关闭TCP连</li></ul><h4 id="10-OSI七层模型"><a href="#10-OSI七层模型" class="headerlink" title="10.OSI七层模型"></a>10.OSI七层模型</h4><p><img src="C:%5CUsers%5CAdministrator%5CDesktop%5Ctr%5CimgURL%5C%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200519110015.jpg" alt></p><table><thead><tr><th>模型</th><th>概述</th><th>单位</th></tr></thead><tbody><tr><td>物理层</td><td>网络连接介质，如网线、光缆，数据在其中以比特为单位传输</td><td>bit</td></tr><tr><td>数据链路层</td><td>数据链路层将比特封装成数据帧并传递</td><td>帧</td></tr><tr><td>网络层</td><td>定义IP地址，定义路由功能，建立主机到主机的通信</td><td>数据包</td></tr><tr><td>传输层</td><td>负责将数据进行可靠或者不可靠传递，建立端口到端口的通信</td><td>数据段</td></tr><tr><td>会话层</td><td>控制应用程序之间会话能力，区分不同的进程</td><td></td></tr><tr><td>表示层</td><td>数据格式标识，基本压缩加密功能</td><td></td></tr><tr><td>应用层</td><td>各种应用软件</td><td></td></tr></tbody></table><h4 id="11-HTTP1-1和HTTP1-0有什么区别"><a href="#11-HTTP1-1和HTTP1-0有什么区别" class="headerlink" title="11.HTTP1.1和HTTP1.0有什么区别"></a>11.HTTP1.1和HTTP1.0有什么区别</h4><p><strong>长连接：</strong> HTTP/1.1支持长连接和请求的流水线，在一个TCP连接上可以传送多个HTTP请求，避免了因为多次建立TCP连接的时间消耗和延时</p><p><strong>缓存处理：</strong> HTTP/1.1引入<code>Entity tag，If-Unmodified-Since, If-Match, If-None-Match</code>等新的请求头来控制缓存，详见浏览器缓存小节</p><p><strong>带宽优化及网络连接的使用：</strong> HTTP1.1则在请求头引入了<code>range</code>头域，支持<strong>断点续传</strong>功能</p><p><strong>Host头处理：</strong> 在HTTP/1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误</p><h4 id="12-介绍一下HTTP-2-0新特性"><a href="#12-介绍一下HTTP-2-0新特性" class="headerlink" title="12.介绍一下HTTP/2.0新特性"></a>12.介绍一下HTTP/2.0新特性</h4><ul><li><strong>多路复用：</strong> 即多个请求都通过一个TCP连接并发地完成</li><li><strong>服务端推送：</strong> 服务端能够主动把资源推送给客户端</li><li><strong>新的二进制格式：</strong> HTTP/2采用二进制格式传输数据，相比于HTTP/1.1的文本格式，二进制格式具有更好的解析性和拓展性</li><li><strong>header压缩：</strong> HTTP/2压缩消息头，减少了传输数据的大小</li></ul><h4 id="13-HTTPS与HTTP有何区别"><a href="#13-HTTPS与HTTP有何区别" class="headerlink" title="13.HTTPS与HTTP有何区别"></a>13.HTTPS与HTTP有何区别</h4><ul><li>HTTPS使用443端口，而HTTP使用80</li><li>HTTPS需要申请证书</li><li>HTTP是超文本传输协议，是明文传输；HTTPS是经过SSL加密的协议，传输更安全</li><li>HTTPS比HTTP慢，因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包</li></ul><h4 id="HTTPS如何进行加密"><a href="#HTTPS如何进行加密" class="headerlink" title="HTTPS如何进行加密"></a>HTTPS如何进行加密</h4><p> 我们通过分析几种加密方式，层层递进，理解HTTPS的加密方式以及为什么使用这种加密方式： </p><ol><li><p><strong>对称加密</strong>： 客户端和服务器公用一个密匙用来对消息加解密。 </p><p> 一定程度上保证了数据的安全性，但<strong>密钥一旦泄露</strong>(密钥在传输过程中被截获)，传输内容就会暴露，因此我们要寻找一种安全传递密钥的方法。 </p></li><li><p><strong>非对称加密</strong>： 客户端和服务端均有一个公钥和私钥，公钥加密的内容只有对应私钥能解。 </p><p> 这样攻击者只拿到传输过程中的公钥也无法破解传输的内容 。</p><p> 但中间人仍然可以用<strong>篡改公钥</strong>的方式来获取或篡改传输内容，而且非对称加密的性能比对称加密的<strong>性能差</strong>了不少 </p></li><li><p><strong>第三方认证</strong>： 第三方使用私钥加密我们<code>自己的公钥</code>（浏览器已经内置一些权威第三方认证机构的公钥），浏览器会使用<code>第三方的公钥</code>来解开<code>第三方私钥加密过的我们的公钥</code>，从而获取公钥，如果能成功解密，就说明获取到的<code>自己的公钥</code>是正确的 </p><p> 但第三方认证也未能完全解决问题，第三方认证是面向所有人的，中间人也能申请证书，如果中间人使用自己的证书掉包原证书，客户端还是无法确认公钥的真伪 </p></li><li><p><strong>数字签名</strong>： 为了让客户端能够验证公钥的来源，我们给公钥加上一个数字签名，这个数字签名是由企业、网站等各种信息和公钥经过单向hash而来，一旦构成数字签名的信息发生变化，hash值就会改变，这就构成了公钥来源的唯一标识。 </p><p>具体来说，服务端本地生成一对密钥，然后拿着公钥以及企业、网站等各种信息到CA(第三方认证中心)去<strong>申请数字证书</strong>，CA会通过一种单向hash算法(比如MD5)，<strong>生成一串摘要</strong>，这串摘要就是这堆信息的唯一标识，然后CA还会使用自己的私钥对摘要进行加密，连同我们自己服务器的公钥一同发送给我我们。</p></li></ol><p>浏览器拿到数字签名后，会使用<strong>浏览器本地内置</strong>的CA公钥解开数字证书并验证，从而拿到正确的公钥。由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密。</p><p>综上所述，HTTPS在<strong>验证阶段</strong>使用<code>非对称加密+第三方认证+数字签名</code>获取正确的公钥，获取到正确的公钥后以<code>对称加密</code>的方式通信</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考&lt;a href=&quot;https://github.com/Advanced-Interview-Question/front-end-interview/blob/dev/docs/guide/http.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试题--JS</title>
    <link href="https://turing5467.github.io/2020/01/16/%E9%9D%A2%E8%AF%95/js/"/>
    <id>https://turing5467.github.io/2020/01/16/面试/js/</id>
    <published>2020-01-15T16:00:00.000Z</published>
    <updated>2020-05-30T08:33:47.930Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h5><ul><li>闭包是基于词法作用域书写代码时所产生的自然结果，它的创建和使用在代码中随处可见</li><li>当函数可以记住并访问所在的<strong>词法作用域</strong>时,就产生了<strong>闭包</strong>,即使函数是在当前词法作用域之外执行</li><li>特点<ol><li>闭包可以访问<strong>外部函数</strong>中定义的变量，即使外部函数已经执行完毕</li><li>闭包还可以访问<strong>外部函数</strong>中定义的<strong>形参</strong>(理论上来说属于第一点)</li><li>闭包可以访问<strong>外部块</strong>中定义的变量，即使外部块已经执行完毕</li></ol></li></ul><blockquote><p>  <strong>词法作用域</strong>是由你在<strong>写代码</strong>时将变量和块作用域写在哪里来决定的   </p></blockquote><ul><li>缺点：滥用闭包会在成内存泄漏，因为闭包中引用到的包裹函数中定义的变量永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数</li></ul><h5 id="apply和call的区别"><a href="#apply和call的区别" class="headerlink" title="apply和call的区别"></a>apply和call的区别</h5><ul><li><p>共同点：都是借用了一个原本不属于一个对象的方法，让当前对象使用</p></li><li><p>传参方式</p><ol><li><code>call</code>：待调用函数的参数以第2, 3, 4, … n,个参数的形式传递给call</li><li><code>apply</code>：待调用函数的参数以<strong>数组</strong>形式传递给apply的第二个参数</li></ol></li><li><p>形参个数</p><ol><li><code>call.length == 1</code></li><li><code>apply.length == 2</code></li></ol></li><li><p>使用场景</p><ul><li><strong>参数数量/顺序</strong>确定就用<code>call</code>，参数数量/顺序不确定的话就用apply。</li><li>考虑可读性：参数<strong>数量</strong>不多就用<code>call</code>，参数数量比较多的话，把参数整合成数组，使用apply。</li><li>参数集合已经是一个数组的情况，用<code>apply</code>，比如获取数组最大值/最小值。</li></ul></li></ul><h5 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h5><ul><li><p>原型：  <strong>构造函数</strong>在创建的过程中，系统自动创建出来与构造函数相关联的一个空的对象。可以由<code>构造函数.prototype</code>来访问到。   </p></li><li><p>每个对象拥有一个原型对象，通过 <strong><strong>proto</strong></strong> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为<strong>原型链 (prototype chain)</strong>，通过原型链一个对象会拥有定义在其他对象中的属性和方法。    </p></li></ul><blockquote><p>补充：</p><ul><li><p><code>__proto__</code>是每个<strong>实例</strong>上都有的属性，指向<strong>自身构造函数</strong>的原型对象   </p></li><li><p><code>constructor</code>属性是<strong>原型对象</strong>的属性，指向这个原型对象所对应的构造函数。 </p></li></ul></blockquote><h5 id="为什么需要原型对象"><a href="#为什么需要原型对象" class="headerlink" title="为什么需要原型对象"></a>为什么需要原型对象</h5><ul><li>通过new生成的实例，相当于是重新开辟了一个<strong>堆区</strong>，虽然是同类型，拥有类似的属性和方法，但是这些属性和方法，并不是相同的 。</li><li>如果只有1、2个实例还好，可如果大量的实例，那么将大量生成这种原本可以复用共用的属性方法，非常<strong>耗费性能</strong>，不利于<strong>复用</strong>，此时我们就需要一个类似共享库的对象，让实例能够沿着原型链，去找。   </li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ol><li>原型链继承</li><li>借助构造函数继承</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生式组合继承</li><li>ES6继承</li></ol><h5 id="new运算符的执行过程"><a href="#new运算符的执行过程" class="headerlink" title="new运算符的执行过程"></a>new运算符的执行过程</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">Con, ...args</span>) </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、创建一个空的对象并链接到原型，相当于obj.__propto__ = Con.prototype</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、执行构造函数，并为其绑定 this </span></span><br><span class="line">    <span class="keyword">var</span> ret = Con.apply(obj,auguments);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、优先返回构造函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h5><ul><li><p>浅拷贝：以复制的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响</p><ul><li><code>Object.assign</code></li><li>展开运算符(…)</li></ul></li><li><p>深拷贝：完全拷贝一个新对象，修改时原对象不再受到任何影</p><ul><li><p><code>JSON.parse(JSON.stringify(obj))</code>: 性能最快</p><ul><li>具有循环引用的对象时，报错</li><li>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</li></ul></li><li><p>递归进行逐一赋值</p></li></ul></li></ul><h5 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h5><ul><li><p>在一个函数中，首先填充几个参数，然后返回一个新的函数的技术，称为函数的柯里化。</p></li><li><p>通常可用于在不侵入函数的前提下，为函数 <strong>预置通用参数</strong>，供多次重复调用。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add1 = add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add1(<span class="number">2</span>) === <span class="number">3</span></span><br><span class="line">add1(<span class="number">20</span>) === <span class="number">21</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><p> JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量（但并不赋值），然后再一行一行地运行。 </p><blockquote><p>一个例外是：使用函数声明式创建的函数，会在所有代码执行之前被创建</p></blockquote><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><ul><li>默认绑定</li><li>隐式绑定</li><li>显式绑定</li><li>new绑定</li><li>箭头函数绑定</li></ul><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200423154554020.png" alt="image-20200423154554020"></p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><ol><li><p>共同点</p><ul><li>块级作用域有效</li><li>不存在变量提升(暂时性死区TDZ)</li><li>不允许重复声明</li></ul></li><li><p>const</p><ul><li>一旦声明，就不能改变，且必须立即初始化</li></ul></li></ol><ul><li>对于<strong>复合类型的变量</strong>，变量指向数据所在的<strong>地址</strong>。 const 命令只保证变量名指向的<strong>地址</strong>不变，并不保证该地址的数据不变。</li></ul><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p> async 函数，就是 Generator 函数的语法糖，使得异步操作更加方便。 </p><ol><li><p>Async—声明一个异步函数</p><ul><li><p>自动将常规函数转换成Promise，返回值也是一个Promise对象</p></li><li><p>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数</p></li><li><p>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。   </p></li></ul></li><li><p>Await—声明一个需要等待结果的表达式，是then命令的语法糖</p><ul><li><p>放置在Promise调用之前，await强制其他代码等待，直到Promise完成并返回结果</p></li><li><p>只能与Promise一起使用，不适用与回调</p></li><li><p>只能在async函数内部使用</p></li></ul></li></ol><ul><li>优点：<ol><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担 </li><li>Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅 </li><li>错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余</li></ol></li></ul><h3 id="——分割线——"><a href="#——分割线——" class="headerlink" title="——分割线——"></a>——分割线——</h3><ul><li><p>为什么 要用<code>void</code><br>因为<code>undefined</code>在js中不是保留字,因而可以作为变量名被赋值,所以不是绝对可靠的而<code>void</code>能保证取到<code>undefined</code>值</p></li><li><p>变量的提前声明</p><p>使用<code>var | function</code>关键字声明的变量,会在所有代码执行之前被<strong>声明</strong>(函数优先)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h4&gt;&lt;h5 id=&quot;闭包是什么&quot;&gt;&lt;a href=&quot;#闭包是什么&quot; class=&quot;headerlink&quot; title=&quot;闭包是什么&quot;&gt;&lt;/a&gt;闭包是什
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
