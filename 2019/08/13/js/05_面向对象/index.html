<!DOCTYPE html><html lang="cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 面向对象 · 快乐的图小灵</title><meta name="description" content="面向对象 - turing5467"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favi.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://turing5467.github.io/atom.xml" title="快乐的图小灵"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">图小灵的博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="https://github.com/turing5467" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">面向对象</h1><div class="post-info">Aug 13, 2019</div><div class="post-content"><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="创建对象方式"><a href="#创建对象方式" class="headerlink" title="创建对象方式"></a>创建对象方式</h3><h4 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name:<span class="string">"图小灵"</span>,</span><br><span class="line">    age:<span class="number">22</span>,</span><br><span class="line">    eat:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'图灵吃饭'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：无法复用</li>
</ul>
<h4 id="2-工厂函数"><a href="#2-工厂函数" class="headerlink" title="2.工厂函数"></a>2.工厂函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    obj.name = name</span><br><span class="line">    obj.age = age</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：无法判断类型</li>
</ul>
<h4 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h4><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="实例属性-方法"><a href="#实例属性-方法" class="headerlink" title="实例属性/方法"></a>实例属性/方法</h4><ul>
<li>绑定在构造函数创建的实例(即<code>this</code>)上，并通过实例来访问</li>
</ul>
<h4 id="静态属性-方法"><a href="#静态属性-方法" class="headerlink" title="静态属性/方法"></a>静态属性/方法</h4><ul>
<li>绑定在<strong>构造函数</strong>上的属性方法，需要通过构造函数访问   </li>
</ul>
<h4 id="原型属性-方法"><a href="#原型属性-方法" class="headerlink" title="原型属性/方法"></a>原型属性/方法</h4><ul>
<li>通过构造函数创建的实例，都共享<strong>构造函数</strong>的<strong>原型对象</strong>上的属性方法，类似共享库。   </li>
</ul>
<h4 id="私有属性-方法"><a href="#私有属性-方法" class="headerlink" title="私有属性/方法"></a>私有属性/方法</h4><ul>
<li>函数内部声明的变量/函数</li>
</ul>
<h4 id="特权方法"><a href="#特权方法" class="headerlink" title="特权方法"></a>特权方法</h4><ul>
<li>能够访问私有成员的实例方法</li>
</ul>
<h3 id="为什么需要原型对象"><a href="#为什么需要原型对象" class="headerlink" title="为什么需要原型对象"></a>为什么需要原型对象</h3><ul>
<li>通过new生成的实例，相当于是重新开辟了一个<strong>堆区</strong>，虽然是同类型，拥有类似的属性和方法，但是这些属性和方法，并不是相同的 。</li>
<li>如果只有1、2个实例还好，可如果大量的实例，那么将大量生成这种原本可以复用共用的属性方法，非常<strong>耗费性能</strong>，不利于<strong>复用</strong>，此时我们就需要一个类似共享库的对象，让实例能够沿着原型链，去找。   </li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">Student.prototype = p;	<span class="comment">// 把Student的原型对象指向实例p</span></span><br><span class="line"></span><br><span class="line">Student.prototype.constructor = Student;	<span class="comment">// 解决类型判断问题</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缺点<ol>
<li>包含引用类型值的原型属性会被所有实例共享   </li>
<li>无法向父类的构造函数中传递参数</li>
</ol>
</li>
</ul>
<h4 id="2-借助构造函数继承"><a href="#2-借助构造函数继承" class="headerlink" title="2.借助构造函数继承"></a>2.借助构造函数继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>) <span class="comment">// * 利用call调用Person上的属性方法拷贝一份到Student（借助构造函数继承）</span></span><br><span class="line">    <span class="keyword">this</span>.num = <span class="string">"030578000"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：<ul>
<li>只能继承父类的<strong>实例</strong>属性和方法，不能继承<strong>原型</strong>属性/方法无法实现复用<ul>
<li>因为call属于普通函数调用(而非构造函数调用，即new)，无继承效果</li>
</ul>
</li>
<li>每个子类都有父类实例函数的副本，影响性能</li>
</ul>
</li>
</ul>
<h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//第二次调用Person()</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>) <span class="comment">// 借助构造函数继承</span></span><br><span class="line">    <span class="keyword">this</span>.num = <span class="string">"030578000"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一份调用Person()</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();  <span class="comment">//原型链继承</span></span><br><span class="line"></span><br><span class="line">Student.prototype.constructor = Student;	<span class="comment">// 解决类型判断问题</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：  在使用子类创建实例对象时，其<strong>原型中会存在两份相同的属性/方法</strong>。   </li>
</ul>
<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h4><ul>
<li>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObjWithObj</span>(<span class="params">obj</span>)</span>&#123; <span class="comment">// * 传入一个原型对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Temp</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    Temp.prototype = obj</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Temp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp = createObjWithObj(Person.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 也可以使用Object.create实现</span></span><br><span class="line"><span class="keyword">let</span> temp2 = <span class="built_in">Object</span>.create(Person.prototype)</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：同原型链继承</li>
</ul>
<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h4><ul>
<li>在<strong>原型式</strong>的基础上，希望给这个对象新增一些属性/方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNewObjWithObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = createObjWithObj(obj)</span><br><span class="line">    o.name = <span class="string">"邵威儒"</span></span><br><span class="line">    o.age = <span class="number">28</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：同原型式继承</li>
</ul>
<h4 id="6-寄生式组合继承-最常用"><a href="#6-寄生式组合继承-最常用" class="headerlink" title="6.寄生式组合继承(最常用)"></a>6.寄生式组合继承(最常用)</h4><ul>
<li>结合借用<strong>构造函数</strong>传递参数和<strong>寄生</strong>模式实现继承   </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">num,name,pets</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,name,pets) <span class="comment">//构造函数传参</span></span><br><span class="line">    <span class="keyword">this</span>.num = num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Child, Parent</span>)</span>&#123;</span><br><span class="line">    Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Student,Person);</span><br></pre></td></tr></table></figure>

<h4 id="7-混入方式继承多个对象"><a href="#7-混入方式继承多个对象" class="headerlink" title="7.混入方式继承多个对象"></a>7.混入方式继承多个对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    SuperClass.call(<span class="keyword">this</span>);     </span><br><span class="line">    OtherSuperClass.call(<span class="keyword">this</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype); 	<span class="comment">// 继承一个类 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype); <span class="comment">// 混合其它 </span></span><br><span class="line"></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br></pre></td></tr></table></figure>

<h4 id="8-ES6继承"><a href="#8-ES6继承" class="headerlink" title="8.ES6继承"></a>8.ES6继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length);</span><br><span class="line">        <span class="comment">//原型属性</span></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//原型方法</span></span><br><span class="line">    <span class="keyword">get</span> area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与ES5继承对比<ul>
<li>ES5的继承实质上是先创建<strong>子类</strong>的实例对象，然后再将<strong>父类</strong>的方法添加到this上（Parent.call(this)）.   </li>
<li>ES6的继承实质上是先创建<strong>父类</strong>的实例对象this，然后再用<strong>子类</strong>的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。   </li>
</ul>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/08/14/js/06_this/" class="prev">上一篇</a><a href="/2019/08/12/js/04_正则/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/08/13/js/05_面向对象/';
var disqus_title = '面向对象';
var disqus_url = 'https://turing5467.github.io/2019/08/13/js/05_面向对象/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2019 - 2020 <a href="https://turing5467.github.io">turing5467</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>