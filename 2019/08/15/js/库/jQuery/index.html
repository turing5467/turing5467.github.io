<!DOCTYPE html><html lang="cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> jQuery API · 快乐的图小灵</title><meta name="description" content="jQuery API - turing5467"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favi.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://turing5467.github.io/atom.xml" title="快乐的图小灵"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">图小灵的博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="https://github.com/turing5467" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">jQuery API</h1><div class="post-info">Aug 15, 2019</div><div class="post-content"><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><blockquote>
<p>Write less, do more</p>
</blockquote>
<ol>
<li>强大的选择器</li>
<li>DOM操作</li>
<li>可靠的事件处理机制</li>
<li>完善的Ajax</li>
<li>不污染顶级变量</li>
<li>出色的<strong>浏览器兼容性</strong></li>
<li>链式调用</li>
<li>隐式迭代</li>
<li>读写二合一</li>
<li>丰富的插件支持</li>
</ol>
<h3 id="jQuery函数"><a href="#jQuery函数" class="headerlink" title="jQuery函数"></a>jQuery函数</h3><h3 id="1"><a href="#1" class="headerlink" title="1.$()"></a>1.$()</h3><ul>
<li><code>$()</code>代表jQuery构造函数,会返回一个jQuery对象</li>
<li>参数<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. $(sel[, context]) 用sel匹配元素</span><br><span class="line">	context: 在context中查找匹配的元素</span><br><span class="line">	</span><br><span class="line">2. $(html[,ownerDoc]) 动态创建DOM元素</span><br><span class="line">	ownerDoc: 一个对象,用来设置创建的元素的属性、事件</span><br><span class="line">	</span><br><span class="line">3. <span class="variable">$(ele)</span> 将元素包装成一个jQuery对象并返回</span><br><span class="line"></span><br><span class="line">4. <span class="variable">$(callback)</span> </span><br><span class="line">	入口函数<span class="variable">$(document)</span>.ready(fn)的简写(document可省)</span><br><span class="line">	jQuery 和 原生JS 的入口函数</span><br><span class="line">		jQuery: </span><br><span class="line">			1. 等到DOM元素加载完毕就执行,不会等到图片也加载完毕</span><br><span class="line">			2. 可编写多个</span><br><span class="line">		原生JS:  </span><br><span class="line">			1. 等到DOM元素加载完毕,并且图片也加载完毕才会执行(因此jQuery入口函数会先于它执行)</span><br><span class="line">			2. 后面的会覆盖前面的</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ul>
<li><code>index([selector | ele | jquery对象])</code>,从0计数<pre><code>    不传入参数: 返回集合中第一个元素 相对于 其**同辈元素**的位置。
传入**同辈**`DOM元素/jq对象` ,返回传入元素在原集合中的位置,
如果找不到匹配的元素，则返回`-1`。 </code></pre></li>
<li><code>each(object[,callback(index,value)])</code>  遍历匹配的元素集合<pre><code>`callback`若返回`false`,则退出遍历(相当于`break`)
                    若返回`true`,则推出本次循环,相当于`continue`</code></pre></li>
<li><code>map(callback(index,value))</code>将一组元素转化为类似数组对象</li>
<li><code>load(url[,data[, callback]])</code> 载入远程 HTML 文件代码并插入至 DOM 中。<pre><code>`(test.html .inner(选择器))`载入部分的 HTML 文档(`outerHTML`)
`callback`参数为文档本身</code></pre></li>
<li><code>get([index])</code> 返回第<code>index</code>位置的DOM元素 , 与<code>[index]</code>等价<pre><code>不传参: 返回匹配的DOM元素集合</code></pre> 补充:  <code>eq(index | -index)</code>返回的是<code>jQuery</code>对象</li>
<li><code>data([key[, value] | obj])</code> <strong>读取</strong><code>data-[key]</code>属性<pre><code>不传参,获取自定义属性集合    </code></pre>  移除: <code>removeData()</code> 可传入多属性字符串</li>
</ul>
<h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><ul>
<li><p><code>length</code>集合中元素个数,可用于判断是否有匹配元素</p>
</li>
<li><p><code>selector</code>返回传给jQuery()的原始选择器</p>
</li>
<li><p><code>context</code>返回传给<code>jQuery()</code>的第二个参数</p>
</li>
</ul>
<ul>
<li><p>$冲突问题</p>
<ol>
<li><p>释放$使用权: <code>jQuery.noConflict();</code></p>
</li>
<li><p>a. 创建别名: <code>var jq = jQuery.noConflict();</code></p>
<p>b. 匿名函数内部传参</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params">alia</span>)</span>&#123;</span><br><span class="line"> 	<span class="comment">//alia即为匿名函数内部使用的别名   </span></span><br><span class="line">&#125;(jQuery)</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.type(obj)判断数据类型 number boolean string <span class="literal">null</span> <span class="literal">undefined</span> array object date regexp</span><br><span class="line">$.param(o) 序列化对象或表单元素数组,是serialize的核心方法</span><br><span class="line">	xx.serialize() 序列化DOM元素内容,返回字符串</span><br><span class="line">	xx.serializeArray() 序列化DOM元素内容,返回<span class="built_in">JSON</span>格式的数据</span><br><span class="line">$.param($(<span class="string">"input"</span>))==$(<span class="string">"input"</span>).serialize()==$(<span class="built_in">document</span>.forms[<span class="number">0</span>]).serialize()</span><br><span class="line">$.error(message) 抛出message字符串的异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.each(object[,callback(index,value)])  遍历数组/对象</span><br><span class="line">$.map(arr|obj,fn(value,key)) 映射数组/伪数组方法,返回由返回值组成的数组</span><br><span class="line">	jq中只有此函数函数的参数值为value,index</span><br><span class="line"></span><br><span class="line">$.isArray(obj) 判断传入对象是否为真数组,返回<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">$.isEmptyObject(obj) 是否为空对象(&#123;&#125;为<span class="literal">true</span>)</span><br><span class="line">$.isPlainObject(obj) 是否为纯粹的对象,通过&#123;&#125;或<span class="keyword">new</span> <span class="built_in">Object</span>创建</span><br><span class="line">$.holdReady(<span class="literal">true</span>/<span class="literal">false</span>)   需要写在入口函数外边</span><br><span class="line">	<span class="literal">true</span>: 暂停入口函数执行</span><br><span class="line">	<span class="literal">false</span>: 恢复入口函数执行</span><br></pre></td></tr></table></figure>

<h3 id="3-筛选元素"><a href="#3-筛选元素" class="headerlink" title="3.筛选元素"></a>3.筛选元素</h3><ul>
<li><p><code>end()</code> 回到最近的一个”破坏性”操作之前,更加方便链式调用.</p>
</li>
<li><p><strong>元素集合</strong>中筛选</p>
<ol>
<li><code>eq(index | -index)</code></li>
<li><code>first()</code> <code>last()</code> </li>
<li><code>is(selector | jq | DOM | fn(index))</code><br>只要元素集合中有一个元素符合 参数 就返回`true``</li>
<li>``has(selector | DOM)` 保留包含特定<strong>后代元素</strong>的元素</li>
<li><code>not(selector | DOM | fn)</code> 排除</li>
<li><code>slice(start [,end])</code> 元素集合的子集</li>
</ol>
</li>
<li><p><strong>后代元素</strong>中筛选</p>
<ol>
<li><code>children([selector])</code> <strong>子元素</strong>集合(不包括后代元素)</li>
<li><code>contents()</code> 所有<strong>子节点</strong>(包括文本节点)</li>
<li><code>find( selector | jq | DOM)</code> 返回匹配的<strong>后代元素</strong> の 集合</li>
</ol>
</li>
<li><p><strong>祖先元素</strong>中筛选</p>
<ol>
<li><code>parent(selector)</code> 返回元素集合的<strong>父元素</strong>集合</li>
<li><code>parents(selector)</code> 元素集合的<strong>祖先元素</strong>集合</li>
<li><code>parentUntil([ selector|DOM [, filterStr] ])</code> 查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止(不包含该元素)。</li>
<li><code>closest(selector | jq | DOM)</code>返回最先匹配的<strong>祖先元素</strong></li>
<li><code>offsetParent()</code>最近的定位祖先元素,没有则返回<code>html</code>对象</li>
</ol>
</li>
<li><p>同辈元素中筛选</p>
<ol>
<li><code>next( [selector] )</code>返回元素集合中每一个元素后面的<strong>紧邻</strong>的同辈元素的集合</li>
<li><code>nextAll([selector])</code>  后面的<strong>所有</strong>同辈元素的集合</li>
<li><code>nextUntil([ selector|DOM [, filterStr] ])</code></li>
<li><code>prev()</code> <code>prevAll</code> <code>prevUntil</code> 同`next``</li>
<li>``siblings( [selector] )` 同辈元素集合</li>
</ol>
</li>
<li><p>选择器</p>
<ol>
<li>基本选择器 <code>#(单个) . ele  * ,</code></li>
<li>层级选择器 <code>&gt; + ~</code></li>
<li>过滤选择器<br><code>:first  :last</code> <strong>单个</strong><br><code>:not(sel)</code><br><code>:even  :odd</code><br><code>:eq(index)</code>单个<br><code>:gt(index)  :lt(index)</code><br><code>:header(index) 所有标题元素</code><br><code>:animated 正在执行动画的所有元素</code><br><code>:focus 焦点元素</code></li>
<li>内容过滤选择器<br><code>:contains(text) 文本中包含text的元素</code><br><code>:empty 不包含子元素或文本的空元素</code><br><code>:has(selector) 含有选择器所匹配的元素的元素</code><br><code>:parent 含有子元素或文本</code><br><code>:hidden  :visible 所有不可见/可见的元素</code></li>
<li>属性选择器<br><code>[attr]</code>    <code>[attr=value]</code>    <code>[attr!=value]</code><br><code>^=(开头)  $=(结尾)  *=(全局)  ~=(单词)</code></li>
<li>子元素过滤选择器<br><code>nth-child(index/even/odd)   nth-of-type</code><br><code>first-child :last-child :only-child</code>集合<br><code>first-of-type :last-of-type   :only-of-type</code></li>
<li>表单过滤<br><code>:enabled :disable :checked :selected</code>表单选择<br><code>:input  所有的input textarea select button</code><br><code>:text 所有单行文本框</code><br><code>:password</code> <code>:radio :checkout :submit :image :reset :button :file</code></li>
</ol>
</li>
</ul>
<h3 id="4-DOM操作"><a href="#4-DOM操作" class="headerlink" title="4.DOM操作"></a>4.DOM操作</h3><ul>
<li><p>插入</p>
<blockquote>
<p>为方便比较，假设调用者元素为a，参数元素为b</p>
</blockquote>
<ol>
<li><code>append()</code>   向(每个)a中追加b</li>
<li><code>appendTo()</code> 将a追加至b</li>
<li><code>prepend()</code> 向a中前置b</li>
<li><code>prependTo()</code> 向b中前置a</li>
</ol>
</li>
<li><p>删除 </p>
<ol>
<li><code>empty()</code> 清空元素所有的<strong>后代节点</strong></li>
<li><code>remove([ele])</code>  删除所有匹配的元素,只保留元素本身,事件、数据不保存</li>
<li><code>detach()</code> 删除所有匹配的元素 同时保留元素、事件、数据</li>
</ol>
</li>
<li><p>复制</p>
<ol>
<li><code>clone([true]) 参数表示 是否同时复制事件处理函数</code></li>
</ol>
</li>
<li><p>其他</p>
<ol>
<li><code>replaceWith( jq | html )</code> 将匹配元素替换为指定的DOM元素的内容或html代码</li>
<li><code>replaceAll( selector )</code> 用匹配的元素将选<code>selector</code>匹配的元素替换掉</li>
<li><code>wrap( html | DOM | fn)</code> 将<strong>每个</strong>匹配元素都用 <code>html/DOM元素/fn返回值</code> 包裹起来</li>
<li><code>wrapAll(html | DOM)</code>将<strong>所有</strong>匹配的元素用<strong>单个</strong>元素包裹起来</li>
<li><code>wrapInner( html | DOM | fn )</code>将<strong>每个</strong>匹配元素的<strong>子节点</strong>用<code>HTML</code>包裹</li>
<li><code>unwrap</code> 移除元素的父元素<h4 id="4-5-HTML操作"><a href="#4-5-HTML操作" class="headerlink" title="4-5 HTML操作"></a>4-5 HTML操作</h4><blockquote>
<p>若调用者为元素集合,  <strong>写多读少原则</strong><br><strong>写</strong>操作时,会对每个元素进行操作<br><strong>读</strong>操作时,只会读取第一个元素中的内容</p>
</blockquote>
</li>
</ol>
</li>
<li><p>内容、属性</p>
</li>
</ul>
<ol>
<li><code>html(val | fn)</code>   </li>
<li><code>text(val | fn)</code>  若调用者为元素集合,则所有标签的<code>text</code>拼接在一起<pre><code>若传递了参数,则会设置每个标签的`html`内容</code></pre></li>
<li><code>attr(name, val?  | attrs)</code><pre><code>`removeAttr(name)`移除属性    </code></pre></li>
<li><code>prop()</code> <pre><code>`removeProp`</code></pre></li>
</ol>
<blockquote>
<p><em>attribute</em>是HTML元素(标签)的属性，是<strong>静态</strong>的，在写<code>html</code>代码时就已确定<br><em>property</em>是HTML元素(标签)对应<strong>DOM对象</strong>的属性，是<strong>动态</strong>的，会响应用户操作。<br>建议: 布尔值使用<code>prop()</code>   非布尔值使用<code>attr()</code>(成本低)</p>
</blockquote>
<ol start="4">
<li><code>val([val | fn | arr])</code> 设置元素的<code>value</code>值<pre><code>`val`要设置的`value`值
`fn` 返回要设置的`value`值
`arr` 用于 `check/select` 的值
对于 `&lt;select multiple=&quot;multiple&quot;&gt;` `val()`方法返回选中的`option`的`text`值的数组.</code></pre></li>
</ol>
<ul>
<li><code>class</code>操作<code>类操作会对整个元素集合进行操作</code><ol>
<li><code>hasClass()</code>只能传入单类名字符串</li>
<li><code>addClass(class | fn)</code> 可传入多类名字符串<pre><code>`fn`返回由一个或多个空格分隔の类名</code></pre></li>
<li><code>removeClass([class | fn])</code>  不可传入多个类名</li>
<li><code>toggleClass(class|fn[,sw])</code> 可多类名,一个一个判断切换<pre><code>`sw`用于决定元素是否包含`class`的布尔值</code></pre></li>
</ol>
</li>
</ul>
<h3 id="5-CSS"><a href="#5-CSS" class="headerlink" title="5.CSS"></a>5.CSS</h3><ul>
<li><p>css样式<br>@[写多读少原则]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(selector).css(name,value)   为所有匹配元素 设置值</span><br><span class="line">$(selector).css(&#123;properties&#125;) 为所有匹配元素 设置多个值</span><br><span class="line">$(selector).css(name)         读</span><br><span class="line">$(selector).css(name,function(index,value)&#123;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>位置相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">---只读---</span><br><span class="line">	position()		</span><br><span class="line">		获取匹配元素相对父元素的偏移。</span><br><span class="line">		返回值为一个对象,对象有left,top两个整型属性</span><br><span class="line"></span><br><span class="line">	innerWidth()  innerHeight()   </span><br><span class="line">		获取padding-box宽/高</span><br><span class="line">	outerWidth()  outerHeight()</span><br><span class="line">		获取border-box宽/高,传入true返回margin-box的宽高</span><br><span class="line">---可写---</span><br><span class="line">	offset(&#123;left,top&#125;)	</span><br><span class="line">		获取/设置匹配元素在当前视口的相对偏移</span><br><span class="line">		返回值/参数为一个对象,对象有left,top两个整型属性</span><br><span class="line">	scrollTop(val)  scrollLeft(val)</span><br><span class="line">		获取或设置元素相对滚动条顶部的偏移(int)</span><br><span class="line">	width(val | fn) height()   获取content-box的宽高</span><br><span class="line">		1.获取第一个匹配元素当前计算的宽度值</span><br><span class="line">		2.设置宽度([String|Number] | [function(index,value)])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-事件处理"><a href="#6-事件处理" class="headerlink" title="6.事件处理"></a>6.事件处理</h3><blockquote>
<p>不传入参数则集合元素中 每个元素都触发事件<br><code>data</code>为要传入处理函数的<strong>额外参数</strong>,通过<code>e.data</code>访问,可以是对象or数组</p>
</blockquote>
<ul>
<li><code>on(events,[selector],[data],fn)</code> 添加事件(可添加<strong>自定义</strong>)<pre><code>一个事件类型可绑定多个函数，且事件绑定是**动态**的
通过传入第二个参数可以实现**事件委托**,这时回调的`this`指向触发元素</code></pre></li>
<li><code>off(events,[selector],[fn])</code></li>
<li><code>one(type,[data,fn])</code> 为匹配元素绑定<strong>一次性</strong>的事件处理函数</li>
<li><code>trigger(type,[data])</code> 模拟xx事件的触发,作用于所有选中的标签，会冒泡<pre><code>应用(按键精灵)</code></pre></li>
<li><code>triggerHandler(type,data)</code>作用于集合元素中第一个元素，不会冒泡<br>  如果你对一个focus事件执行了 .triggerHandler() ，浏览器默认动作将不会被触发，只会触发你绑定的动作。</li>
</ul>
<blockquote>
<p>传入参数时,表示绑定事件<br><strong>不传入参数,则触发事件</strong>(失去焦点+ 回掉函数)<br>只可绑定一种同类型事件</p>
</blockquote>
<ul>
<li><code>blur([[data,] fn])</code>    </li>
<li><code>focus([[data,]fn])</code></li>
<li><code>focusin([[data,]fn])</code> 可以检测自身及<strong>子元素</strong>获取焦点事件</li>
<li><code>focusout([[data,]fn])</code>  可以检测自身及<strong>子元素</strong>失去焦点事件</li>
<li><code>change([[data,]fn])</code> 当元素值发生改变且失去焦点时触发</li>
<li><code>click([[data,]fn])</code></li>
<li><code>dblclick([[data,]fn])</code></li>
<li><code>keydown([[data,]fn])</code><ul>
<li><code>keyup([[data,]fn])</code></li>
<li><code>keypress([[data,]fn])</code>  只有输入字符在触发<br>发生在获得焦点的元素上,<br>如果在<code>document</code>设置，则无论是否获得焦点，事件都会发生。</li>
</ul>
</li>
<li><code>mousedown([[data,]fn])</code></li>
<li><code>mouseup([[data,]fn])</code></li>
<li><code>mouseenter([[data,]fn])</code></li>
<li><code>mouseleave([[data,]fn])</code></li>
<li><code>mouseover([[data,]fn])</code> 穿过子元素也会触发</li>
<li><code>mouseout([[data,]fn])</code>离开任何子元素也会触发</li>
<li><code>mousemove([[data,]fn])</code></li>
<li><code>resize([[data,]fn])</code></li>
<li><code>scroll([[data,]fn])</code> 使用与所有可滚动的元素和window对象</li>
<li><code>select([[data,]fn])</code>当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。</li>
<li><code>submit([[data,]fn])</code> 提交表单时,会触发<code>submit</code>事件</li>
<li><code>hover([overFn,]outFn)</code> 绑定移入事件 ,移除事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给还不存在的元素绑定事件</span></span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">"click"</span>,<span class="string">'.download-resume'</span>, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    	alert(<span class="string">"ok"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="6-1-事件对象"><a href="#6-1-事件对象" class="headerlink" title="6.1 事件对象"></a>6.1 事件对象</h5><ul>
<li><p>属性</p>
<ol>
<li><code>currentTarget</code>  在事件冒泡阶段中的当前DOM元素</li>
<li><code>delegateTarget</code> 委托元素</li>
<li><code>target</code>最初触发事件的DOM元素</li>
<li><code>pageX</code> <code>pageY</code> 鼠标相对与文档左/上的位置</li>
<li><code>clientX/Y</code> 可视区 <code>offsetX/Y</code> 相对 </li>
<li><code>result</code> 当前事件触发的处理函数的返回值</li>
<li><code>timeStamp</code> 事件触发时距离1970年1月1日的毫秒数。</li>
<li><code>type</code>事件类型</li>
<li><code>which</code></li>
<li>…</li>
</ol>
</li>
<li><p>方法</p>
<ol>
<li><code>isDefaultPrevented()</code> 是否禁止默认行为</li>
<li><code>preventDefault()</code>;</li>
<li><code>isImmediatePropagationStopped()</code></li>
<li><code>stopImmediatePropagation()</code> 阻止所有事件冒泡到DOM树上</li>
<li><code>isPropagationStopped()</code> </li>
<li><code>stopPropagation()</code> 组织当前事件冒泡到DOM树上</li>
</ol>
</li>
</ul>
<h5 id="6-2动画函数"><a href="#6-2动画函数" class="headerlink" title="6.2动画函数"></a>6.2动画函数</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">callback为动画完成时执行的函数</span><br><span class="line">切换</span><br><span class="line">	hide(speed,callback) 隐藏HTML元素</span><br><span class="line">	show(speed,callback) 显示HTML元素</span><br><span class="line">	toggle(speed,callback) 切换 HTML 元素的可见状态</span><br><span class="line">		speed 默认0ms,可设<span class="symbol">:<span class="string">"slow"</span></span>, <span class="string">"fast"</span>, <span class="string">"normal"</span> 或 毫秒数</span><br><span class="line">滑动</span><br><span class="line">	slideDown(speed,callback)  向下滑动元素(高度增大) </span><br><span class="line">	(selector).slideUp(speed,callback)    向上滑动元素(降低元素的可见高)</span><br><span class="line">	slideToggle(speed,callback) 在向上、向下之间进行切换</span><br><span class="line">Fade函数</span><br><span class="line">	fadeIn(speed,callback)   元素透明度变为为<span class="number">0</span>,占位</span><br><span class="line">	fadeOut(speed,callback)  元素褪色至透明度为<span class="number">0</span>,且不占位置</span><br><span class="line">	fadeTo(speed,opacity,callback) 元素褪色至透明度为x,占位置</span><br><span class="line">	fadeToggle</span><br><span class="line">自定义动画</span><br><span class="line">	animate(&#123;params&#125;,[speed],[easing],[fn])</span><br><span class="line">		 <span class="symbol">params:</span> 定义产生动画的属性(驼峰形式)</span><br><span class="line">		 <span class="symbol">duration:</span> 它定义用来应用于动画的时间.<span class="string">"slow"</span>, <span class="string">"fast"</span>, <span class="string">"normal"</span> 或 ms</span><br><span class="line">	stop()停止当前元素所有正在运行的动画。</span><br><span class="line">	delay(duration,[queuename])延迟执行之后的项目,会阻塞之后的任务,属于同步任务</span><br><span class="line">	finish([queue]) 停止并完成匹配元素所有的动画</span><br><span class="line">	jQuery.fx.off =<span class="literal">true</span>; 关闭所有动画</span><br><span class="line"></span><br><span class="line">由于 JavaScript 语句（指令）是逐一执行的 - 按照次序，动画之后的语句可能会产生错误或页面冲突，因为动画还没有完成。</span><br><span class="line">为了避免这个情况，您可以以参数的形式添加 Callback 函数。</span><br></pre></td></tr></table></figure>

<p>​        </p>
<h3 id="7-插件机制"><a href="#7-插件机制" class="headerlink" title="7.插件机制"></a>7.插件机制</h3><ul>
<li><code>jQuery.extend = jQuery.fn.extend</code> 为<code>jQuery</code>框架添加静态或实例方法</li>
</ul>
<h2 id="jQuery-Tips"><a href="#jQuery-Tips" class="headerlink" title="jQuery Tips"></a>jQuery Tips</h2><ol>
<li><p><code>length</code>属性或<code>$(&quot;#box&quot;)[0]</code>判断元素是否存在</p>
</li>
<li><p><code>eq(i)</code>获得<code>jq</code>对象，<code>get(i)</code>或<code>[i]</code>获得<code>DOM</code>对象</p>
</li>
<li><p><code>is()</code>方法十分强大，如<code>is(&#39;:animated&#39;)</code></p>
</li>
<li><p>判断是否为外部链接 <code>this.hostname == location.hostname</code></p>
</li>
<li><p>禁止右键: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(&quot;contextmenu&quot;,function(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不允许复制粘贴<br><code>.attr(&#39;unselectable&#39;, &#39;on&#39;).css(&#39;user-select&#39;, &#39;none&#39;).on(&#39;selectstart&#39;, false)</code></p>
</li>
<li><p>借助<code>a</code>标签解析<code>url</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let url = &apos;http://tutorialzine.com/books/jquery-trickshots?trick=12#comments&apos;;</span><br><span class="line">   let $a = $(&apos;&lt;a&gt;&apos;, &#123;</span><br><span class="line">       href: url</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   let obj = &#123;</span><br><span class="line">       hostName: $a.prop(&apos;hostname&apos;),</span><br><span class="line">       pathName: $a.prop(&apos;pathname&apos;),</span><br><span class="line">       queryString: $a.prop(&apos;search&apos;),</span><br><span class="line">       protocal: $a.prop(&apos;protocol&apos;),</span><br><span class="line">       hash: $a.prop(&apos;hash&apos;)</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重复函数只定义一次</p>
</li>
<li><p>给<code>html</code>元素分配一个<code>.JS</code>类名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    $(&apos;html&apos;).addClass(&apos;JS&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//css</span><br><span class="line">html.JS #message &#123; display:block; &#125;  支持js则显示</span><br><span class="line">#message &#123;display:none;&#125;  不支持js则不显示元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>on()</code>方法可以监听还不存在的事件,且可设置多个同类型事件</p>
</li>
<li><p>一次性事件<code>one()</code></p>
</li>
<li><p>可以通过<code>trigger()</code>模拟触发事件</p>
</li>
<li><p>更快阻止默认事件行为<code>$(&quot;a&quot;).click(false)</code></p>
</li>
<li><p>使用<code>event.result</code>连接多个事件处理程序</p>
</li>
<li><p>创建自己的事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wrap = $(&quot;.wrap&quot;);</span><br><span class="line">   wrap.on(&apos;jump&apos;, function(e, data) &#123;</span><br><span class="line">       console.log(&apos;jump&apos;);</span><br><span class="line">   &#125;);</span><br><span class="line">   $(&quot;#btn&quot;).click(function() &#123;</span><br><span class="line">       wrap.trigger(&apos;jump&apos;, [&apos;jump&apos;]);  //触发自定义事件,并传参</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用延迟简化<code>ajax</code>请求</p>
</li>
<li><p>平行运行多个<code>ajax</code>请求<br><code>$.when($.ajax(),$.ajax()).done(function(a1,a2))</code>a1,a2分别是两个请求的参数组成的数组<code>1:响应体, 2:回调类型, 3:jqXHR对象</code></p>
</li>
<li><p>自动修复失效图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;img&apos;).on(&apos;error&apos;, function() &#123;</span><br><span class="line">       if (!$(this).hasClass(&apos;broken-image&apos;)) &#123;</span><br><span class="line">           $(this).prop(&apos;src&apos;, &apos;img/broken.png&apos;).addClass(&apos;broken-image&apos;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>悬停切换class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).hover(function() &#123;</span><br><span class="line">       $(this).toggleClass(&apos;hover&apos;);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jQuery性能优化"><a href="#jQuery性能优化" class="headerlink" title="jQuery性能优化"></a>jQuery性能优化</h2><h4 id="使用合适的选择器"><a href="#使用合适的选择器" class="headerlink" title="使用合适的选择器"></a>使用合适的选择器</h4><ul>
<li><code>$(&quot;#id&quot;)</code> 最佳提高性能的方式。因为底层直接调用<code>document.getElementById()</code></li>
<li><code>$(&quot;p&quot;)</code>、<code>$(&quot;div&quot;)</code>、<code>$(&quot;input&quot;)</code> 性能优化第二选择，因为 jQuery 也是直接调用 JS 原生方法</li>
<li><code>$(&quot;.class&quot;)</code> 这是 jQuery 封装的函数，ie9+ 以上是使用 JS 的原生方法，ie9 一下是使用 <strong>DOM 搜索</strong>方式来实现</li>
<li><code>$(&quot;[attribute=value]&quot;)</code>：利用属性来定位 DOM 元素，大部分都是使用 <strong>DOM 搜索</strong>方式来达到效果。所以<strong>性能</strong>并不是很理想</li>
<li><code>$(&quot;:hidden&quot;)</code>：需要搜索每一个元素来定位这个选择器，所以尽量不要使用。</li>
</ul>
<h4 id="缓存选择器"><a href="#缓存选择器" class="headerlink" title="缓存选择器"></a>缓存选择器</h4><ul>
<li>缓存对象,不要让相同的选择器在你的代码中出现多次。</li>
<li>尽量减少DOM操作</li>
</ul>
<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;myTable&quot;).click(function()&#123;</span><br><span class="line">       var $clicked =  $(e.target);   // 捕捉到触发的目标元素</span><br><span class="line">       $clicked.css(&quot;background&quot;,&apos;red&apos;);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>也可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;myTable td&quot;).on(&apos;click&apos;,&apos;td&apos;, function()&#123;</span><br><span class="line">       $(this).css(&quot;background&quot;,&apos;red&apos;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2019/08/16/js/基础/08_Web API/" class="prev">PREV</a><a href="/2019/08/15/js/基础/07_数据存储技术/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/08/15/js/库/jQuery/';
var disqus_title = 'jQuery API';
var disqus_url = 'https://turing5467.github.io/2019/08/15/js/库/jQuery/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2019 - 2020 <a href="https://turing5467.github.io">turing5467</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>