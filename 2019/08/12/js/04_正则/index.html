<!DOCTYPE html><html lang="cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 正则表达式 · 快乐的图小灵</title><meta name="description" content="正则表达式 - turing5467"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favi.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://turing5467.github.io/atom.xml" title="快乐的图小灵"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">图小灵的博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="https://github.com/turing5467" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">正则表达式</h1><div class="post-info">Aug 12, 2019</div><div class="post-content"><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则相关方法"><a href="#正则相关方法" class="headerlink" title="正则相关方法"></a>正则相关方法</h3><ul>
<li><p>RegExp原型上的方法</p>
<ol>
<li><code>test(str)</code> 是否匹配</li>
<li><code>exec(str)</code>  每次调用，返回一个匹配的结果，匹配结果和分组以数组的形式返回，不断的调用即可返回下一个结果，直到返回null</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Here is a Phone Number 111-2313 and 133-2311"</span> ;</span><br><span class="line"><span class="keyword">var</span> srg = <span class="regexp">/(\d&#123;3&#125;)[-.]\d&#123;4&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = srg.exec(str);</span><br><span class="line"><span class="keyword">while</span>(result !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    result = srg.exec(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>String原型上的方法</p>
<ol>
<li><p><code>match</code></p>
<ul>
<li><p>如果未使用<strong>g</strong>标志，则仅返回<strong>第一个</strong>完整匹配及其相关的<strong>捕获组</strong>组成的<strong>数组</strong>   </p>
</li>
<li><p>如果使用<strong>g</strong>标志，  则将返回与完整正则表达式匹配的所有结果的<strong>数组</strong>，但不会返回捕获组，或者未匹配 null。   </p>
</li>
</ul>
</li>
<li><p><code>replace(reg, newStr | Function)</code> 不修改原字符串，只是返回修改后的字符串（g：替换全部；不带g：只替换第一个）</p>
</li>
<li><p><code>search</code> 返回匹配字符串的位置</p>
</li>
<li><p><code>split</code> 按照匹配规则拆分字符串</p>
</li>
</ol>
</li>
</ul>
<h3 id="组成元素"><a href="#组成元素" class="headerlink" title="组成元素"></a>组成元素</h3><ul>
<li><p>字符：  基础的计算机字符编码   </p>
</li>
<li><p>元字符：也被称为<strong>特殊字符</strong>，表示特殊语义的字符</p>
<ul>
<li><p>本身是特殊字符，转义后失去原本的含义</p>
<ul>
<li><code>() [] {} \ ^ $ |  ? * + .</code></li>
</ul>
</li>
<li><p>本身不是特殊字符，转义后具有特殊含义 </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>换行符</td>
<td>\n</td>
</tr>
<tr>
<td>换页符</td>
<td>\f</td>
</tr>
<tr>
<td>回车</td>
<td>\r</td>
</tr>
<tr>
<td>空白</td>
<td>\s</td>
</tr>
<tr>
<td>制表符</td>
<td>\t</td>
</tr>
<tr>
<td>垂直制表符</td>
<td>\v</td>
</tr>
<tr>
<td>会退符</td>
<td><code>[\b]</code>，之所以使用<code>[]</code>符号是避免和<code>\b</code>重复</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>多个字符</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>除<code>\n</code>之外的任意字符</td>
</tr>
<tr>
<td>\d</td>
<td>单个数字：0-9</td>
</tr>
<tr>
<td>\D</td>
<td></td>
</tr>
<tr>
<td>\w</td>
<td><code>[0-9a-zA-Z_]</code></td>
</tr>
<tr>
<td>\W</td>
<td></td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白字符,包括空格、制表符、换页符和换行符</td>
</tr>
<tr>
<td>\S</td>
<td></td>
</tr>
<tr>
<td>\b</td>
<td>单词结界符</td>
</tr>
<tr>
<td>\B</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>循环与重复</p>
<table>
<thead>
<tr>
<th>{min,  max?}</th>
<th>指定次数</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>0或1次</td>
</tr>
<tr>
<td>+</td>
<td>1次及1次以上</td>
</tr>
<tr>
<td>*</td>
<td>0次或以上</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>位置边界</p>
<table>
<thead>
<tr>
<th>^</th>
<th>字符串开头</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>字符串结尾</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>注：  在<code>[]</code>  中特殊字符不需要转义，可以直接使用 ，如<code>.</code>等</p>
<p>​            在<code>[]</code>  内部的<code>^</code>表示<strong>取反</strong></p>
<p>​            -为第一个字符时，表示原字符，不是第一个字符(a-z)时，表示从a到z   </p>
</blockquote>
<ul>
<li><p>逻辑处理</p>
<ol>
<li><p>与：默认规则，不予讨论</p>
</li>
<li><p>或</p>
<ul>
<li><p><code>[]</code></p>
</li>
<li><p><code>(a|b)</code></p>
</li>
</ul>
</li>
<li><p>非</p>
<ul>
<li><code>[^a]</code></li>
<li>前向/后向负查找（后面会讲）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li><p>所有以<code>(</code>和<code>)</code>元字符所包含的正则表达式被分为一组，每一个<strong>分组</strong>都是一个<strong>子表达式</strong>，它也是构成高级正则表达式的基础。   </p>
</li>
<li><p>整个匹配项为group0，手动分组从 1 开始</p>
</li>
</ul>
<h4 id="分组捕获"><a href="#分组捕获" class="headerlink" title="分组捕获"></a>分组捕获</h4><ul>
<li><p><code>$</code>：用来在<code>replace</code>时进行标志或选择</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"where is tr-"</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(tr)-*/</span>;	<span class="comment">//去除tr后面多余的-</span></span><br><span class="line"><span class="keyword">let</span> s = str.replace(reg, <span class="string">"$1"</span>)</span><br><span class="line"><span class="comment">//s: where is tr</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>\</code>：应用在正则表达式本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"800-800-8828"</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(800)-\1-\d+/</span>;		<span class="comment">//\1表示800，即第一个分组的内容</span></span><br><span class="line">reg.test(str) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>?</code>：可以禁止贪婪属性，表示 一次匹配到重点就可以停止(需要紧跟在量词后)   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"[ali] and [tencent]"</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\[.*\]/g</span>; <span class="comment">//匹配[]及中间的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); </span><br><span class="line"><span class="comment">//["[ali] and [tencent]"] </span></span><br><span class="line"><span class="comment">//哎！咋只匹配到一项咧，这不是我们想要的，原来是因为量词默认贪婪匹配</span></span><br><span class="line"></span><br><span class="line">reg = <span class="regexp">/\[.*?\]/g</span>	<span class="comment">//禁止贪婪属性(将两对[]分开匹配)</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"><span class="comment">//["[ali]", "[tencent]"]</span></span><br><span class="line"><span class="comment">//bingo!这下好了</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="回溯引用"><a href="#回溯引用" class="headerlink" title="回溯引用"></a>回溯引用</h4><ul>
<li>如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>非捕获正则</td>
</tr>
<tr>
<td><code>?=regExp</code></td>
<td>前向查找</td>
</tr>
<tr>
<td><code>?!regExp</code></td>
<td>负前向查找</td>
</tr>
<tr>
<td><code>?&lt;=regExp</code></td>
<td>后向查找</td>
</tr>
<tr>
<td><code>?&lt;!regExp</code></td>
<td>负后向查找</td>
</tr>
</tbody></table>
<ul>
<li>非捕获正则：使子表达式不被引用</li>
<li>前向查找： 从符合指定子表达式的位置出发<strong>向前</strong>查找符合规则的字符串。</li>
<li>后向查找：  从符合指定子表达式的位置出发<strong>向后</strong>查找符合规则的字符串。   </li>
</ul>
<blockquote>
<p>  从es2018之后，chrome中的正则表达式才开始支持反/后向查找。   </p>
</blockquote>
<ul>
<li>文章参考：<a href="https://juejin.im/post/5cdcd42551882568651554e6" target="_blank" rel="noopener">here</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/08/13/js/05_面向对象/" class="prev">上一篇</a><a href="/2019/08/11/js/03_原型链/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/08/12/js/04_正则/';
var disqus_title = '正则表达式';
var disqus_url = 'https://turing5467.github.io/2019/08/12/js/04_正则/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2019 - 2020 <a href="https://turing5467.github.io">turing5467</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>